<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ru/webgl-drawing-multiple-things.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="WebGL - Отрисовка нескольких объектов" />
<meta property="og:type" content="website" />
<meta property="og:image" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />
<meta property="og:description" content="Отображение различных объектов в WebGL" />
<meta property="og:url" content="http://webglfundamentals.org/webgl/lessons/ru/webgl-drawing-multiple-things.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webglfundamentals.org" />
<meta name="twitter:title" content="WebGL - Отрисовка нескольких объектов" />
<meta name="twitter:url" content="http://webglfundamentals.org/webgl/lessons/ru/webgl-drawing-multiple-things.html" />
<meta name="twitter:description" content="Отображение различных объектов в WebGL" />
<meta name="twitter:image:src" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />


<title>WebGL - Отрисовка нескольких объектов</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />
</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-drawing-multiple-things.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-drawing-multiple-things.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-drawing-multiple-things.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-drawing-multiple-things.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-drawing-multiple-things.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-drawing-multiple-things.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-drawing-multiple-things.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-drawing-multiple-things.html" >简体中文</a>
</select>


    <a href="#toc">оглавление</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ru/">WebGLFundamentals.org</a></h1>
</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL - Отрисовка нескольких объектов</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Эта статья продолжает серию, которая начинается с <a href="webgl-fundamentals.html">Основ WebGL</a>.
Если вы ещё не читали предыдущие статьи, предлагаю прочесть по крайней мере первую
из них, а потом вернуться сюда.</p>
<p>Один из самых распространённых вопросов после первых успехов в WebGL -
как отобразить несколько объектов.</p>
<p>Нужно понимать, что за редким исключением WebGL похож на функцию, где
вместо того, чтобы один раз вызвать функцию с кучей параметров, у нас
на руках есть больше 70 функций, которые подготавливают состояние
для этой единственной функции. Для примера представьте, что вам нужна
функция для отрисовки окружности. Вы могли бы написать что-то вроде</p>
<pre class="prettyprint"><code>function drawCircle(centerX, centerY, radius, color) { ... }
</code></pre><p>Или же такой вариант.</p>
<pre class="prettyprint"><code>var centerX;
var centerY;
var radius;
var color;

function setCenter(x, y) {
   centerX = x;
   centerY = y;
}

function setRadius(r) {
   radius = r;
}

function setColor(c) {
   color = c;
}

function drawCircle() {
   ...
}
</code></pre><p>WebGL работает по второму сценарию. Через функции <code>gl.createBuffer</code>,
<code>gl.bufferData</code>, <code>gl.createTexture</code> и <code>gl.texImage2D</code> вы можете загрузить
данные буферов (вершины) и текстур (цвета и прочее) в WebGL. Через функции
<code>gl.createProgram</code>, <code>gl.createShader</code>, <code>gl.compileProgram</code> и <code>gl.linkProgram</code>
вы можете создать шейдеры GLSL. Практически все из оставшихся функций WebGL
устанавливают глобальные переменные или <em>состояние</em>, которое используется
при вызове функции <code>gl.drawArrays</code> или <code>gl.drawElements</code>.</p>
<p>Исходя из вышесказанного типичная программа WebGL придерживается следующей структуры:</p>
<p>При инициализации</p>
<ul>
<li>создаются все шейдеры и программы, получаются ссылки на переменные;</li>
<li>создаются буферы и загружаются данные вершин;</li>
<li>создаются текстуры и загружаются текстурные данные.</li>
</ul>
<p>При рендеринге</p>
<ul>
<li>очищаем и устанавливаем область просмотра и другие глобальные
переменные (включение проверки глубины, отбраковки и других);</li>
<li>Для каждого объекта, который будем отрисовывать:<ul>
<li>устанавливаем активную программу через <code>gl.useProgram</code>;</li>
<li>настраиваем атрибуты:<ul>
<li>для каждого атрибута вызываем <code>gl.bindBuffer</code>,
<code>gl.vertexAttribPointer</code>, <code>gl.enableVertexAttribArray</code>;</li>
</ul>
</li>
<li>настраиваем uniform-переменные:<ul>
<li>для каждой переменной вызываем <code>gl.uniformXXX</code>;</li>
<li>вызываем <code>gl.activeTexture</code> и <code>gl.bindTexture</code> для привязки
текстур к текстурным блокам;</li>
</ul>
</li>
<li>вызываем <code>gl.drawArrays</code> или <code>gl.drawElements</code>.</li>
</ul>
</li>
</ul>
<p>Вот, собственно, и всё. От вас уже зависит, как организовать свой
код, чтобы выполнить этот сценарий.</p>
<p>Некоторые данные (например, данные текстур или даже вершин) могут передаваться
асинхронно и нужно дождаться, пока они загрузятся по сети.</p>
<p>Сделаем простое приложение, которое отобразит 3 объекта - куб, сферу и конус.</p>
<p>Не буду углубляться в детали вычисления координат куба, сферы и конуса.
Просто предположим, что у нас есть функции для создания этих 3 объектов,
которые вернут <a href="webgl-less-code-more-fun.html">объекты bufferInfo, рассмотренные в предыдущей
статье</a>.</p>
<p>Итак, код. Наш шейдер практически не изменился с последнего
<a href="webgl-3d-perspective.html">примера о перспективе</a>, за исключением того,
что добавился <code>u_colorMult</code>, на который умножатся цвета вершин.</p>
<pre class="prettyprint"><code>// Передаётся из вершинного шейдера
varying vec4 v_color;

uniform vec4 u_colorMult;

void main() {
   gl_FragColor = v_color * u_colorMult;
}
</code></pre><p>При инициализации:</p>
<pre class="prettyprint"><code>// uniform-переменные для каждого отображаемого объекта
var sphereUniforms = {
  u_colorMult: [0.5, 1, 0.5, 1],
  u_matrix: m4.identity(),
};
var cubeUniforms = {
  u_colorMult: [1, 0.5, 0.5, 1],
  u_matrix: m4.identity(),
};
var coneUniforms = {
  u_colorMult: [0.5, 0.5, 1, 1],
  u_matrix: m4.identity(),
};

// Перенос каждого объекта
var sphereTranslation = [  0, 0, 0];
var cubeTranslation   = [-40, 0, 0];
var coneTranslation   = [ 40, 0, 0];
</code></pre><p>При рендеринге:</p>
<pre class="prettyprint"><code>var sphereXRotation =  time;
var sphereYRotation =  time;
var cubeXRotation   = -time;
var cubeYRotation   =  time;
var coneXRotation   =  time;
var coneYRotation   = -time;

// ------ Отрисовка сферы --------

gl.useProgram(programInfo.program);

// Устанавливаем все необходимые атрибуты
webglUtils.setBuffersAndAttributes(gl, programInfo, sphereBufferInfo);

sphereUniforms.u_matrix = computeMatrix(
    viewProjectionMatrix,
    sphereTranslation,
    sphereXRotation,
    sphereYRotation);

// Устанавливаем рассчитанные uniform-переменные
webglUtils.setUniforms(programInfo, sphereUniforms);

gl.drawArrays(gl.TRIANGLES, 0, sphereBufferInfo.numElements);

// ------ Отрисовываем куб --------

// Устанавливаем все необходимые атрибуты
webglUtils.setBuffersAndAttributes(gl, programInfo, cubeBufferInfo);

cubeUniforms.u_matrix = computeMatrix(
    viewProjectionMatrix,
    cubeTranslation,
    cubeXRotation,
    cubeYRotation);

// Устанавливаем рассчитанные uniform-переменные
webglUtils.setUniforms(programInfo, cubeUniforms);

gl.drawArrays(gl.TRIANGLES, 0, cubeBufferInfo.numElements);

// ------ Отрисовываем конус --------

// Устанавливаем все необходимые атрибуты
webglUtils.setBuffersAndAttributes(gl, programInfo, coneBufferInfo);

coneUniforms.u_matrix = computeMatrix(
    viewProjectionMatrix,
    coneTranslation,
    coneXRotation,
    coneYRotation);

// Устанавливаем рассчитанные uniform-переменные
webglUtils.setUniforms(programInfo, coneUniforms);

gl.drawArrays(gl.TRIANGLES, 0, coneBufferInfo.numElements);
</code></pre><p>И вот результат.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-multiple-objects-manual.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-multiple-objects-manual.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Заметьте, что мы вызываем <code>gl.useProgram</code> лишь один раз, так как у нас
есть всего одна шейдерная программа. Если бы у нас было несколько шейдерных
программ, нам бы потребовалось вызывать <code>gl.useProgram</code> перед... эм...
использованием каждой программы.</p>
<p>Есть ещё одно место, где не помешало бы упрощение. По сути есть
3 основных вещи, которые можно объединить.</p>
<ol>
<li>Шейдерная программа (и её сеттеры атрибутов и uniform-переменных);</li>
<li>Буфер и атрибуты рисуемого объекта;</li>
<li>uniform-переменные, необходимые для отрисовки объекта через данный шейдер.</li>
</ol>
<p>Небольшим упрощением будет создание массива объектов для отрисовки и
помещением в него 3 наших объектов.</p>
<pre class="prettyprint"><code>var objectsToDraw = [
  {
    programInfo: programInfo,
    bufferInfo: sphereBufferInfo,
    uniforms: sphereUniforms,
  },
  {
    programInfo: programInfo,
    bufferInfo: cubeBufferInfo,
    uniforms: cubeUniforms,
  },
  {
    programInfo: programInfo,
    bufferInfo: coneBufferInfo,
    uniforms: coneUniforms,
  },
];
</code></pre><p>При отрисовке нам нужно обновить матрицы</p>
<pre class="prettyprint"><code>var sphereXRotation =  time;
var sphereYRotation =  time;
var cubeXRotation   = -time;
var cubeYRotation   =  time;
var coneXRotation   =  time;
var coneYRotation   = -time;

// Задаём матрицы для каждого объекта
sphereUniforms.u_matrix = computeMatrix(
    viewProjectionMatrix,
    sphereTranslation,
    sphereXRotation,
    sphereYRotation);

cubeUniforms.u_matrix = computeMatrix(
    viewProjectionMatrix,
    cubeTranslation,
    cubeXRotation,
    cubeYRotation);

coneUniforms.u_matrix = computeMatrix(
    viewProjectionMatrix,
    coneTranslation,
    coneXRotation,
    coneYRotation);
</code></pre><p>И теперь код отрисовки - это просто цикл</p>
<pre class="prettyprint"><code>// ------ Отрисовка объектов --------

objectsToDraw.forEach(function(object) {
  var programInfo = object.programInfo;
  var bufferInfo = object.bufferInfo;

  gl.useProgram(programInfo.program);

  // Устанавливаем все необходимые атрибуты
  webglUtils.setBuffersAndAttributes(gl, programInfo, bufferInfo);

  // Задаём uniform-переменные
  webglUtils.setUniforms(programInfo, object.uniforms);

  // Отрисовываем
  gl.drawArrays(gl.TRIANGLES, 0, bufferInfo.numElements);
});
</code></pre><p>И это, вероятно, основной цикл отрисовки большинства существующих 3D-движков.
Где-то в другом месте код решает, что будет передано в массив <code>objectsToDraw</code>,
но в целом схема такова.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-multiple-objects-list.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-multiple-objects-list.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Есть ещё несколько оптимизаций. Если программа для текущей отрисовки не
изменилась с предыдущей отрисовки, нам не нужно вызывать <code>gl.useProgram</code>.
Аналогично, если мы отрисовываем тот же объект/геометрию/вершину, нам
не нужно устанавливать их снова.</p>
<p>Очень простая оптимизация может выглядеть следующим образом:</p>
<pre class="prettyprint"><code>var lastUsedProgramInfo = null;
var lastUsedBufferInfo = null;

objectsToDraw.forEach(function(object) {
  var programInfo = object.programInfo;
  var bufferInfo = object.bufferInfo;
  var bindBuffers = false;

  if (programInfo !== lastUsedProgramInfo) {
    lastUsedProgramInfo = programInfo;
    gl.useProgram(programInfo.program);

    // Нам нужно перепривязать буферы при изменении программы, так как
    // в программе используются только текущие буферы. Поэтому когда 2
    // программы используют один bufferInfo, и первая из них использует
    // только координаты, то при переключении на вторую программу
    // некоторые атрибуты не будут включены.
    bindBuffers = true;
  }

  // Устанавливаем все необходимые атрибуты
  if (bindBuffers || bufferInfo != lastUsedBufferInfo) {
    lastUsedBufferInfo = bufferInfo;
    webglUtils.setBuffersAndAttributes(gl, programInfo, bufferInfo);
  }

  // Задаём uniform-переменные
  webglUtils.setUniforms(programInfo, object.uniforms);

  // Отрисовываем
  gl.drawArrays(gl.TRIANGLES, 0, bufferInfo.numElements);
});
</code></pre><p>А теперь давайте создадим много объектов. Вместо 3 объектов мы сделаем
значительно больший массив объектов.</p>
<pre class="prettyprint"><code>// записываем фигуры в массив, чтобы было проще выбрать случайную
var shapes = [
  sphereBufferInfo,
  cubeBufferInfo,
  coneBufferInfo,
];

// создаём два списка объектов - один для отрисовки, один для управления
var objectsToDraw = [];
var objects = [];

// Uniform-переменные для каждого объекта
var numObjects = 200;
for (var ii = 0; ii &lt; numObjects; ++ii) {
  // Выбираем фигуру
  var bufferInfo = shapes[rand(0, shapes.length) | 0];

  // Создаём объект
  var object = {
    uniforms: {
      u_colorMult: [rand(0, 1), rand(0, 1), rand(0, 1), 1],
      u_matrix: m4.identity(),
    },
    translation: [rand(-100, 100), rand(-100, 100), rand(-150, -50)],
    xRotationSpeed: rand(0.8, 1.2),
    yRotationSpeed: rand(0.8, 1.2),
  };
  objects.push(object);

  // Добавляем его в массив объектов для отрисовки
  objectsToDraw.push({
    programInfo: programInfo,
    bufferInfo: bufferInfo,
    uniforms: object.uniforms,
  });
}
</code></pre><p>При рендеринге</p>
<pre class="prettyprint"><code>// Вычисляем матрицы для каждого объекта
objects.forEach(function(object) {
  object.uniforms.u_matrix = computeMatrix(
      viewMatrix,
      projectionMatrix,
      object.translation,
      object.xRotationSpeed * time,
      object.yRotationSpeed * time);
});
</code></pre><p>Затем отрисовываем объекты с помощью описанного выше цикла отрисовки.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-multiple-objects-list-optimized.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-multiple-objects-list-optimized.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Вы также можете отсортировать массив по <code>programInfo</code> и/или <code>bufferInfo</code>,
чтобы оптимизация срабатывала намного чаще. Большая часть игровых движков
именно так и делает. К сожалению, это не так-то просто. Если все объекты
непрозрачные, то подойдёт простая сортировка. Но если вам нужны полупрозрачные
объекты, порядок будет отличаться. Создаётся один массив для непрозрачных
объектов. Второй - для прозрачных. Массив с непрозрачными объектами сортируется
по программе и геометрии. Массив с прозрачными объектами сортируется по глубине.
Кроме этих массивов могут существовать и другие - например, для наложений
или для пост-эффектов.</p>
<p><a href="../../webgl-multiple-objects-list-optimized-sorted.html"
target="_blank">Вот пример с сортировкой</a>. На моём компьютере выдаёт
~31fps на несортированном списке и ~37 на сортированном. Это около 20%
прироста. Но это худший пример против лучшего, у большинства программ
логика гораздо сложнее, поэтому о подобной оптимизации стоит задумываться
только в отдельных случаях.</p>
<p>Стоит заметить, что нельзя просто так отрисовать любую геометрию с помощью
любого шейдера. Например, шейдер, в котором идёт работа с нормалями, не
будет работать с геометрией без нормалей. Аналогично, шейдер, в котором
есть работа с текстурами, не будет работать без текстур.</p>
<p>Это одна из многих причин, по которой лучше выбрать 3D-библиотеку вроде
<a href="http://threejs.org">Three.js</a>, так как она сделает всё за вас. Вы
создаёте геометрию, сообщаете three.js, как её нужно отрисовать и
библиотека создаёт шейдеры во время выполнения, чтобы покрыть все ваши
запросы. Практически все 3D-движки обладают подобными возможностями -
начиная от Unity3D и заканчивая движками Unreal, Source и Crytek.
Некоторые из них генерируют шейдеры автономно, но главное здесь то, что
они <em>генерируют</em> их.</p>
<p>Само собой, вы читаете эту статью, потому что хотите знать, что происходит
на нижнем уровне. Это замечательно и интересно писать всё самому. Просто
помните, что <a href="webgl-2d-vs-3d-library.html">WebGL очень низкоуровневый</a>,
поэтому вам придётся самому сделать тонну работы, включая написание
генератора шейдеров, потому что разные свойства требуют разных шейдеров.</p>
<p>Обратите внимание, что я не внёс <code>computeMatrix</code> внутрь цикла. Потому что
я считаю, что рендеринг должен быть отделён от вычисления матриц.
Общепринятым подходом является вычисление матриц из
<a href="webgl-scene-graph.html">графа сцен, который мы рассмотрим в следующей статье</a>.</p>
<p>Ну а теперь, когда у нас есть основа для отрисовки нескольких объектов,
<a href="webgl-text-html.html">добавим текст на сцену</a>.</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-drawing-multiple-things.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-drawing-multiple-things.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-drawing-multiple-things.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-drawing-multiple-things.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-drawing-multiple-things.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-drawing-multiple-things.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-drawing-multiple-things.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-drawing-multiple-things.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Основы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-fundamentals.html">Основы WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-how-it-works.html">Как работает WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-shaders-and-glsl.html">Шейдеры и GLSL в WebGL</a></li>
        </ul>
  <li>Обработка изображений</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-image-processing.html">Обработка изображений в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-image-processing-continued.html">Продолжаем обработку изображений в WebGL</a></li>
        </ul>
  <li>Математика переноса, поворота и масштабирования в 2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-translation.html">2D-перенос в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-rotation.html">2D-поворот в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-scale.html">2D-масштабирование в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrices.html">2D-матрицы в WebGL</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-orthographic.html">WebGL 3D - Ортогональ</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective.html">WebGL 3D - Перспектива</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-camera.html">WebGL 3D - Камеры</a></li>
        </ul>
  <li>Освещение</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-lighting-directional.html">WebGL 3D - Направленное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-point.html">WebGL 3D - Точечное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-spot.html">WebGL 3D - Прожектор</a></li>
        </ul>
  <li>Структура и устройство</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-less-code-more-fun.html">WebGL - Меньше кода, больше веселья</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-multiple-things.html">WebGL - Отрисовка нескольких объектов</a></li>
<li><a href="/webgl/lessons/ru/webgl-scene-graph.html">WebGL - Графы сцены</a></li>
        </ul>
  <li>Геометрия</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-geometry-lathe.html">WebGL 3D - Создание модели</a></li>
        </ul>
  <li>Текстуры</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-textures.html">WebGL 3D - Текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-data-textures.html">WebGL - Данные для текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-2-textures.html">WebGL - Использование 2 и более текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-cors-permission.html">WebGL - Кросс-доменные изображения</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective-correct-texturemapping.html">WebGL 3D - Перспективная коррекция текстур</a></li>
        </ul>
  <li>Рендеринг в текстуру</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-render-to-texture.html">WebGL - Рендеринг в текстуру</a></li>
        </ul>
  <li>Приёмы</li>
        <ul>
          <ul>  <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-drawimage.html">WebGL 2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrix-stack.html">WebGL 2D - Стек матриц</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-cube-maps.html">WebGL - Cubemaps</a></li>
<li><a href="/webgl/lessons/ru/webgl-environment-maps.html">WebGL - Environment maps</a></li>
<li><a href="/webgl/lessons/ru/webgl-skybox.html">WebGL - Skyboxes</a></li>
<li><a href="/webgl/lessons/ru/webgl-skinning.html">WebGL - Skinning</a></li>
<li><a href="/webgl/lessons/ru/webgl-fog.html">WebGL - Fog</a></li>
        </ul>
  <li>Текст</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-text-html.html">WebGL текст - HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-canvas2d.html">WebGL текст - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-texture.html">WebGL текст - Используем текстуру</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-glyphs.html">WebGL текст - Используем глиф-текстуру</a></li>
        </ul></ul>
        </ul>
  <li>Разное</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-setup-and-installation.html">WebGL Установка и настройка</a></li>
<li><a href="/webgl/lessons/ru/webgl-boilerplate.html">Шаблон WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-resizing-the-canvas.html">Изменение размера Canvas в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-animation.html">WebGL - Анимация</a></li>
<li><a href="/webgl/lessons/ru/webgl-and-alpha.html">WebGL и прозрачность</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-vs-3d-library.html">WebGL - 2D и 3D библиотеки</a></li>
<li><a href="/webgl/lessons/ru/webgl-anti-patterns.html">WebGL - Антипаттерны</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-attributes.html">WebGL Attributes</a></li>
<li><a href="/webgl/lessons/ru/webgl-texture-units.html">WebGL Texture Units</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Документация по вспомогательным функциям</a></li>
  <li><a href="http://twgljs.org">TWGL, лёгкая библиотека-помощник для WebGL</a></li>
  <li><a href="https://github.com/greggman/webgl-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>Вопросы? <a href="http://stackoverflow.com/questions/tagged/webgl">Спросите на stackoverflow</a>.</div>
        <div>Нашли ошибку? <a href="http://github.com/greggman/webgl-fundamentals/issues">Создайте задачу на github</a>.</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL - Отрисовка нескольких объектов';
            var disqus_title = 'WebGL - Отрисовка нескольких объектов';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script src="//cdn.webglstats.com/stat.js" defer="defer" async="async"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');

</script>


</html>



