<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ru/webgl-3d-orthographic.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="WebGL 3D - Ортогональ" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />
<meta property="og:description" content="Знакомимся с 3D в WebGL, начиная с ортографической проекции." />
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/ru/webgl-3d-orthographic.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webglfundamentals.org" />
<meta name="twitter:title" content="WebGL 3D - Ортогональ" />
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/ru/webgl-3d-orthographic.html" />
<meta name="twitter:description" content="Знакомимся с 3D в WebGL, начиная с ортографической проекции." />
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />


<title>WebGL 3D - Ортогональ</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />
</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-3d-orthographic.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-3d-orthographic.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-3d-orthographic.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-3d-orthographic.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-3d-orthographic.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-3d-orthographic.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-3d-orthographic.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-3d-orthographic.html" >简体中文</a>
</select>


    <a href="#toc">оглавление</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ru/">WebGLFundamentals.org</a></h1>
</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL 3D - Ортогональ</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Эта статья продолжает серию статей о WebGL. В первой из них
<a href="webgl-fundamentals.html">мы начали с основ WebGL</a>, а в предыдущей
<a href="webgl-2d-matrices.html">узнали о 2D-матрицах</a>. Если вы их ещё не
читали, рекомендую ознакомиться сначала с ними.</p>
<p>В последней статье мы разобрали, как работают матрицы в 2D. Мы выяснили,
как перенос, поворот, масштабирование и даже проецирование пикселей в
пространство отсечения могут быть выполнены с помощью одной матрицы и
небольшой доли магии математики. 3D - это лишь небольшой дополнительный
шаг от 2D-матриц.</p>
<p>В наших предыдущих 2D-примерах у нас было две точки (x, y), которые мы
умножали на матрицу 3х3. В 3D нам нужно 3 точки (x, y, z) и матрицы 4х4.</p>
<p>Возьмём наш последний пример и перенесём его в 3D-пространство. Мы
по-прежнему будем использовать &#39;F&#39;, но на этот раз это будет &#39;F&#39; в 3D.</p>
<p>Первым делом нам нужно поменять вершинный шейдер для работы в 3D.
Вот старый вершинный шейдер:</p>
<pre class="prettyprint"><code>&lt;script id=&quot;2d-vertex-shader&quot; type=&quot;x-shader/x-vertex&quot;&gt;
attribute vec2 a_position;

uniform mat3 u_matrix;

void main() {
  // Умножаем координату на матрицу
  gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);
}
&lt;/script&gt;
</code></pre><p>А вот новый:</p>
<pre class="prettyprint"><code>&lt;script id=&quot;3d-vertex-shader&quot; type=&quot;x-shader/x-vertex&quot;&gt;
*attribute vec4 a_position;

*uniform mat4 u_matrix;

void main() {
  // Умножаем координату на матрицу
*  gl_Position = u_matrix * a_position;
}
&lt;/script&gt;
</code></pre><p>Он стал даже проще! Если в 2D-пространстве мы передавали <code>x</code> и <code>y</code>,
а <code>z</code> устанавливали в 1, в 3D мы мы передаём <code>x</code>, <code>y</code> и <code>z</code>. Ещё нам
нужно, чтобы <code>w</code> равнялось единице, но здесь мы воспользуемся тем, что
для атрибута <code>w</code> значение по умолчанию как раз равно 1.</p>
<p>Теперь нам нужно передать 3D-данные.</p>
<pre class="prettyprint"><code>  ...

  // Указываем атрибуту, как получать данные от positionBuffer (ARRAY_BUFFER)
*  var size = 3;          // 3 компоненты на итерацию
  var type = gl.FLOAT;    // наши данные - 32-битные числа с плавающей точкой
  var normalize = false;  // не нормализовать данные
  var stride = 0;         // 0 = перемещаться на size * sizeof(type) каждую итерацию для получения следующего положения
  var offset = 0;         // начинать с начала буфера
  gl.vertexAttribPointer(
      positionAttributeLocation, size, type, normalize, stride, offset);

  ...

// Заполняем текущий буфер ARRAY_BUFFER.
// Передаём значения, описывающие букву &#39;F&#39;.
function setGeometry(gl) {
  gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([
          // вертикальный столб
            0,   0,  0,
           30,   0,  0,
            0, 150,  0,
            0, 150,  0,
           30,   0,  0,
           30, 150,  0,

          // верхняя перекладина
           30,   0,  0,
          100,   0,  0,
           30,  30,  0,
           30,  30,  0,
          100,   0,  0,
          100,  30,  0,

          // перекладина посередине
           30,  60,  0,
           67,  60,  0,
           30,  90,  0,
           30,  90,  0,
           67,  60,  0,
           67,  90,  0]),
      gl.STATIC_DRAW);
}
</code></pre><p>Теперь нам нужно поменять все функции по работе с матрицами из 2D в 3D.</p>
<p>Вот предыдущие 2D-версии функций m3.translation, m3.rotation и m3.scaling.</p>
<pre class="prettyprint"><code>var m3 = {
  translation: function translation(tx, ty) {
    return [
      1, 0, 0,
      0, 1, 0,
      tx, ty, 1
    ];
  },

  rotation: function rotation(angleInRadians) {
    var c = Math.cos(angleInRadians);
    var s = Math.sin(angleInRadians);
    return [
      c,-s, 0,
      s, c, 0,
      0, 0, 1
    ];
  },

  scaling: function scaling(sx, sy) {
    return [
      sx, 0, 0,
      0, sy, 0,
      0, 0, 1
    ];
  },
};
</code></pre><p>А вот обновлённые версии функций для 3D.</p>
<pre class="prettyprint"><code>var m4 = {
  translation: function(tx, ty, tz) {
    return [
       1,  0,  0,  0,
       0,  1,  0,  0,
       0,  0,  1,  0,
       tx, ty, tz, 1,
    ];
  },

  xRotation: function(angleInRadians) {
    var c = Math.cos(angleInRadians);
    var s = Math.sin(angleInRadians);

    return [
      1, 0, 0, 0,
      0, c, s, 0,
      0, -s, c, 0,
      0, 0, 0, 1,
    ];
  },

  yRotation: function(angleInRadians) {
    var c = Math.cos(angleInRadians);
    var s = Math.sin(angleInRadians);

    return [
      c, 0, -s, 0,
      0, 1, 0, 0,
      s, 0, c, 0,
      0, 0, 0, 1,
    ];
  },

  zRotation: function(angleInRadians) {
    var c = Math.cos(angleInRadians);
    var s = Math.sin(angleInRadians);

    return [
       c, s, 0, 0,
      -s, c, 0, 0,
       0, 0, 1, 0,
       0, 0, 0, 1,
    ];
  },

  scaling: function(sx, sy, sz) {
    return [
      sx, 0,  0,  0,
      0, sy,  0,  0,
      0,  0, sz,  0,
      0,  0,  0,  1,
    ];
  },
};
</code></pre><p>Заметьте, что у нас теперь 3 функции поворота. В 2D нам было достаточно
одной, чтобы вращение было только вокруг оси Z. Однако, в 3D нам нужно
также уметь выполнять поворот вокруг оси X и оси Y. Они все очень похожи
друг на друга. Если бы нам понадобилось вывести их, мы бы увидели, что
они упрощаются тем же способом.</p>
<p>Поворот вокруг Z</p>
<div class="webgl_center">
<div>newX = x *  c + y * s;</div>
<div>newY = x * -s + y * c;</div>
</div>

<p>Поворот вокруг Y</p>
<div class="webgl_center">
<div>newX = x *  c + z * s;</div>
<div>newZ = x * -s + z * c;</div>
</div>

<p>Поворот вокруг X</p>
<div class="webgl_center">
<div>newY = y *  c + z * s;</div>
<div>newZ = y * -s + z * c;</div>
</div>

<p>И мы получаем наши повороты.</p>
<iframe class="external_diagram" src="../resources/axis-diagram.html" style="width: 540px; height: 240px;"></iframe>

<p>Подобным образом мы сделаем упрощённые функции.</p>
<pre class="prettyprint"><code>  translate: function(m, tx, ty, tz) {
    return m4.multiply(m, m4.translation(tx, ty, tz));
  },

  xRotate: function(m, angleInRadians) {
    return m4.multiply(m, m4.xRotation(angleInRadians));
  },

  yRotate: function(m, angleInRadians) {
    return m4.multiply(m, m4.yRotation(angleInRadians));
  },

  zRotate: function(m, angleInRadians) {
    return m4.multiply(m, m4.zRotation(angleInRadians));
  },

  scale: function(m, sx, sy, sz) {
    return m4.multiply(m, m4.scaling(sx, sy, sz));
  },
</code></pre><p>Нам также нужно изменить проекционную функцию. Старая функция:</p>
<pre class="prettyprint"><code>  projection: function (width, height) {
    // Эта матрица переворачивает Y, чтобы 0 был наверху
    return [
      2 / width, 0, 0,
      0, -2 / height, 0,
      -1, 1, 1
    ];
  },
}
</code></pre><p>которая преобразует пиксели в пространство отсечения. Для нашей
первой попытки перехода к 3D попробуем следующее:</p>
<pre class="prettyprint"><code>  projection: function(width, height, depth) {
    // Эта матрица переворачивает Y, чтобы 0 был наверху
    return [
       2 / width, 0, 0, 0,
       0, -2 / height, 0, 0,
       0, 0, 2 / depth, 0,
      -1, 1, 0, 1,
    ];
  },
</code></pre><p>Не забываем конвертировать координату Z из пикселей в пространство отсечения,
как мы делали с координатами X и Y. Мы передаём значение <code>depth</code> для Z по
аналогии с <code>width</code>, и наше пространство будет 0 пикселей шириной по <code>width</code>,
0 пикселей высотой по <code>height</code> и от <code>-depth / 2</code> до <code>+depth / 2</code> пикселей
глубиной по <code>depth</code>.</p>
<p>Наконец, нам нужно изменить код для вычисления матриц.</p>
<pre class="prettyprint"><code>  // Задаём матрицы
*  var matrix = m4.projection(gl.canvas.clientWidth, gl.canvas.clientHeight, 400);
*  matrix = m4.translate(matrix, translation[0], translation[1], translation[2]);
*  matrix = m4.xRotate(matrix, rotation[0]);
*  matrix = m4.yRotate(matrix, rotation[1]);
*  matrix = m4.zRotate(matrix, rotation[2]);
*  matrix = m4.scale(matrix, scale[0], scale[1], scale[2]);

  // Передаём матрицы шейдеру
*  gl.uniformMatrix4fv(matrixLocation, false, matrix);
</code></pre><p>И вот пример.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-step1.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-step1.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Первая проблема заключается в том, что наша геометрия плоская, а по плоской
&#39;F&#39; сложно увидеть 3D. Для устранения этой проблемы перенесём геометрию в 3D.
Наша &#39;F&#39; сейчас сделана из 3 прямоугольников, 2 треугольника в каждом. Для
3D-формы понадобится в сумме 16 прямоугольников - 3 прямоугольника впереди,
3 сзади, один слева, 4 справа, 2 сверху и 3 снизу.</p>
<p><img class="webgl_center nodarkinvert" width="300" src="../resources/3df.svg" /></p>
<p>Довольно много, чтобы перечислять здесь. 16 прямоугольников с двумя треугольниками
на каждый и 3 вершины на каждый треугольник - в сумме 96 вершин. Если хотите
увидеть их все - посмотрите на исходный код примера.</p>
<p>Итак, нам нужно нарисовать больше вершин.</p>
<pre class="prettyprint"><code>    // Отрисовка геометрии
    var primitiveType = gl.TRIANGLES;
    var offset = 0;
*    var count = 16 * 6;
    gl.drawArrays(primitiveType, offset, count);
</code></pre><p>И мы получим пример 3D-геометрии</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-step2.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-step2.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Передвигая слайдеры, довольно сложно определить форму 3D-объекта. Попробуем
раскрасить каждый прямоугольник в свой цвет. Для этого добавим ещё один
атрибут в вершинный шейдер и заведём varying-переменную для передачи значения
из вершинного во фрагментный шейдер.</p>
<p>Вот новый вершинный шейдер:</p>
<pre class="prettyprint"><code>&lt;script id=&quot;3d-vertex-shader&quot; type=&quot;x-shader/x-vertex&quot;&gt;
attribute vec4 a_position;
+attribute vec4 a_color;

uniform mat4 u_matrix;

+varying vec4 v_color;

void main() {
  // Умножаем координату на матрицу
  gl_Position = u_matrix * a_position;

+  // Передаём цвет во фрагментный шейдер
+  v_color = a_color;
}
&lt;/script&gt;
</code></pre><p>Во фрагментном шейдере нам нужно использовать переданный цвет.</p>
<pre class="prettyprint"><code>&lt;script id=&quot;3d-fragment-shader&quot; type=&quot;x-shader/x-fragment&quot;&gt;
precision mediump float;

+// Передаётся из вершинного шейдера
+varying vec4 v_color;

void main() {
*   gl_FragColor = v_color;
}
&lt;/script&gt;
</code></pre><p>Нам нужно получить ссылку на атрибут для передачи цветов, установить буфер и
заполнить этот буфер данными цвета.</p>
<pre class="prettyprint"><code>  ...
  var colorLocation = gl.getAttribLocation(program, &quot;a_color&quot;);

  ...
  // Создаём буфер для цветов
  var colorBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  // Заполняем буфер цветами
  setColors(gl);


  ...
// Заполняем буфер цветами для буквы &#39;F&#39;

function setColors(gl) {
  gl.bufferData(
      gl.ARRAY_BUFFER,
      new Uint8Array([
          // вертикальный столб
        200,  70, 120,
        200,  70, 120,
        200,  70, 120,
        200,  70, 120,
        200,  70, 120,
        200,  70, 120,

          // верхняя перекладина
        200,  70, 120,
        200,  70, 120,
        ...
        ...
      gl.STATIC_DRAW);
}
</code></pre><p>Затем при рендеринге мы описываем, как атрибут цвета будет получать
данные из буфера цветов.</p>
<pre class="prettyprint"><code>// Включаем атрибут цвета
gl.enableVertexAttribArray(colorLocation);

// Привязываем буфер цветов
gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);

// Указываем атрибуту, как получать данные от colorBuffer (ARRAY_BUFFER)
var size = 3;                 // 3 компоненты на итерацию
var type = gl.UNSIGNED_BYTE;  // данные - 8-битные беззнаковые целые
var normalize = true;         // нормализовать данные (конвертировать из 0-255 в 0-1)
var stride = 0;               // 0 = перемещаться на size * sizeof(type) каждую итерацию для получения следующего положения
var offset = 0;               // начинать с начала буфера
gl.vertexAttribPointer(
    colorLocation, size, type, normalize, stride, offset)
</code></pre><p>Вот, что мы получим.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-step3.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-step3.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>О-хо-хо, ну и каша. Оказывается, что разные части 3D-буквы &#39;F&#39; -
передняя, задняя, боковые и т.д. - отрисовываются в порядке следования
данных геометрии. Это не даёт нам ожидаемый результат, так как иногда
части, которые должны быть сзади, отрисовываются впереди.</p>
<p><img class="webgl_center" style="background-color: transparent;" width="163" height="190" src="../resources/polygon-drawing-order.gif" /></p>
<p><span style="background: rgb(200, 70, 120); color: white; padding: 0.25em">Красным цветом</span>
отмечена <strong>передняя часть</strong> буквы &#39;F&#39;, но из-за того, что она отрисовывается
первой, другие треугольники перекрывают её, хотя и находятся дальше. Например,
<span style="background: rgb(80, 70, 200); color: white; padding: 0.25em">фиолетовые части</span>
на самом деле должны находиться позади. Фиолетовые части рисуются вторыми,
так как они идут вторыми в массиве данных.</p>
<p>Треугольники в WebGL могут располагаться лицевой или тыльной стороной.
По умолчанию у треугольника с лицевой стороной вершины идут в направлении
против часовой стрелке. У треугольника с тыльной стороной вершины идут в
направлении по часовой стрелке.</p>
<p><img src="../resources/triangle-winding.svg" class="webgl_center" width="400" /></p>
<p>В WebGL есть возможность отрисовывать только треугольники лицевой
стороны или только треугольники тыльной стороны. Мы можем включить
эту опцию через</p>
<pre class="prettyprint"><code>  gl.enable(gl.CULL_FACE);
</code></pre><p>Мы поместим этот код в функцию <code>drawScene</code>. С этой включённой опцией
WebGL &quot;отбраковывает&quot; треугольники с тыльной стороной. Под &quot;отбраковкой&quot;
здесь можно понимать &quot;не отрисовывать&quot;.</p>
<p>Следует заметить, что WebGL решает, повёрнут ли треугольник тыльной или
лицевой стороной, когда вершины находятся в пространстве отсечения. Другими
словами, направление по часовой или против часовой стрелке определяется
ПОСЛЕ применения всех трансформаций. Это означает, что треугольник, у которого
вершины расположены по часовой стрелке, после поворота по X на -1 становится
тыльным и вершины в нём расположены уже против часовой стрелки. Если
CULL_FACE отключен, мы видим и лицевые (вершины по часовой стрелке), и
тыльные (вершины против часовой стрелки) треугольники. А после включения
CULL_FACE, как только треугольники с лицевой стороной переворачиваются
из-за масштабирования, поворота или чего-то ещё, WebGL перестаёт их
отрисовывать. Хорошей практикой будет рассматривать те треугольники,
которые направлены к вам, как треугольники с лицевой стороной.</p>
<p>С включённым CULL_FACE мы получим следующую картину:</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-step4.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-step4.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Эй! Куда делись все треугольники? Оказывается, многие из них имеют
неправильную направленность вершин. Поверните их и вы увидите, как они
появляются с другой стороны. К счастью, это легко исправить. Нам нужно
найти треугольники с тыльной стороной и поменять им 2 вершины местами.
Например, если треугольник с тыльной стороной объявлен так:</p>
<pre class="prettyprint"><code>           1,   2,   3,
          40,  50,  60,
         700, 800, 900,
</code></pre><p>нам просто нужно переставить 2 вершины, чтобы сделать его сторону лицевой:</p>
<pre class="prettyprint"><code>           1,   2,   3,
         700, 800, 900,
          40,  50,  60,
</code></pre><p>Исправив все треугольники с тыльной стороной, мы получим</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-step5.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-step5.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Это ближе к 3D, но всё же остаётся одна проблема. Даже когда все треугольники
с лицевой стороной повёрнуты в правильном направлении, и когда все
треугольники с тыльной скрываются, у нас по-прежнему есть места, где
треугольники, которые должны быть на заднем плане, выходят на передний
план и перекрывают другие треугольники.</p>
<p>И вот где появляется БУФЕР ГЛУБИНЫ.</p>
<p>Буфер глубины, иногда называемый z-буфер, - это прямоугольник пикселей
<em>глубины</em>, и для создания изображения каждому пикселю цвета задаётся
пиксель глубины. WebGL может отрисовать пиксель глубины точно так же,
как он может отрисовать цветовой пиксель. Отрисовка выполняется на основе
значения Z в вершинном шейдере. Z также находится в пространстве отсечения
(от -1 до +1), и его нужно конвертировать так же, как X и Y. Затем это
значение преобразовывается в пространство глубины (от 0 до +1). Перед
отрисовкой пикселя WebGL проверяет соответствующий пиксель глубины. Если
значение глубины рисуемого пикселя больше, чем значение соответствующего
пикселя глубины, то WebGL не отрисовывает новый цветовой пиксель. В противном
случае WebGL отрисовывает <em>И</em> новый цветовой пиксель с цветом из фрагментного
шейдера, <em>И</em> пиксель глубины с новым значением глубины. Это означает, что
пиксели, которые находятся позади других пикселей, не будут отрисовываться.</p>
<p>Мы можем включить эту опцию почти так же просто, как мы включали CULL_FACE</p>
<pre class="prettyprint"><code>  gl.enable(gl.DEPTH_TEST);
</code></pre><p>А ещё нам нужно очистить буфер глубины обратно в 1.0 перед отрисовкой.</p>
<pre class="prettyprint"><code>  // Отрисовка сцены
  function drawScene() {
    ...

    // Очищаем canvas И буфер глубины
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    ...
</code></pre><p>И теперь мы получили</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-step6.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-step6.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Вот это настоящее 3D!</p>
<p>Одна небольшая деталь. В большинстве библиотек с 3D-математикой отсутствует
функция <code>projection</code>, которая преобразовывает пиксели в пространство отсечения.
Обычно есть функция <code>ortho</code> или <code>orthographic</code>, которая выглядит примерно так:</p>
<pre class="prettyprint"><code>var m4 = {
  orthographic: function(left, right, bottom, top, near, far) {
    return [
      2 / (right - left), 0, 0, 0,
      0, 2 / (top - bottom), 0, 0,
      0, 0, 2 / (near - far), 0,

      (left + right) / (left - right),
      (bottom + top) / (bottom - top),
      (near + far) / (near - far),
      1,
    ];
  }
</code></pre><p>В отличие от нашей упрощённой функции <code>projection</code>, в которой были лишь ширина, высота и
глубина, в более распространённой ортографической функции мы можем передать левую, правую,
нижнюю, верхнюю, а также переднюю и заднюю плоскость, что даёт нам большую гибкость. Чтобы
заменить нашу предыдущую функцию, напишем следующий код:</p>
<pre class="prettyprint"><code>var left = 0;
var right = gl.canvas.clientWidth;
var bottom = gl.canvas.clientHeight;
var top = 0;
var near = 400;
var far = -400;
m4.orthographic(left, right, bottom, top, near, far);
</code></pre><p>В следующей статье я расскажу о том, <a href="webgl-3d-perspective.html">как создать перспективу</a>.</p>
<div class="webgl_bottombar">
<h3>Почему атрибут vec4, а gl.vertexAttribPointer имеет размер 3</h3>
<p>
Внимательный к деталям читатель мог заметить, что мы определили 2 атрибута следующим образом:
</p>
<pre class="prettyprint showlinemods">
attribute vec4 a_position;
attribute vec4 a_color;
</pre>
<p>оба из которых 'vec4', но при передаче данных из буфера мы использовали</p>
<pre class="prettyprint showlinemods">
// Указываем атрибуту, как получать данные от positionBuffer (ARRAY_BUFFER)
var size = 3;          // 3 компоненты на итерацию
var type = gl.FLOAT;   // наши данные - 32-битные числа с плавающей точкой
var normalize = false; // не нормализовать данные
var stride = 0;        // 0 = перемещаться на size * sizeof(type) каждую
                       // итерацию для получения следующего положения
var offset = 0;        // начинать с начала буфера
gl.vertexAttribPointer(
    positionAttributeLocation, size, type, normalize, stride, offset);

...
// Указываем атрибуту, как получать данные от colorBuffer (ARRAY_BUFFER)
var size = 3;          // 3 компоненты на итерацию
var type = gl.UNSIGNED_BYTE;   // данные - 8-битные беззнаковые целые
var normalize = true;  // конвертировать из 0-255 в 0.0-1.0
var stride = 0;        // 0 = перемещаться на size * sizeof(type) каждую
                       // итерацию для получения следующего положения
var offset = 0;        // начинать с начала буфера
gl.vertexAttribPointer(
    colorAttributeLocation, size, type, normalize, stride, offset);
</pre>
<p>
Цифра '3' означает, что нужно выбрать 3 значения из буфера на атрибут за одну
итерацию в вершинном шейдере. Это работает, потому что в вершинном шейдере WebGL
заполняет пропущенные параметры значениями по умолчанию. Этими значениями по
умолчанию являются 0, 0, 0, 1, где x = 0, y = 0, z = 0 и w = 1. Вот почему в
нашем старом вершинном шейдере 2D нам приходилось явно указывать 1. Мы передавали
x и y, а ещё нужно было установить 1 для z, так как значением по умолчанию для z
является 0. Однако, в 3D, даже если мы не передадим 'w', его значение по умолчанию,
которое равняется 1, нас вполне устраивает для работы матриц.
</p>
</div>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-3d-orthographic.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-3d-orthographic.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-3d-orthographic.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-3d-orthographic.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-3d-orthographic.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-3d-orthographic.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-3d-orthographic.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-3d-orthographic.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Основы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-fundamentals.html">Основы WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-how-it-works.html">Как работает WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-shaders-and-glsl.html">Шейдеры и GLSL в WebGL</a></li>
        </ul>
  <li>Обработка изображений</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-image-processing.html">Обработка изображений в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-image-processing-continued.html">Продолжаем обработку изображений в WebGL</a></li>
        </ul>
  <li>Математика переноса, поворота и масштабирования в 2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-translation.html">2D-перенос в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-rotation.html">2D-поворот в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-scale.html">2D-масштабирование в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrices.html">2D-матрицы в WebGL</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-orthographic.html">WebGL 3D - Ортогональ</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective.html">WebGL 3D - Перспектива</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-camera.html">WebGL 3D - Камеры</a></li>
        </ul>
  <li>Освещение</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-lighting-directional.html">WebGL 3D - Направленное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-point.html">WebGL 3D - Точечное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-spot.html">WebGL 3D - Прожектор</a></li>
        </ul>
  <li>Структура и устройство</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-less-code-more-fun.html">WebGL - Меньше кода, больше веселья</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-multiple-things.html">WebGL - Отрисовка нескольких объектов</a></li>
<li><a href="/webgl/lessons/ru/webgl-scene-graph.html">WebGL - Графы сцены</a></li>
        </ul>
  <li>Геометрия</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-geometry-lathe.html">WebGL 3D - Создание модели</a></li>
        </ul>
  <li>Текстуры</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-textures.html">WebGL 3D - Текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-data-textures.html">WebGL - Данные для текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-2-textures.html">WebGL - Использование 2 и более текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-cors-permission.html">WebGL - Кросс-доменные изображения</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective-correct-texturemapping.html">WebGL 3D - Перспективная коррекция текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>Рендеринг в текстуру</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-render-to-texture.html">WebGL - Рендеринг в текстуру</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>Приёмы</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-drawimage.html">WebGL 2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrix-stack.html">WebGL 2D - Стек матриц</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/ru/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/ru/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/ru/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/ru/webgl-fog.html">Fog</a></li>
        </ul>
  <li>Текст</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-text-html.html">WebGL текст - HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-canvas2d.html">WebGL текст - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-texture.html">WebGL текст - Используем текстуру</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-glyphs.html">WebGL текст - Используем глиф-текстуру</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/ru/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Разное</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-setup-and-installation.html">WebGL Установка и настройка</a></li>
<li><a href="/webgl/lessons/ru/webgl-boilerplate.html">Шаблон WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ru/webgl-resizing-the-canvas.html">Изменение размера Canvas в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-animation.html">WebGL - Анимация</a></li>
<li><a href="/webgl/lessons/ru/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/ru/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/ru/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/ru/webgl-and-alpha.html">WebGL и прозрачность</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-vs-3d-library.html">WebGL - 2D и 3D библиотеки</a></li>
<li><a href="/webgl/lessons/ru/webgl-anti-patterns.html">WebGL - Антипаттерны</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/ru/webgl-texture-units.html">Texture Units</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Документация по вспомогательным функциям</a></li>
  <li><a href="http://twgljs.org">TWGL, лёгкая библиотека-помощник для WebGL</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>Вопросы? <a href="http://stackoverflow.com/questions/tagged/webgl">Спросите на stackoverflow</a>.</div>
        <div>Нашли ошибку? <a href="http://github.com/gfxfundamentals/webgl-fundamentals/issues">Создайте задачу на github</a>.</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL 3D - Ортогональ';
            var disqus_title = 'WebGL 3D - Ортогональ';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script src="//cdn.webglstats.com/stat.js" defer="defer" async="async"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');

</script>


</html>



