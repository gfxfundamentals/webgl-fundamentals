<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ru/webgl-text-texture.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Отображение текста в WebGL с помощью текстур">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-text-texture_ru.jpg">

<meta property="og:title" content="WebGL текст - текстуры">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-text-texture_ru.jpg">
<meta property="og:description" content="Отображение текста в WebGL с помощью текстур">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/ru/webgl-text-texture.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGL текст - текстуры">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/ru/webgl-text-texture.html">
<meta name="twitter:description" content="Отображение текста в WebGL с помощью текстур">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-text-texture_ru.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/ru/webgl-text-texture.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-text-texture_ru.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/ru/webgl-text-texture.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/ru/webgl-text-texture.html",
      "inLanguage":"ru",
      "name":"WebGL текст - текстуры",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/ru/webgl-text-texture.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL текст - текстуры</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-text-texture.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-text-texture.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-text-texture.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-text-texture.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-text-texture.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-text-texture.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-text-texture.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-text-texture.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-text-texture.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-text-texture.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-text-texture.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-text-texture.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-text-texture.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-text-texture.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-text-texture.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-text-texture.html" >简体中文</a>
</select>


    <a href="#toc">оглавление</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ru/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub a {
    background: #000;
    color: #fff;
    text-decoration: none;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 2rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 300px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(150px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a:hover {
    background: #c11;
    color: #fff;
}
#forkongithub a::before,#forkongithub a::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub a::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
@media (max-width: 900px) {
    #forkongithub a{
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub a{
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL текст - текстуры</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Эта статья продолжает серию статей о WebGL. Последняя была об
<a href="webgl-text-canvas2d.html">использовании canvas 2D для отрисовки текста над элементом canvas
в WebGL</a>. Если вы её ещё не читали, предлагаю
сначала ознакомиться с ней.</p>
<p>В последней статье мы узнали, <a href="webgl-text-canvas2d.html">как использовать 2D-canvas для отображения
текста над сценой WebGL</a>. Этот подход работает
и реализуется довольно легко, однако, у него есть ограничение - текст всегда
находится на переднем плане и не может перекрыться объектами сцены. Чтобы
добиться перекрытия, нам нужно отображать текст средствами WebGL.</p>
<p>Самый простой способ - создать текстуры с текстом внутри них. Например, можно
зайти в фотошоп или какой-нибудь другой графический редактор  и создать
изображение с текстом внутри него.</p>
<p><img class="webgl_center" src="../resources/my-awesme-text.png" /></p>
<p>Затем создадим плоскую геометрию и отобразим её. Именно так отображали
весь текст некоторые игры, с которыми я работал. Например, игра Locoroco
содержала около 270 строк и была локализована на 17 языков. У нас был лист
Excel со всеми языками, а также скрипт, который запускал фотошоп и генерировал
текстуру - одну для каждого сообщения на каждом языке.</p>
<p>Конечно же, можно создавать текстуры на лету. Мы снова можем использовать
преимущество браузерного окружения и задействовать Canvas 2D API для
генерации наших текстур.</p>
<p>Начнём с примера из <a href="webgl-text-canvas2d.html">предыдущей статьи</a>
и добавим в него функцию для заполнения canvas 2D текстом.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var textCtx = document.createElement(&quot;canvas&quot;).getContext(&quot;2d&quot;);

// помещаем текст в центр canvas
function makeTextCanvas(text, width, height) {
  textCtx.canvas.width  = width;
  textCtx.canvas.height = height;
  textCtx.font = &quot;20px monospace&quot;;
  textCtx.textAlign = &quot;center&quot;;
  textCtx.textBaseline = &quot;middle&quot;;
  textCtx.fillStyle = &quot;black&quot;;
  textCtx.clearRect(0, 0, textCtx.canvas.width, textCtx.canvas.height);
  textCtx.fillText(text, width / 2, height / 2);
  return textCtx.canvas;
}
</code></pre><p>Так как нам нужно отрисовать два разных объекта в WebGL (букву F и текст)
я буду использовать <a href="webgl-drawing-multiple-things.html">функцию-помощник из предыдущей
статьи</a>. Если вещи вроде <code class="notranslate" translate="no">programInfo</code>,
<code class="notranslate" translate="no">bufferInfo</code> и другие вам непонятны, то загляните в предыдущую статью.</p>
<p>Итак, создадим букву &#39;F&#39; и единичный квадрант.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// подготавливаем данные для буквы F
var fBufferInfo = primitives.create3DFBufferInfo(gl);
// создаём единичный квадрант для текста
var textBufferInfo = primitives.createPlaneBufferInfo(gl, 1, 1, 1, 1, m4.xRotation(Math.PI / 2));
</code></pre><p>Единичный квадрант - это квадрант (квадрат) единичного размера. Центр нашего
квадранта находится в начале системы координат. <code class="notranslate" translate="no">createPlaneBufferInfo</code>
создаёт плоскость в плоскости xz. Мы передаём матрицу для поворота и получаем
единичный квадрант в плоскости xy.</p>
<p>Далее создаём два шейдера</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// настройка программы GLSL
var fProgramInfo = createProgramInfo(gl, [&quot;vertex-shader-3d&quot;, &quot;fragment-shader-3d&quot;]);
var textProgramInfo = createProgramInfo(gl, [&quot;text-vertex-shader&quot;, &quot;text-fragment-shader&quot;]);
</code></pre><p>И создаём текстуру текста.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// создаём текстуру текста.
var textCanvas = makeTextCanvas(&quot;Hello!&quot;, 100, 26);
var textWidth  = textCanvas.width;
var textHeight = textCanvas.height;
var textTex = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, textTex);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textCanvas);
// отображаем текстуру, даже когда её размер не равен степени двойки
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
</code></pre><p>Устанавливаем uniform-переменные для текста и буквы &#39;F&#39;</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var fUniforms = {
  u_matrix: m4.identity(),
};

var textUniforms = {
  u_matrix: m4.identity(),
  u_texture: textTex,
};
</code></pre><p>Теперь при вычислении матриц для F мы сохраняем матрицу вида для буквы.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var fViewMatrix = m4.translate(viewMatrix,
    translation[0] + xx * spread, translation[1] + yy * spread, translation[2]);
fViewMatrix = m4.xRotate(fViewMatrix, rotation[0]);
fViewMatrix = m4.yRotate(fViewMatrix, rotation[1] + yy * xx * 0.2);
fViewMatrix = m4.zRotate(fViewMatrix, rotation[2] + now + (yy * 3 + xx) * 0.1);
fViewMatrix = m4.scale(fViewMatrix, scale[0], scale[1], scale[2]);
fViewMatrix = m4.translate(fViewMatrix, -50, -75, 0);
</code></pre><p>Отрисовка F выглядит следующим образом.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.useProgram(fProgramInfo.program);

webglUtils.setBuffersAndAttributes(gl, fProgramInfo, fBufferInfo);

fUniforms.u_matrix = m4.multiply(projectionMatrix, fViewMatrix);

webglUtils.setUniforms(fProgramInfo, fUniforms);

// отрисовка геометрии
gl.drawElements(gl.TRIANGLES, fBufferInfo.numElements, gl.UNSIGNED_SHORT, 0);
</code></pre><p>Для вывода текста нам нужно положение начальной точки F. Также нам нужно
масштабировать наш единичный квадрант, чтобы он соответствовал размерам
текстуры. Наконец, нам нужно умножить всё это на проекционную матрицу.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// для текста используем положение вида буквы &#39;F&#39;
var textMatrix = m4.translate(projectionMatrix,
    fViewMatrix[12], fViewMatrix[13], fViewMatrix[14]);
// масштабируем квадрант до нужного размера
textMatrix = m4.scale(textMatrix, textWidth, textHeight, 1);
</code></pre><p>И отображаем текст.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// предварительные настройки для отображения текста
gl.useProgram(textProgramInfo.program);

webglUtils.setBuffersAndAttributes(gl, textProgramInfo, textBufferInfo);

m4.copy(textMatrix, textUniforms.u_matrix);
webglUtils.setUniforms(textProgramInfo, textUniforms);

// отображаем текст
gl.drawElements(gl.TRIANGLES, textBufferInfo.numElements, gl.UNSIGNED_SHORT, 0);
</code></pre><p>И вот результат.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Вы можете заметить, что иногда части нашего текста закрывают части буквы F.
Это происходит из-за отрисовки квадранта. Цвет по умолчанию для canvas -
чёрный прозрачный (0,0,0,0), и этот цвет мы отображаем в квадранте. Для решения
проблемы будем использовать смешивание пикселей.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
</code></pre><p>Пиксель источника (цвет из фрагментного шейдера) соединится с пикселем в
приемника (цвет canvas) в соответствии с функцией смешивания. Мы установили
функции смешивания <code class="notranslate" translate="no">SRC_ALPHA</code> для источника и <code class="notranslate" translate="no">ONE_MINUS_SRC_ALPHA</code> для
приемника, значит</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">result = dest * (1 - src_alpha) + src * src_alpha
</code></pre><p>Например, если в приемнике зелёный цвет <code class="notranslate" translate="no">0,1,0,1</code>, а в источнике -
красный <code class="notranslate" translate="no">1,0,0,1</code>, то мы получим</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">src = [1, 0, 0, 1]
dst = [0, 1, 0, 1]
src_alpha = src[3]  // равно 1
result = dst * (1 - src_alpha) + src * src_alpha

// что можно упростить до
result = dst * 0 + src * 1

// и ещё раз упростить до
result = src
</code></pre><p>Для частей текстуры с прозрачным чёрным цветом <code class="notranslate" translate="no">0,0,0,0</code></p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">src = [0, 0, 0, 0]
dst = [0, 1, 0, 1]
src_alpha = src[3]  // равно 0
result = dst * (1 - src_alpha) + src * src_alpha

// что можно упростить до
result = dst * 1 + src * 0

// и ещё раз упростить до
result = dst
</code></pre><p>Вот результат использования смешивания.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture-enable-blend.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture-enable-blend.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Стало лучше, но по-прежнему есть недостатки. Если вы приглядитесь,
то иногда заметите такую проблему:</p>
<p><img class="webgl_center" src="../resources/text-zbuffer-issue.png" /></p>
<p>Что происходит? Мы отрисовываем букву F, затем её текст. Затем следующую
F и её текст и так далее. <a href="webgl-3d-orthographic.html">Буфер глубины</a>
включён, поэтому при отрисовке текста для F, даже не смотря на то, что в
режиме смешивания некоторые пиксели остаются с цветом фона, буфер всё
равно обновляется. А когда мы отображаем следующую F, если части F
находятся позади этих пикселей от предыдущего текста, то эти части не
будут отображены.</p>
<p>Мы только что столкнулись с одной из самых сложных проблем в рендеринге
3D на видеокарте. <strong>Прозрачность несёт в себе множество опасностей</strong>.</p>
<p>Наиболее распространённый подход для отображения прозрачных объектов -
отрисовывать сначала все непрозрачные объекты, затем все прозрачные,
которые упорядочены по расстоянию по z с включённым тестированием буфера
глубины и отключённым обновлением буфера.</p>
<p>Давайте для начала отделим отрисовку непрозрачных объектов (буквы F) от
прозрачных (текст). Для начала заведём переменную, где будем хранить
положения для текста.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var textPositions = [];
</code></pre><p>И при цикле отрисовки букв F мы будем запоминать эти положения.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var fViewMatrix = m4.translate(viewMatrix,
    translation[0] + xx * spread, translation[1] + yy * spread, translation[2]);
fViewMatrix = m4.xRotate(fViewMatrix, rotation[0]);
fViewMatrix = m4.yRotate(fViewMatrix, rotation[1] + yy * xx * 0.2);
fViewMatrix = m4.zRotate(fViewMatrix, rotation[2] + now + (yy * 3 + xx) * 0.1);
fViewMatrix = m4.scale(fViewMatrix, scale[0], scale[1], scale[2]);
fViewMatrix = m4.translate(fViewMatrix, -50, -75, 0);
+// запоминаем положение вида буквы F
+textPositions.push([fViewMatrix[12], fViewMatrix[13], fViewMatrix[14]]);
</code></pre><p>Перед отрисовкой букв F мы отключим смешивание и включим запись в буфер глубины.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.disable(gl.BLEND);
gl.depthMask(true);
</code></pre><p>Для текста мы включим смешивание и отключим запись в буфер глубины.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
gl.depthMask(false);
</code></pre><p>И далее отрисуем текст во всех сохранённых положениях.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">+// предварительные настройки для отображения текста
+gl.useProgram(textProgramInfo.program);
+
+webglUtils.setBuffersAndAttributes(gl, textProgramInfo, textBufferInfo);

+textPositions.forEach(function(pos) {
  // отображаем текст

  // для текста используем положение вида буквы &#39;F&#39;
*  var textMatrix = m4.translate(projectionMatrix, pos[0], pos[1], pos[2]);
  // масштабируем квадрант до нужного размера
  textMatrix = m4.scale(textMatrix, textWidth, textHeight, 1);

  m4.copy(textMatrix, textUniforms.u_matrix);
  webglUtils.setUniforms(textProgramInfo, textUniforms);

  // отображаем текст
  gl.drawElements(gl.TRIANGLES, textBufferInfo.numElements, gl.UNSIGNED_SHORT, 0);
+});
</code></pre><p>Обратите внимание, что мы вынесли установку текущей программы и атрибутов
за пределы цикла, так как мы отрисовываем один и тот же объект несколько
раз и нет смысла устанавливать их каждую итерацию.</p>
<p>И теперь оно почти работает.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture-separate-opaque-from-transparent.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture-separate-opaque-from-transparent.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Как видите, мы не упорядочивали объекты, о чём я говорил выше. Мы отображаем
непрозрачный текст, поэтому сортировка не даст заметной разницы, а значит
я приберегу сортировку для какой-нибудь другой статьи.</p>
<p>Ещё одна проблема заключается в том, что текст пересекается со своей буквой &#39;F&#39;.
Какого-то универсального решения для этой ситуации нет. Если вам доведётся
делать игру в жанре ММО, и понадобится надпись для каждого игрока, то, возможно,
вы решите разместить надпись над головой персонажа. Просто прибавьте к значению
Y некоторое число, чтобы надпись была всегда выше игрока.</p>
<p>Или же можно сдвинуть надпись ближе к камере. Так и сделаем, просто ради
эксперимента. &#39;pos&#39; находится в пространстве вида, то есть он расположен
относительно наблюдателя (который находится в координатах 0,0,0). Поэтому
при его нормализации мы получим единичный вектор, направленный от наблюдателя
к координате, и при умножении этого вектора на определённое число надпись
сдвинется на несколько единиц по направлению к наблюдателю (или от него).</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">+// pos находится в пространстве вида - то есть является вектором от наблюдателя
+// к координате. Поэтому сместимся вдоль этого вектора ближе к наблюдателю.
+var fromEye = m4.normalize(pos);
+var amountToMoveTowardEye = 150;  // длина буквы F составляет 150 единиц
+var viewX = pos[0] - fromEye[0] * amountToMoveTowardEye;
+var viewY = pos[1] - fromEye[1] * amountToMoveTowardEye;
+var viewZ = pos[2] - fromEye[2] * amountToMoveTowardEye;
+var textMatrix = m4.translate(projectionMatrix, viewX, viewY, viewZ);

*var textMatrix = m4.translate(projectionMatrix, viewX, viewY, viewZ);
// масштабируем квадрант до нужного размера
textMatrix = m4.scale(textMatrix, textWidth, textHeight, 1);
</code></pre><p>И вот, что мы получим</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture-moved-toward-view.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture-moved-toward-view.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Осталась ещё одна нерешённая проблема, которую можно увидеть на границах букв.</p>
<p><img class="webgl_center" src="../resources/text-gray-outline.png" /></p>
<p>Всё дело в том, что Canvas 2D API даёт на выходе только предумноженную
прозрачность. При загрузке содержимого canvas в текстуру WebGL пытается
получить не предумноженную прозрачность, но у него не получается сделать
это идеально, так как предумножение прозрачности идёт с потерями.</p>
<p>Чтобы поправить ситуацию, скажем WebGL, чтобы он не получал предумноженную прозрачность.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
</code></pre><p>Эта строчка говорит WebGL, что нужно передать предумноженную прозрачность в
<code class="notranslate" translate="no">gl.texImage2D</code> и <code class="notranslate" translate="no">gl.texSubImage2D</code>. Если данные для <code class="notranslate" translate="no">gl.texImage2D</code> уже
предумноженные, как в случае с Canvas 2D, то WebGL сможет просто передать
их далее.</p>
<p>Кроме того, нам нужно изменить функцию смешивания.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">-gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
+gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
</code></pre><p>Старая функция умножала цвет источника на его прозрачность. За это отвечает
<code class="notranslate" translate="no">SRC_ALPHA</code>. Но сейчас данные для текстуры уже предумноженные на прозрачность.
Это и есть смысл предумножения. Поэтому нам не нужно заставлять видеокарту
выполнять умножение. Значение параметра <code class="notranslate" translate="no">ONE</code> означает умножение на 1.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture-premultiplied-alpha.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture-premultiplied-alpha.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Теперь на краях букв пропала размытость.</p>
<p>А что, если нам нужно, чтобы текст оставался фиксированного размера, но
по-прежнему находился на переднем плане? Как вы помните из <a href="webgl-3d-perspective.html">статьи о
перспективе</a>, наша матрица перспективы
масштабирует объекты на значение <code class="notranslate" translate="no">1 / -Z</code>, чтобы они были меньше на расстоянии.
Поэтому нам нужно лишь компенсировать этот коэффициент, масштабируя на <code class="notranslate" translate="no">-Z</code>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">...
// pos находится в пространстве вида - то есть является вектором от наблюдателя
// к координате. Поэтому сместимся вдоль этого вектора ближе к наблюдателю.
var fromEye = normalize(pos);
var amountToMoveTowardEye = 150;  // длина буквы F составляет 150 единиц
var viewX = pos[0] - fromEye[0] * amountToMoveTowardEye;
var viewY = pos[1] - fromEye[1] * amountToMoveTowardEye;
var viewZ = pos[2] - fromEye[2] * amountToMoveTowardEye;
+var desiredTextScale = -1 / gl.canvas.height;  // 1x1 пикселей
+var scale = viewZ * desiredTextScale;

var textMatrix = m4.translate(projectionMatrix, viewX, viewY, viewZ);
// масштабируем квадрант до нужного размера
*textMatrix = m4.scale(textMatrix, textWidth * scale, textHeight * scale, 1);
...
</code></pre><p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture-consistent-scale.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture-consistent-scale.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Мы можем установить разные надписи для каждой буквы F, нужно лишь задать новую
текстуру для каждой F, а затем просто обновлять uniform-переменную для этой F.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// создаём текстуры с текстом, по одной на каждую F
var textTextures = [
  &quot;anna&quot;,   // 0
  &quot;colin&quot;,  // 1
  &quot;james&quot;,  // 2
  &quot;danny&quot;,  // 3
  &quot;kalin&quot;,  // 4
  &quot;hiro&quot;,   // 5
  &quot;eddie&quot;,  // 6
  &quot;shu&quot;,    // 7
  &quot;brian&quot;,  // 8
  &quot;tami&quot;,   // 9
  &quot;rick&quot;,   // 10
  &quot;gene&quot;,   // 11
  &quot;natalie&quot;,// 12,
  &quot;evan&quot;,   // 13,
  &quot;sakura&quot;, // 14,
  &quot;kai&quot;,    // 15,
].map(function(name) {
  var textCanvas = makeTextCanvas(name, 100, 26);
  var textWidth  = textCanvas.width;
  var textHeight = textCanvas.height;
  var textTex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, textTex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textCanvas);
  // make sure we can render it even if it&#39;s not a power of 2
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  return {
    texture: textTex,
    width: textWidth,
    height: textHeight,
  };
});
</code></pre><p>Затем при отрисовке выбираем текстуру</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">*textPositions.forEach(function(pos, ndx) {

  +// выбираем текстуру
  +var tex = textTextures[ndx];

  var textMatrix = m4.translate(projectionMatrix, viewX, viewY, viewZ);
  // масштабируем квадрант до нужного размера
  *textMatrix = m4.scale(textMatrix, tex.width * scale, tex.height * scale, 1);
</code></pre><p>и обновляем значение uniform-переменной перед отрисовкой.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  *textUniforms.u_texture = tex.texture;
</code></pre><p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture-different-text.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture-different-text.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Мы использовали чёрный цвет для текста. Было бы полезно использовать белый
цвет для текста. Тогда мы могли бы умножить текст на цвет и получить в итоге
цветной текст.</p>
<p>Для начала внесём изменения в шейдер текста для умножения на цвет.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">varying vec2 v_texcoord;

uniform sampler2D u_texture;
+uniform vec4 u_color;

void main() {
*   gl_FragColor = texture2D(u_texture, v_texcoord) * u_color;
}
</code></pre><p>Далее при отрисовке текста в canvas будем использовать белый цвет.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">textCtx.fillStyle = &quot;white&quot;;
</code></pre><p>Теперь создадим цвета надписей.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// цвета, по 1 на каждую F
var colors = [
  [0.0, 0.0, 0.0, 1], // 0
  [1.0, 0.0, 0.0, 1], // 1
  [0.0, 1.0, 0.0, 1], // 2
  [1.0, 1.0, 0.0, 1], // 3
  [0.0, 0.0, 1.0, 1], // 4
  [1.0, 0.0, 1.0, 1], // 5
  [0.0, 1.0, 1.0, 1], // 6
  [0.5, 0.5, 0.5, 1], // 7
  [0.5, 0.0, 0.0, 1], // 8
  [0.0, 0.0, 0.0, 1], // 9
  [0.5, 5.0, 0.0, 1], // 10
  [0.0, 5.0, 0.0, 1], // 11
  [0.5, 0.0, 5.0, 1], // 12,
  [0.0, 0.0, 5.0, 1], // 13,
  [0.5, 5.0, 5.0, 1], // 14,
  [0.0, 5.0, 5.0, 1], // 15,
];
</code></pre><p>При отрисовке устанавливаем цвет</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// задаём значение для uniform-переменной цвета
textUniforms.u_color = colors[ndx];
</code></pre><p>И получаем цветные надписи.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture-different-colors.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture-different-colors.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Такую технику использует большая часть браузеров, когда они используют
аппаратное ускорение. Браузер создаёт текстуру из контента вашего HTML и
всевозможных стилей, которые вы назначили, и до тех пор, пока контент не
меняется, браузер отображает текстуру снова при скроле и прочем. Конечно
же, если вы обновляете контент часто, то такая техника может работать
немного медленно, так как нужно пересоздавать текстуры и передавать новые
текстуры в видеокарту, что является относительно медленными операциями.</p>
<p>В <a href="webgl-text-glyphs.html">следующей статье мы познакомимся с техникой, которая больше подходит для
случаев, когда объекты часто меняются</a>.</p>
<div class="webgl_bottombar">
<h3>Масштабирование текста без пикселизации</h3>
<p>
Вы могли заметить, что в примерах до использования постоянного размера текста
буквы подвергались пикселизации при приближении к камере. Как этого избежать?
</p>
<p>
Честно говоря, масштабирование 2D-текста в 3D - не частая задача. Взять те же
игры или редакторы 3D - текст почти всегда одного размера, независимо от
того, как далеко от камеры он расположен. Часто текст может быть отрисован в 2D
вместо 3D, поэтому даже когда кто-то или что-то находится за препядствием -
например, персонаж за стеной - вы по-прежнему будете видеть текст.
</p>
<p>Если вам всё же придётся масштабировать 2D-текст в 3D, я не знаю каких-либо
простых вариантов. Вот несколько навскидку:</p>
<ul>
<li>Сделайте различные размеры текстур со шрифтами для разных разрешений. Затем
используйте текстуры с более высоким разрешением при увеличении текста. Это
приём называется LOD (различные уровни детализации).</li>
<li>Также можно отображать текстуры с точно соответствующим размером шрифта
на каждый кадр. Скорей всего это будет очень медленно.</li>
<li>Можно создать 2D-текст с помощью геометрии. Другими словами, вместо
отрисовки текста в текстуру можно создать текст из множества треугольников.
Это будет работать, однако маленький текст отобразится очень плохо, а у большого
текста будут заметны треугольники.</li>
<li>Ещё можно <a href="https://www.google.com/search?q=loop+blinn+curve+rendering">использовать специальные шейдеры для отображения кривых</a>.
Это очень круто, но находится далеко за гранью того, что я здесь объясняю.
</li>
</ul>
</div>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-text-texture.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-text-texture.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-text-texture.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-text-texture.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-text-texture.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-text-texture.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-text-texture.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-text-texture.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Основы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-fundamentals.html">Основы WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-how-it-works.html">Как работает WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-shaders-and-glsl.html">Шейдеры и GLSL в WebGL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL State Diagram</a></li>
        </ul>
  <li>Обработка изображений</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-image-processing.html">Обработка изображений в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-image-processing-continued.html">Продолжаем обработку изображений в WebGL</a></li>
        </ul>
  <li>Математика переноса, поворота и масштабирования в 2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-translation.html">2D-перенос в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-rotation.html">2D-поворот в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-scale.html">2D-масштабирование в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrices.html">2D-матрицы в WebGL</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-orthographic.html">WebGL 3D - Ортогональ</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective.html">WebGL 3D - Перспектива</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-camera.html">WebGL 3D - Камеры</a></li>
        </ul>
  <li>Освещение</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-lighting-directional.html">WebGL 3D - Направленное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-point.html">WebGL 3D - Точечное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-spot.html">WebGL 3D - Прожектор</a></li>
        </ul>
  <li>Структура и устройство</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-less-code-more-fun.html">WebGL - Меньше кода, больше веселья</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-multiple-things.html">WebGL - Отрисовка нескольких объектов</a></li>
<li><a href="/webgl/lessons/ru/webgl-scene-graph.html">WebGL - Графы сцены</a></li>
        </ul>
  <li>Геометрия</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-geometry-lathe.html">WebGL 3D - Создание модели</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj.html">Loading .obj files</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>Текстуры</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-textures.html">WebGL 3D - Текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-data-textures.html">WebGL - Данные для текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-2-textures.html">WebGL - Использование 2 и более текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-cors-permission.html">WebGL - Кросс-доменные изображения</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective-correct-texturemapping.html">WebGL 3D - Перспективная коррекция текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>Рендеринг в текстуру</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-render-to-texture.html">WebGL - Рендеринг в текстуру</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>Приёмы</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-drawimage.html">WebGL 2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrix-stack.html">WebGL 2D - Стек матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-sprites.html">Sprites</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/ru/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/ru/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/ru/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/ru/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ru/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Текст</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-text-html.html">WebGL текст - HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-canvas2d.html">WebGL текст - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-texture.html">WebGL текст - Используем текстуру</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-glyphs.html">WebGL текст - Используем глиф-текстуру</a></li>
        </ul>
  <li>Текстуры</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-ramp-textures.html">Ramp Textures (Toon Shading)</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/ru/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ru/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ru/webgl-instanced-drawing.html">Instanced Drawing</a></li>
        </ul>
  <li>Разное</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-setup-and-installation.html">WebGL Установка и настройка</a></li>
<li><a href="/webgl/lessons/ru/webgl-boilerplate.html">Шаблон WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-resizing-the-canvas.html">Изменение размера Canvas в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-animation.html">WebGL - Анимация</a></li>
<li><a href="/webgl/lessons/ru/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/ru/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/ru/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/ru/webgl-and-alpha.html">WebGL и прозрачность</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-vs-3d-library.html">WebGL - 2D и 3D библиотеки</a></li>
<li><a href="/webgl/lessons/ru/webgl-anti-patterns.html">WebGL - Антипаттерны</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/ru/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#html-background">Use WebGL as Background in HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/ru/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/ru/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/ru/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ru/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Документация по вспомогательным функциям</a></li>
  <li><a href="https://twgljs.org">TWGL, лёгкая библиотека-помощник для WebGL</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>Вопросы? <a href="https://stackoverflow.com/questions/tagged/webgl">Спросите на stackoverflow</a>.</div>
        <div>Нашли ошибку? <a href="https://github.com/gfxfundamentals/webgl-fundamentals/issues">Создайте задачу на github</a>.</div>

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL текст - текстуры';
            var disqus_title = 'WebGL текст - текстуры';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
      return;
  }

  function addScript(src, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  addScript('//cdn.webglstats.com/stat.js');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>



