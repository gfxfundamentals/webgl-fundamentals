<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ru/webgl-ramp-textures.md. Do not edited directly -->
<!--
Copyright 2021 GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Using ramp textures">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-ramp-textures_ru.jpg">

<meta property="og:title" content="WebGL Ramp Textures">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-ramp-textures_ru.jpg">
<meta property="og:description" content="Using ramp textures">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/ru/webgl-ramp-textures.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGL Ramp Textures">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/ru/webgl-ramp-textures.html">
<meta name="twitter:description" content="Using ramp textures">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-ramp-textures_ru.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/ru/webgl-ramp-textures.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-ramp-textures_ru.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/ru/webgl-ramp-textures.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/ru/webgl-ramp-textures.html",
      "inLanguage":"ru",
      "name":"WebGL Ramp Textures",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/ru/webgl-ramp-textures.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL Ramp Textures</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-ramp-textures.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-ramp-textures.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-ramp-textures.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-ramp-textures.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-ramp-textures.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-ramp-textures.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-ramp-textures.html">
  <link rel="alternate" hreflang="uk" href="https://webglfundamentals.org/webgl/lessons/uk/webgl-ramp-textures.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-ramp-textures.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-ramp-textures.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-ramp-textures.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-ramp-textures.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-ramp-textures.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-ramp-textures.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-ramp-textures.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-ramp-textures.html" selected>Русский</a>
    <option value="/webgl/lessons/uk/webgl-ramp-textures.html" >Українська</a>
    <option value="/webgl/lessons/zh_cn/webgl-ramp-textures.html" >简体中文</a>
</select>


    <a href="#toc">оглавление</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ru/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL Ramp Textures</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Важным моментом в WebGL является то, что текстуры — это не просто элементы, 
применяемые непосредственно к треугольникам, как мы рассмотрели в <a href="webgl-3d-textures.html"> статье о текстурах. </a>.
Текстуры — это массивы данных произвольного доступа, обычно двумерные массивы данных. 
Таким образом, любое решение, в котором мы могли бы использовать массив данных с произвольным доступом,
— это место, где мы, вероятно, можем использовать текстуру.</p>
<p>В <a href="webgl-3d-lighting-directional.html">статье о направленном освещени</a>
мы рассказали, как использовать <em>скалярное произведение</em>для вычисления угла между двумя векторами. 
В нем мы вычислили <em>скалярное произведение</em> направления света на нормаль к поверхности нашей модели. 
Так мы определили косинус угла между двумя векторами. Косинус — это значение от -1 до +1, 
и мы использовали его как непосредственный множитель нашего цвета.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">float light = dot(normal, u_reverseLightDirection);

gl_FragColor = u_color;
gl_FragColor.rgb *= light;
</code></pre>
<p>Это затемнит свет.</p>
<p>Что, если вместо непосредственного использования этого скалярного произведения мы воспользуемся им для поиска значения в одномерной текстуре?</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">precision mediump float;

// Passed in from the vertex shader.
varying vec3 v_normal;

uniform vec3 u_reverseLightDirection;
uniform vec4 u_color;
+uniform sampler2D u_ramp;

void main() {
  // because v_normal is a varying it&#39;s interpolated
  // so it will not be a unit vector. Normalizing it
  // will make it a unit vector again
  vec3 normal = normalize(v_normal);

-  float light = dot(normal, u_reverseLightDirection);
+  float cosAngle = dot(normal, u_reverseLightDirection);
+
+  // convert from -1 &lt;-&gt; 1 to 0 &lt;-&gt; 1
+  float u = cosAngle * 0.5 + 0.5;
+
+  // make a texture coordinate
+  vec2 uv = vec2(u, 0.5);
+
+  // lookup a value from a 1d texture
+  vec4 rampColor = texture2D(u_ramp, uv);
+
  gl_FragColor = u_color;
-  gl_FragColor.rgb *= light;
+  gl_FragColor *= rampColor;
}
</code></pre>
<p>Нам нужно создать текстуру. Начнем с текстуры 2х1. Мы будем использовать формат <code class="notranslate" translate="no">LUMINANCE</code>,
который дает нам монохромную текстуру, используя только 1 байт на тексель.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">var tex = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, tex);
gl.texImage2D(
    gl.TEXTURE_2D,     // target
    0,                 // mip level
    gl.LUMINANCE,      // internal format
    2,                 // width
    1,                 // height
    0,                 // border
    gl.LUMINANCE,      // format
    gl.UNSIGNED_BYTE,  // type
    new Uint8Array([90, 255]));
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
</code></pre>
<p>Цвета двух пикселей выше — темно-серый (90) и белый (255).
Мы также устанавливаем параметры текстуры, чтобы не было фильтрации.</p>
<p>Модифицируя образец новой текстуры, нам нужно найти форму <code class="notranslate" translate="no">u_ramp</code>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">var worldViewProjectionLocation = gl.getUniformLocation(program, &quot;u_worldViewProjection&quot;);
var worldInverseTransposeLocation = gl.getUniformLocation(program, &quot;u_worldInverseTranspose&quot;);
var colorLocation = gl.getUniformLocation(program, &quot;u_color&quot;);
+var rampLocation = gl.getUniformLocation(program, &quot;u_ramp&quot;);
var reverseLightDirectionLocation =
    gl.getUniformLocation(program, &quot;u_reverseLightDirection&quot;);
</code></pre>
<p>и нам нужно настроить текстуру при рендеринге</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// bind the texture to active texture unit 0
gl.activeTexture(gl.TEXTURE0 + 0);
gl.bindTexture(gl.TEXTURE_2D, tex);
// tell the shader that u_ramp should use the texture on texture unit 0
gl.uniform1i(rampLocation, 0);
</code></pre>
<p>Я заменил данные для 3D <code class="notranslate" translate="no">F</code> из образца света на данные для &quot;низкополигональной&quot; головы. 
Запустив его, мы получим это</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-ramp-texture.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-ramp-texture.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Если вы повернете модель, вы увидите, что она похожа на  <a href="https://en.wikipedia.org/wiki/Cel_shading">toon shading</a></p>
<p>В приведенном выше примере мы установили фильтрацию текстур на <code class="notranslate" translate="no">NEAREST</code>, что означает, 
что мы просто выбираем ближайший тексел из текстуры для нашего цвета. 
Есть только 2 текселя, поэтому, если поверхность обращена от света, мы получаем первый цвет (темно-серый), 
а если поверхность обращена к свету, мы получаем второй цвет (белый). 
Этот цвет умножается на <code class="notranslate" translate="no">gl_FragColor</code>, точно так же, как раньше был <code class="notranslate" translate="no">light</code>.</p>
<p>Thinking about it if we switch to <code class="notranslate" translate="no">LINEAR</code> filtering we <em>should</em> get the same
result as before using the texture. Let&#39;s try it.</p>
<p>Если подумать, если мы переключимся на <code class="notranslate" translate="no">LINEAR</code> фильтрацию, 
<em>мы должны</em> получить тот же результат, что и перед использованием текстуры. Давай попробуем.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
-gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
+gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
+gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-ramp-texture-linear.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-ramp-texture-linear.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Это выглядит похоже, но если мы действительно сравним их друг с другом...</p>
<div class="webgl_center"><img src="../resources/ramp-vs-light.png" style="width: 598px;"></div>

<p>Мы видим, что они не одинаковы. Но почему?</p>
<p><code class="notranslate" translate="no">LINEAR</code> фильтрация смешивает пиксели. 
Если мы увеличим текстуру размером 2 пикселя с линейной фильтрацией, мы увидим проблему.</p>
<div class="webgl_center"><img src="../resources/linear-texture-interpolation.svg" style="width: 500px;"></div>
<div class="webgl_center">Диапазон координат текстуры для ramp</div>

<p>С каждой стороны по полпикселя без интерполяции. Представьте, если для текстуры было установлено
<code class="notranslate" translate="no">TEXTURE_WRAP_S</code> в <code class="notranslate" translate="no">REPEAT</code>. Тогда мы ожидаем, что самая левая половина красного пикселя будет линейно сливаться с зеленым,
как если бы зеленый цвет повторялся влево. Но то, что слева, более красное, поскольку мы используем <code class="notranslate" translate="no">CLAMP_TO_EDGE</code>.</p>
<p>Чтобы действительно получить линейное изменение, нам просто нужно выбрать значения из этого центрального диапазона.
Мы можем сделать это с помощью небольших математических вычислений в нашем шейдере.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">precision mediump float;

// Passed in from the vertex shader.
varying vec3 v_normal;

uniform vec3 u_reverseLightDirection;
uniform vec4 u_color;
uniform sampler2D u_ramp;
+uniform vec2 u_rampSize;

void main() {
  // because v_normal is a varying it&#39;s interpolated
  // so it will not be a unit vector. Normalizing it
  // will make it a unit vector again
  vec3 normal = normalize(v_normal);

  float cosAngle = dot(normal, u_reverseLightDirection);

  // convert from -1 &lt;-&gt; 1 to 0 &lt;-&gt; 1
  float u = cosAngle * 0.5 + 0.5;

  // make a texture coordinate.
  vec2 uv = vec2(u, 0.5);

+  // scale to size of ramp
+  vec2 texelRange = uv * (u_rampSize - 1.0);
+
+  // offset by half a texel and convert to texture coordinate
+  vec2 rampUV = (texelRange + 0.5) / u_rampSize;

-  vec4 rampColor = texture2D(u_ramp, uv);
+  vec4 rampColor = texture2D(u_ramp, rampUV);

  gl_FragColor = u_color;
  gl_FragColor *= rampColor;
}
</code></pre>
<p>Выше мы в основном масштабируем нашу UV-координату, чтобы она изменялась от 0 до 1 на 1 меньше ширины текстуры.
Затем добавляем половину пикселя и конвертируем обратно в нормализованные координаты текстуры.</p>
<p>Нам нужно найти местоположение <code class="notranslate" translate="no">u_rampSize</code></p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">var colorLocation = gl.getUniformLocation(program, &quot;u_color&quot;);
var rampLocation = gl.getUniformLocation(program, &quot;u_ramp&quot;);
+var rampSizeLocation = gl.getUniformLocation(program, &quot;u_rampSize&quot;);
</code></pre>
<p>И нам нужно установить его во время рендеринга</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// bind the texture to active texture unit 0
gl.activeTexture(gl.TEXTURE0 + 0);
gl.bindTexture(gl.TEXTURE_2D, tex);
// tell the shader that u_ramp should use the texture on texture unit 0
gl.uniform1i(rampLocation, 0);
+gl.uniform2fv(rampSizeLocation, [2, 1]);
</code></pre>
<p>Прежде чем запустить его, давайте добавим флаг, чтобы мы могли сравнивать с <em>ramp texture</em> и без нее.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">precision mediump float;

// Passed in from the vertex shader.
varying vec3 v_normal;

uniform vec3 u_reverseLightDirection;
uniform vec4 u_color;
uniform sampler2D u_ramp;
uniform vec2 u_rampSize;
+uniform bool u_useRampTexture;

void main() {
  // because v_normal is a varying it&#39;s interpolated
  // so it will not be a unit vector. Normalizing it
  // will make it a unit vector again
  vec3 normal = normalize(v_normal);

  float cosAngle = dot(normal, u_reverseLightDirection);

  // convert from -1 &lt;-&gt; 1 to 0 &lt;-&gt; 1
  float u = cosAngle * 0.5 + 0.5;

  // make a texture coordinate.
  vec2 uv = vec2(u, 0.5);

  // scale to size of ramp
  vec2 texelRange = uv * (u_rampSize - 1.0);

  // offset by half a texel and convert to texture coordinate
  vec2 rampUV = (texelRange + 0.5) / u_rampSize;

  vec4 rampColor = texture2D(u_ramp, rampUV);

+  if (!u_useRampTexture) {
+    rampColor = vec4(u, u, u, 1);
+  }

  gl_FragColor = u_color;
  gl_FragColor *= rampColor;
}
</code></pre>
<p>Мы также найдем местонахождение этой формы.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">var rampLocation = gl.getUniformLocation(program, &quot;u_ramp&quot;);
var rampSizeLocation = gl.getUniformLocation(program, &quot;u_rampSize&quot;);
+var useRampTextureLocation = gl.getUniformLocation(program, &quot;u_useRampTexture&quot;);
</code></pre>
<p>и установим её</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">var data = {
  useRampTexture: true,
};

...

// bind the texture to active texture unit 0
gl.activeTexture(gl.TEXTURE0 + 0);
gl.bindTexture(gl.TEXTURE_2D, tex);
// tell the shader that u_ramp should use the texture on texture unit 0
gl.uniform1i(rampLocation, 0);
gl.uniform2fv(rampSizeLocation, [2, 1]);

+gl.uniform1i(useRampTextureLocation, data.useRampTexture);
</code></pre>
<p>Таким образом, мы видим, что старый способ освещения и новый способ texture rump совпадают.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-ramp-texture-issue-confirm.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-ramp-texture-issue-confirm.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Установив флажок «useRampTexture», мы не видим никаких изменений, поскольку теперь эти два метода совпадают.</p>
<blockquote>
<p>Примечание. Обычно я не рекомендую использовать в шейдере условие типа <code class="notranslate" translate="no">u_useRampTexture</code>
Вместо этого я рекомендую создать две шейдерные программы: одну, использующую нормальное освещение, 
и другую, использующую ramp texture. К сожалению, поскольку код не использует
что-то вроде <a href="webgl-less-code-more-fun.html">нашей вспомогательной библиотеки</a>,
для поддержки двух шейдерных программ потребовалось бы существенное изменение. 
Для каждой программы нужен свой набор локаций. Внесение столь значительных изменений отвлекло 
бы от сути этой статьи, поэтому в данном случае я решил использовать условность. 
В целом я стараюсь избегать условий при выборе функций в шейдерах и вместо этого создаю разные шейдеры для разных функций.</p>
</blockquote>
<p>Примечание. Эта математика важна только в том случае, если мы используем <code class="notranslate" translate="no">LINEAR</code> фильтрацию. 
Если мы используем фильтрацию <code class="notranslate" translate="no">NEAREST</code>, нам нужна исходная математика.</p>
<p>Теперь, когда мы знаем, что математические расчеты рампы верны, давайте создадим несколько различных ramp textures.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">+// make a 256 array where elements 0 to 127
+// go from 64 to 191 and elements 128 to 255
+// are all 255.
+const smoothSolid = new Array(256).fill(255);
+for (let i = 0; i &lt; 128; ++i) {
+  smoothSolid[i] = 64 + i;
+}
+
+const ramps = [
+  { name: &#39;dark-white&#39;,          color: [0.2, 1, 0.2, 1], format: gl.LUMINANCE, filter: false,
+    data: [80, 255] },
+  { name: &#39;dark-white-skewed&#39;,   color: [0.2, 1, 0.2, 1], format: gl.LUMINANCE, filter: false,
+    data: [80, 80, 80, 255, 255] },
+  { name: &#39;normal&#39;,              color: [0.2, 1, 0.2, 1], format: gl.LUMINANCE, filter: true,
+    data: [0, 255] },
+  { name: &#39;3-step&#39;,              color: [0.2, 1, 0.2, 1], format: gl.LUMINANCE, filter: false,
+    data: [80, 160, 255] },
+  { name: &#39;4-step&#39;,              color: [0.2, 1, 0.2, 1], format: gl.LUMINANCE, filter: false,
+    data: [80, 140, 200, 255] },
+  { name: &#39;4-step skewed&#39;,       color: [0.2, 1, 0.2, 1], format: gl.LUMINANCE, filter: false,
+    data: [80, 80, 80, 80, 140, 200, 255] },
+  { name: &#39;black-white-black&#39;,   color: [0.2, 1, 0.2, 1], format: gl.LUMINANCE, filter: false,
+    data: [80, 255, 80] },
+  { name: &#39;stripes&#39;,             color: [0.2, 1, 0.2, 1], format: gl.LUMINANCE, filter: false,
+    data: [80, 255, 80, 255, 80, 255, 80, 255, 80, 255, 80, 255, 80, 255, 80, 255, 80, 255, 80, 255, 80, 255, 80, 255, 80, 255, 80, 255, 80, 255, 80, 255] },
+  { name: &#39;stripe&#39;,              color: [0.2, 1, 0.2, 1], format: gl.LUMINANCE, filter: false,
+    data: [80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255] },
+  { name: &#39;smooth-solid&#39;,        color: [0.2, 1, 0.2, 1], format: gl.LUMINANCE, filter: false,
+    data: smoothSolid },
+  { name: &#39;rgb&#39;,                 color: [  1, 1,   1, 1], format: gl.RGB,       filter: true,
+    data: [255, 0, 0, 0, 255, 0, 0, 0, 255] },
+];
+
+var elementsForFormat = {};
+elementsForFormat[gl.LUMINANCE] = 1;
+elementsForFormat[gl.RGB      ] = 3;
+
+ramps.forEach((ramp) =&gt; {
+  const {name, format, filter, data} = ramp;
  var tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
+  gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
+  const width = data.length / elementsForFormat[format];
  gl.texImage2D(
      gl.TEXTURE_2D,     // target
      0,                 // mip level
*      format,            // internal format
*      width,
      1,                 // height
      0,                 // border
*     format,            // format
      gl.UNSIGNED_BYTE,  // type
*      new Uint8Array(data));
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
*  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter ? gl.LINEAR : gl.NEAREST);
*  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter ? gl.LINEAR : gl.NEAREST);
+  ramp.texture = tex;
+  ramp.size = [width, 1];
+});
</code></pre>
<p>и давайте создадим шейдер так, чтобы он мог обрабатывать как <code class="notranslate" translate="no">NEAREST, так и</code>LINEAR<code class="notranslate" translate="no">. 
Как я уже упоминал выше, я обычно не использую логические операторы if в шейдерах, 
но если различия небольшие и я могу сделать это без условия, то я рассмотрю возможность использования одного шейдера. 
Для этого мы можем добавить плавающую форму</code>u_linearAdjust`, которой мы установим значение 0,0 или 1,0.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">precision mediump float;

// Passed in from the vertex shader.
varying vec3 v_normal;

uniform vec3 u_reverseLightDirection;
uniform vec4 u_color;
uniform sampler2D u_ramp;
uniform vec2 u_rampSize;
-uniform bool u_useRampTexture;
-uniform float u_linearAdjust;  // 1.0 if linear, 0.0 if nearest

void main() {
  // because v_normal is a varying it&#39;s interpolated
  // so it will not be a unit vector. Normalizing it
  // will make it a unit vector again
  vec3 normal = normalize(v_normal);

  float cosAngle = dot(normal, u_reverseLightDirection);

  // convert from -1 &lt;-&gt; 1 to 0 &lt;-&gt; 1
  float u = cosAngle * 0.5 + 0.5;

  // make a texture coordinate.
  vec2 uv = vec2(u, 0.5);

  // scale to size of ramp
-  vec2 texelRange = uv * (u_rampSize - 1.0);
+  vec2 texelRange = uv * (u_rampSize - u_linearAdjust);

-  // offset by half a texel and convert to texture coordinate
-  vec2 rampUV = (texelRange + 0.5) / u_rampSize;
+  // offset by half a texel if linear and convert to texture coordinate
+  vec2 rampUV = (texelRange + 0.5 * u_linearAdjust) / u_rampSize;

  vec4 rampColor = texture2D(u_ramp, rampUV);

-  if (!u_useRampTexture) {
-    rampColor = vec4(u, u, u, 1);
-  }

  gl_FragColor = u_color;
  gl_FragColor *= rampColor;
}
</code></pre>
<p>во время инициализации найдите местоположение</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">var colorLocation = gl.getUniformLocation(program, &quot;u_color&quot;);
var rampLocation = gl.getUniformLocation(program, &quot;u_ramp&quot;);
var rampSizeLocation = gl.getUniformLocation(program, &quot;u_rampSize&quot;);
+var linearAdjustLocation = gl.getUniformLocation(program, &quot;u_linearAdjust&quot;);
</code></pre>
<p>и во время рендеринга выберите одну из текстур</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">var data = {
  ramp: 0,
};

...
+const {texture, color, size, filter} = ramps[data.ramp];

// Set the color to use
-gl.uniform4fv(colorLocation, [0.2, 1, 0.2, 1]);
+gl.uniform4fv(colorLocation, color);

// set the light direction.
gl.uniform3fv(reverseLightDirectionLocation, m4.normalize([-1.75, 0.7, 1]));

// bind the texture to active texture unit 0
gl.activeTexture(gl.TEXTURE0 + 0);
-gl.bindTexture(gl.TEXTURE_2D, tex);
+gl.bindTexture(gl.TEXTURE_2D, texture);
// tell the shader that u_ramp should use the texture on texture unit 0
gl.uniform1i(rampLocation, 0);
-gl.uniform2fv(rampSizeLocation, [2, 1]);
+gl.uniform2fv(rampSizeLocation, size);

+// adjust if linear
+gl.uniform1f(linearAdjustLocation, filter ? 1 : 0);
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-ramp-textures.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-ramp-textures.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Попробуйте различные ramp textures, и вы увидите множество странных эффектов. 
Это один из способов универсальной корректировки шейдера.
Вы можете создать шейдер, который выполняет двухцветное <em>toon shading</em>, 
установив 2 цвета и такой порог.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">uniform vec4 color1;
uniform vec4 color2;
uniform float threshold;

...

  float cosAngle = dot(normal, u_reverseLightDirection);

  // convert from -1 &lt;-&gt; 1 to 0 &lt;-&gt; 1
  float u = cosAngle * 0.5 + 0.5;

  gl_FragColor = mix(color1, color2, step(cosAngle, threshold));
</code></pre>
<p>И это сработает. Но если вам нужна трехэтапная или четырехшаговая версия, 
вам придется написать еще один шейдер. С <em>ramp texture</em> вы можете просто 
создать другую текстуру. Кроме того, обратите внимание выше: даже если вам 
нужен двухшаговый шейдер мультяшного изображения,
вы все равно можете настроить место выполнения шага, просто добавив больше 
или меньше данных в текстуру. Например текстура с</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">[dark, light]
</code></pre><p>Дает вам двухступенчатую текстуру, где она разделяется посередине между направлением к свету или от него. Но текстура типа</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">[dark, dark, dark, light, light]
</code></pre><p>позволит переместить разделение на отметку 60% между лицом от света и лицом к свету, и все это без необходимости изменения шейдера.</p>
<p>Этот конкретный пример использования <em>ramp texture</em> для <em>toon shading</em> или странных
эффектов может оказаться для вас полезным, а может и нет, но более важным выводом является 
просто базовая концепция использования некоторого значения для поиска данных в текстуре. 
Использование подобных текстур предназначено не только для преобразования расчета освещения. 
Вы можете использовать <em>ramp texture</em>  <a href="webgl-post-processing.html">для постобработки</a>, чтобы добиться того же эффекта, 
<a href="https://www.photoshopessentials.com/photo-effects/gradient-map/">что и карта градиента в фотошопе</a></p>
<p>Вы также можете использовать <em>ramp texture</em> для анимации на основе графического процессора. 
Вы сохраняете ключевые значения в текстуре и используете «time» в качестве значения 
для перемещения по текстуре. Есть много применений этой техники.</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-ramp-textures.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-ramp-textures.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-ramp-textures.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-ramp-textures.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-ramp-textures.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-ramp-textures.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-ramp-textures.html" selected>Русский</a>
    <option value="/webgl/lessons/uk/webgl-ramp-textures.html" >Українська</a>
    <option value="/webgl/lessons/zh_cn/webgl-ramp-textures.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Основы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-fundamentals.html">Основы WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-how-it-works.html">Как работает WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-shaders-and-glsl.html">Шейдеры и GLSL в WebGL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL State Diagram</a></li>
        </ul>
  <li>Обработка изображений</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-image-processing.html">Обработка изображений в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-image-processing-continued.html">Продолжаем обработку изображений в WebGL</a></li>
        </ul>
  <li>Математика переноса, поворота и масштабирования в 2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-translation.html">2D-перенос в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-rotation.html">2D-поворот в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-scale.html">2D-масштабирование в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrices.html">2D-матрицы в WebGL</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-orthographic.html">WebGL 3D - Ортогональ</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective.html">WebGL 3D - Перспектива</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-camera.html">WebGL 3D - Камеры</a></li>
        </ul>
  <li>Освещение</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-lighting-directional.html">WebGL 3D - Направленное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-point.html">WebGL 3D - Точечное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-spot.html">WebGL 3D - Прожектор</a></li>
        </ul>
  <li>Структура и устройство</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-less-code-more-fun.html">WebGL - Меньше кода, больше веселья</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-multiple-things.html">WebGL - Отрисовка нескольких объектов</a></li>
<li><a href="/webgl/lessons/ru/webgl-scene-graph.html">WebGL - Графы сцены</a></li>
        </ul>
  <li>Геометрия</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-geometry-lathe.html">WebGL 3D - Создание модели</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj.html">Loading .obj files</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>Текстуры</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-textures.html">WebGL 3D - Текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-data-textures.html">WebGL - Данные для текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-2-textures.html">WebGL - Использование 2 и более текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-cors-permission.html">WebGL - Кросс-доменные изображения</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective-correct-texturemapping.html">WebGL 3D - Перспективная коррекция текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>Рендеринг в текстуру</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-render-to-texture.html">WebGL - Рендеринг в текстуру</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>Приёмы</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-drawimage.html">WebGL 2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrix-stack.html">WebGL 2D - Стек матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-sprites.html">Sprites</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/ru/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/ru/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/ru/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/ru/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ru/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Текст</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-text-html.html">WebGL текст - HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-canvas2d.html">WebGL текст - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-texture.html">WebGL текст - Используем текстуру</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-glyphs.html">WebGL текст - Используем глиф-текстуру</a></li>
        </ul>
  <li>Текстуры</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-ramp-textures.html">Ramp Textures (Toon Shading)</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-smallest-programs.html">Небольшие программы WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/ru/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ru/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ru/webgl-instanced-drawing.html">Instanced Drawing</a></li>
        </ul>
  <li>Разное</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-setup-and-installation.html">WebGL Установка и настройка</a></li>
<li><a href="/webgl/lessons/ru/webgl-boilerplate.html">Шаблон WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-resizing-the-canvas.html">Изменение размера Canvas в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-animation.html">WebGL - Анимация</a></li>
<li><a href="/webgl/lessons/ru/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/ru/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/ru/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/ru/webgl-and-alpha.html">WebGL и прозрачность</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-vs-3d-library.html">WebGL - 2D и 3D библиотеки</a></li>
<li><a href="/webgl/lessons/ru/webgl-anti-patterns.html">WebGL - Антипаттерны</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/ru/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#html-background">Use WebGL as Background in HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/ru/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/ru/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/ru/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/ru/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ru/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Документация по вспомогательным функциям</a></li>
  <li><a href="https://twgljs.org">TWGL, лёгкая библиотека-помощник для WebGL</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>Нашли ошибку? <a href="https://github.com/gfxfundamentals/webgl-fundamentals/issues">Создайте задачу на github</a>.</div>

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL Ramp Textures';
            var disqus_title = 'WebGL Ramp Textures';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>



