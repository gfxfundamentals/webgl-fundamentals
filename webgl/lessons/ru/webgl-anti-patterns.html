<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ru/webgl-anti-patterns.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Что и почему не нужно делать в WebGL, и что следует использовать" />
<meta name="keywords" content="webgl graphics" />
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-anti-patterns_ru.jpg" />

<meta property="og:title" content="WebGL - Антипаттерны" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-anti-patterns_ru.jpg" />
<meta property="og:description" content="Что и почему не нужно делать в WebGL, и что следует использовать" />
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/ru/webgl-anti-patterns.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webglfundamentals.org" />
<meta name="twitter:title" content="WebGL - Антипаттерны" />
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/ru/webgl-anti-patterns.html" />
<meta name="twitter:description" content="Что и почему не нужно делать в WebGL, и что следует использовать" />
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-anti-patterns_ru.jpg" />

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/ru/webgl-anti-patterns.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-anti-patterns_ru.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/ru/webgl-anti-patterns.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/ru/webgl-anti-patterns.html",
      "inLanguage":"ru",
      "name":"WebGL - Антипаттерны",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/ru/webgl-anti-patterns.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL - Антипаттерны</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />



</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-anti-patterns.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-anti-patterns.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-anti-patterns.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-anti-patterns.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-anti-patterns.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-anti-patterns.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-anti-patterns.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-anti-patterns.html" >简体中文</a>
</select>


    <a href="#toc">оглавление</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ru/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub a {
    background: #000;
    color: #fff;
    text-decoration: none;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 2rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 300px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(150px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a:hover {
    background: #c11;
    color: #fff;
}
#forkongithub a::before,#forkongithub a::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub a::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
@media (max-width: 900px) {
    #forkongithub a{
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub a{
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL - Антипаттерны</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Ниже приведён список антипаттернов в WebGL. Антипаттерны - это вещи, которых стоит избегать.</p>
<ol>
<li><p>Добавление свойств <code class="notranslate" translate="no">viewportWidth</code> и <code class="notranslate" translate="no">viewportHeight</code> объекту <code class="notranslate" translate="no">WebGLRenderingContext</code></p>
<p>Порой можно встретить, что значения ширины и высоты области просмотра
записываются в свойства объекта <code class="notranslate" translate="no">WebGLRenderingContext</code>, например так:</p>
<pre class="prettyprint">
gl = canvas.getContext("webgl");
gl.viewportWidth = canvas.width;    // ПЛОХО!!!
gl.viewportHeight = canvas.height;  // ПЛОХО!!!
</pre>

<p>Затем свойства могут использоваться следующим образом:</p>
<pre class="prettyprint">
gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
</pre>

<p><strong>Почему это плохо:</strong></p>
<p>Это объективно плохо, потому что теперь у вас появляется 2 свойства, которые
нужно не забывать обновлять каждый раз при изменении размера canvas. Например,
при изменении размера окна пользователем свойства <code class="notranslate" translate="no">gl.viewportWidth</code> и
<code class="notranslate" translate="no">gl.viewportHeight</code> будут некорректными, их нужно обновить согласно новым
размерам canvas.</p>
<p>Это субъективно плохо, потому что новички в WebGL посмотрят на ваш код и
подумают, что <code class="notranslate" translate="no">gl.viewportWidth</code> и <code class="notranslate" translate="no">gl.viewportHeight</code> - часть спецификации
WebGL, что введёт их в заблуждение, возможно, на месяцы.</p>
<p><strong>Что делать вместо этого:</strong></p>
<p>Зачем создавать себе больше работы? Контекст WebGL уже содержит ширину и
высоту. Просто используйте их.</p>
<pre class="prettyprint">
// если вам необходимо, чтобы область просмотра соответствовала размеру
// буфера отрисовки canvas'а, это всегда будет работать
gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
</pre>

<p>Такой подход даже лучше справится со сложными случаями, где использование
<code class="notranslate" translate="no">gl.canvas.width</code> и <code class="notranslate" translate="no">gl.canvas.height</code> не поможет. <a href="#drawingbuffer">Объяснение смотри ниже</a>.</p>
</li>
<li><p>Использование <code class="notranslate" translate="no">canvas.width</code> и <code class="notranslate" translate="no">canvas.height</code> для соотношения сторон экрана</p>
<p>Часто можно увидеть код, использующий <code class="notranslate" translate="no">canvas.width</code> и <code class="notranslate" translate="no">canvas.height</code> для
соотношения сторон экрана, например:</p>
<pre class="prettyprint">
var aspect = canvas.width / canvas.height;
perspective(fieldOfView, aspect, zNear, zFar);
</pre>

<p><strong>Почему это плохо:</strong></p>
<p>Ширина и высота canvas никак не связана с тем размером, как canvas отображается
на странице. За размер canvas на странице отвечает CSS.</p>
<p><strong>Что делать вместо этого:</strong></p>
<p>Используйте <code class="notranslate" translate="no">canvas.clientWidth</code> и <code class="notranslate" translate="no">canvas.clientHeight</code>. Эти размеры вернут
реальный размер отображаемого на экране canvas. Используя эти свойства, у вас
всегда будет правильное соотношение сторон экрана, независимо от CSS.</p>
<pre class="prettyprint">
var aspect = canvas.clientWidth / canvas.clientHeight;
perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);
</pre>

<p>Ниже идут несколько примеров canvas с одинаковым размером (<code class="notranslate" translate="no">width=&quot;400&quot; height=&quot;300&quot;</code>),
но через CSS мы задаём разный размер отображения в браузере. Заметьте, что
примеры сохраняют корректное соотношение сторон экрана.</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 150px; height: 200px;" src="/webgl/lessons/../webgl-canvas-clientwidth-clientheight.html"></iframe>
</div>


<p></p>
<div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 400px; height: 150px;" src="/webgl/lessons/../webgl-canvas-clientwidth-clientheight.html"></iframe>
</div>

</p>
<p>А если мы используем <code class="notranslate" translate="no">canvas.width</code> и <code class="notranslate" translate="no">canvas.height</code>, изображение искажается.</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 150px; height: 200px;" src="/webgl/lessons/../webgl-canvas-width-height.html"></iframe>
</div>


<p></p>
<div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 400px; height: 150px;" src="/webgl/lessons/../webgl-canvas-width-height.html"></iframe>
</div>

</p>
</li>
<li><p>Использование для вычислений <code class="notranslate" translate="no">window.innerWidth</code> и <code class="notranslate" translate="no">window.innerHeight</code></p>
<p>Многие программы WebGL используют <code class="notranslate" translate="no">window.innerWidth</code> и <code class="notranslate" translate="no">window.innerHeight</code>
во многих местах. Например:</p>
<pre class="prettyprint">
canvas.width = window.innerWidth;                    // ПЛОХО!!
canvas.height = window.hinnerHeight;                 // ПЛОХО!!
</pre>

<p><strong>Почему это плохо:</strong></p>
<p>Это не переносится. Да, это будет работать на HTML-страницах, где вы хотите растянуть
canvas на весь экран. Проблема появится, когда полноэкранный режим станет не нужен.
Возможно, вы решите сделать статью подобную моей, где canvas - лишь небольшая часть
большой страницы. А может сбоку вам нужен редактор свойств или статистика по игре.
Конечно, вы сможете обойти эти ситуации, но почему бы сразу не написать код так,
чтобы он работал везде? Тогда вам не придётся менять его при создании нового проекта
или использование старого проекта по-новому.</p>
<p><strong>Что делать вместо этого:</strong></p>
<p>Вместо того, чтобы бороться с веб-страницей, сотрудничайте с ней! Используйте
CSS вместе с <code class="notranslate" translate="no">clientWidth</code> и <code class="notranslate" translate="no">clientHeight</code>.</p>
<pre class="prettyprint">
var width = gl.canvas.clientWidth;
var height = gl.canvas.clientHeight;

gl.canvas.width = width;
gl.canvas.height = height;
</pre>

<p>Ниже приведены 9 примеров. Все они используют один и тот же код. Ни один из
них не использует ни <code class="notranslate" translate="no">window.innerWidth</code>, ни <code class="notranslate" translate="no">window.innerHeight</code>.</p>
<p><a href="../../webgl-same-code-canvas-fullscreen.html" target="_blank">Страница с единственным элементом canvas, растянутым на весь экран через CSS</a></p>
<p><a href="../../webgl-same-code-canvas-partscreen.html" target="_blank">Страница с canvas размером 70% ширины страницы, чтобы осталось место для контрольной панели</a></p>
<p><a href="../../webgl-same-code-canvas-embedded.html" target="_blank">Страница с canvas внутри параграфа</a></p>
<p><a href="../../webgl-same-code-canvas-embedded-border-box.html" target="_blank">Страница с canvas внутри параграфа, использует <code class="notranslate" translate="no">box-sizing: border-box;</code></a></p>
<p>При использовании <code class="notranslate" translate="no">box-sizing: border-box;</code> границы и внутренние отступы забирают пространство самого элемента, а не области вокруг него.
Другими словами, в обычном режиме box-sizing элемент размером 400x300 пикселей с границей толщиной 15 пикселей будет содержать 400x300 пикселей контента
и будет окружён границей толщиной 15 пикселей, то есть итоговый размер составит 430x330 пикселей. В режиме box-sizing: border-box граница уйдёт внутрь,
поэтому суммарный размер элемента останется 400x300 пикселей, а контент займёт 370x270 пикселей. Это ещё одна причина, по которой вам нужно использовать
<code class="notranslate" translate="no">clientWidth</code> и <code class="notranslate" translate="no">clientHeight</code>. При установки ширины границы, скажем, <code class="notranslate" translate="no">1em</code> вы не будете знать, какой размер у неё будет, так как он будет разным в
зависимости от шрифта, компьютера, браузера.</p>
<p><a href="../../webgl-same-code-container-fullscreen.html" target="_blank">Страница, содержащая только контейнер, которому через CSS задан полноэкранный размер, и в который через код вставлен canvas</a></p>
<p><a href="../../webgl-same-code-container-partscreen.html" target="_blank">Страница с контейнером шириной 70%, чтобы оставить место для панели управления, в который через код вставлен canvas</a></p>
<p><a href="../../webgl-same-code-container-embedded.html" target="_blank">Страница с контейнером, вставленным в параграф, в который через код вставлен canvas</a></p>
<p><a href="../../webgl-same-code-container-embedded-border-box.html" target="_blank"> Страница с контейнером, вставленным в параграф, используется <code class="notranslate" translate="no">box-sizing: border-box;</code>, в контейнер через код вставлен canvas</a></p>
<p><a href="../../webgl-same-code-body-only-fullscreen.html" target="_blank">Страница без элементов, настроенная через CSS для полноэкранного режима, в которую через код вставлен canvas</a></p>
<p>Повторюсь, что смысл в том, чтобы при написании кода, используя описанные
техники, вам не пришлось менять код, сталкиваясь с различными ситуациями.</p>
</li>
<li><p>Использование события <code class="notranslate" translate="no">&#39;resize&#39;</code> для изменения размера canavs</p>
<p>Некоторые приложения отслеживают событие <code class="notranslate" translate="no">&#39;resize&#39;</code>, чтобы подстроить размер canavs.</p>
<pre class="prettyprint">
window.addEventListener('resize', resizeTheCanvas);
</pre>

<p>или так</p>
<pre class="prettyprint">
window.onresize = resizeTheCanvas;
</pre>

<p><strong>Почему это плохо:</strong></p>
<p>Само по себе это не плохо. Просто для <em>большинства</em> программ на WebGL такое
решение не охватывает некоторых ситуаций. Событие <code class="notranslate" translate="no">&#39;resize&#39;</code> срабатывает, только
когда размер окна меняется. Оно не сработает, если по каким-то причинам изменился
размер canvas. Например, вы делаете 3D-редактор. Ваш canvas находится слева,
настройки расположены справа. И у вас есть возможность расширять или сужать
панель настроек, потянув за границу между настройками и canvas. В этом случае
не будет никакого события <code class="notranslate" translate="no">&#39;resize&#39;</code>. Аналогично, при добавлении или удалении
контента на страницу размер canvas может меняться, и вы тоже не получите события
<code class="notranslate" translate="no">&#39;resize&#39;</code>.</p>
<p><strong>Что делать вместо этого:</strong></p>
<p>Как и во многих решениях выше, в данном случае есть способ написать код так, чтобы
он работал в большинстве ситуаций. Для приложений WebGL, которые постоянно
отображают каждый кадр, можно проверять размер перед отрисовкой, и в зависимости
от результата обновлять размер.</p>
<pre class="prettyprint">
function resize() {
  var width = gl.canvas.clientWidth;
  var height = gl.canvas.clientHeight;
  if (gl.canvas.width != width ||
      gl.canvas.height != height) {
     gl.canvas.width = width;
     gl.canvas.height = height;
  }
}

function render() {
   resize();
   drawStuff();
   requestAnimationFrame(render);
}
render();
</pre>

<p>Теперь во всех описанных выше ситуациях canvas будет всегда иметь правильный
размер. Нет необходимости менять код для отдельных случаев. Например, используя
код из примера #3, сделаем редактор с возможностью менять размер панели настроек.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-same-code-resize.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-same-code-resize.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>В этом примере не будет события изменений размера, как и в других случаях, когда
размер canvas меняется динамически в зависимости от других элементов страницы.</p>
<p>Для приложений, где не отрисовывается каждый кадр, код по-прежнему будет работать,
вам нужно лишь вызывать перерисовку при изменении размера canvas. Одним из решений
будет использование цикла requestAnimationFrame следующим образом:</p>
<pre class="prettyprint">
function resize() {
  var width = gl.canvas.clientWidth;
  var height = gl.canvas.clientHeight;
  if (gl.canvas.width != width ||
      gl.canvas.height != height) {
     gl.canvas.width = width;
     gl.canvas.height = height;
     return true;
  }
  return false;
}

var needToRender = true;  // необходимо отрисовать хотя бы раз
function checkRender() {
   if (resize() || needToRender) {
     needToRender = false;
     drawStuff();
   }
   requestAnimationFrame(checkRender);
}
checkRender();
</pre>

<p>Здесь отрисовка будет происходить только в том случае, когда размер canvas изменился
или значение <code class="notranslate" translate="no">needToRender</code> равно true. Таким образом мы решим проблему изменения
размера в приложениях, которые не отрисовывают каждый кадр. Просто установите
<code class="notranslate" translate="no">needToRender</code> в значение true, когда на сцене что-то изменилось, и вы хотите
отрисовать сцену, чтобы отразить эти изменения.</p>
</li>
<li><p>Добавление свойств к объектам <code class="notranslate" translate="no">WebGLObject</code></p>
<p>Объекты <code class="notranslate" translate="no">WebGLObject</code> - это различные виды ресурсов в WebGL, например, <code class="notranslate" translate="no">WebGLBuffer</code>
или <code class="notranslate" translate="no">WebGLTexture</code>. Некоторые приложения добавляют свои свойства к этим объектам.
Например, код может выглядеть так:</p>
<pre class="prettyprint">
var buffer = gl.createBuffer();
buffer.itemSize = 3;        // ПЛОХО!!
buffer.numComponents = 75;  // ПЛОХО!!

var program = gl.createProgram();
...
program.u_matrixLoc = gl.getUniformLocation(program, "u_matrix");  // ПЛОХО!!
</pre>

<p><strong>Почему это плохо:</strong></p>
<p>Причина заключается в том, что WebGL может &quot;потерять контекст&quot;&quot;. Это может случиться по
многим причинам, но чаще всего возникает ситуация, когда браузер решает, что используется
слишком много ресурсов видеокарты, и вытесняет контекст некоторых <code class="notranslate" translate="no">WebGLRenderingContext</code>,
чтобы освободить память. Программам WebGL, работающим без остановки, необходимо отлавливать
эту ситуацию. Например, Google Maps обрабатывает такую ситуацию.</p>
<p>Проблема упомянутого кода в том, что при потере контекста теряются и функции создания
объектов, например <code class="notranslate" translate="no">gl.createBuffer()</code> вернёт <code class="notranslate" translate="no">null</code>. Поэтому следующий код</p>
<pre class="prettyprint">
var buffer = null;
buffer.itemSize = 3;        // ОШИБКА!
buffer.numComponents = 75;  // ОШИБКА!
</pre>

<p>скорей всего прекратит выполнение вашего приложение с ошибкой</p>
<pre class="prettyprint">
TypeError: Cannot set property 'itemSize' of null
</pre>

<p>Многим приложениям не важно, если они завершатся по ошибке при потере контекста, но всё
же это является плохой практикой, потому что разработчику придётся исправлять код, если
ему понадобится обрабатывать ситуацию с потерей контекста.</p>
<p><strong>Что делать вместо этого:</strong></p>
<p>Если вам нужно сохранить <code class="notranslate" translate="no">WebGLObjects</code> и другую информации в одном месте, одним
из способов будет использование объектов JavaScript. Например:</p>
<pre class="prettyprint">
var bufferInfo = {
  id: gl.createBuffer(),
  itemSize: 3,
  numComponents: 75,
};

var programInfo = {
  id: program,
  u_matrixLoc: gl.getUniformLocation(program, "u_matrix"),
};
</pre>

<p>Лично я бы предложил использовать <a href="webgl-less-code-more-fun.html">несколько простых
помощников, которые облегчат написание кода WebGL</a>.</p>
</li>
</ol>
<p>Описанные выше ситуации, которые я отношу к антипаттернам WebGL, я встретил на просторах
интернета. Надеюсь, я показал, почему их нужно избегать, а приведённые решение будут
вам полезны.</p>
<div class="webgl_bottombar"><a id="drawingbuffer"></a><h3>Что такое drawingBufferWidth и drawingBufferHeight?</h3>
<p>
В видеокарте есть ограничение на размер прямоугольника пикселей (текстуры, буфера отрисовки). Обычно этот
размер является степенью двойки и при этом превышает разрешение монитора, которое распространено на момент
выпуска видеокарты. Например, если видеокарта выпущена для мониторов 1280x1024, её ограничением скорей
всего будет значение 2048. В случае с мониторами разрешением 2560x1600 ограничение видеокарты составит 4096.
</p><p>
Это кажется разумным, но что случится, если у вас несколько мониторов? Скажем, у меня видеокарта с
ограничением 2048, но у меня два монитора 1920x1080. Пользователь откроет окно браузера со страницей
WebGL и растянет окно на два монитора. Ваш код попытается установить <code class="notranslate" translate="no">canvas.width</code> в значение
<code class="notranslate" translate="no">canvas.clientWidth</code> , которое в данный момент равно 3840. Что произойдёт?
<p>У меня сходу есть 3 варианта</p>
<ol>
<li>
 <p>Исключение</p>
 <p>Плохой сценарий. Большинство приложений не проверят это исключение и прервут
 выполнение. Если в приложении были данные пользователя, они потеряются.</p>
</li>
<li>
 <p>Ограничить размер canvas до ограничения видеокарты</p>
 <p>Это решение тоже, вероятно, приведёт к прерыванию работы программы или другим проблемам
 на странице, так как код ожидает, что размер canvas будет другим, и что другие части
 интерфейса будут на своих местах страницы.</p>
</li>
<li>
 <p>Размер canvas может быть любым, но буфер отрисовки будет ограничен</p>
 <p>Это решение, которое использует WebGL. Если ваш код написан верно, пользователь сможет заметить лишь то,
 что изображение на canvas немного растянулось. В других случаях всё будет в порядке. В худшем случае,
 когда ваш код написан не совсем корректно, пользователь увидит смещение картинки, но при уменьшении
 размера окна картинка будет отображаться нормально.</p>
</li>
</ol>
<p>У большинства пользователей один монитор, поэтому проблема возникает редко. Или, по крайней мере,
возникала редко. Chrome и Safari, во всяком случае на январь 2015 года, имели встроенное ограничение
canvas 4096. У Apple iMac 5k ограничение было выше. Из-за этого многие приложения WebGL имели странности
с отображением. Аналогично многие люди начали использовать WebGL с двумя мониторами для работы с
инсталляциями и тоже достигли ограничения.</p>
<p>
Поэтому если вы хотите обработать эти случаи, используйте <code class="notranslate" translate="no">gl.drawingBufferWidth</code> и
<code class="notranslate" translate="no">gl.drawingBufferHeight</code>, как показано в примере #1. Для большинства приложений при следовании
советам, описанных выше, всё будет работать без проблем. Однако, если вы выполняете вычисления, для которых
нужен реальный размер буфера отрисовки, вам нужно принять во внимание описанное выше. Например, выбор
объектов сцены, где нужно преобразовать координаты мыши в пиксели canvas. Другой пример - пост-эффекты,
для которых нужно знать реальный размер буфера отрисовки.
</p>
</div>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-anti-patterns.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-anti-patterns.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-anti-patterns.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-anti-patterns.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-anti-patterns.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-anti-patterns.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-anti-patterns.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-anti-patterns.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Основы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-fundamentals.html">Основы WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-how-it-works.html">Как работает WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-shaders-and-glsl.html">Шейдеры и GLSL в WebGL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL State Diagram</a></li>
        </ul>
  <li>Обработка изображений</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-image-processing.html">Обработка изображений в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-image-processing-continued.html">Продолжаем обработку изображений в WebGL</a></li>
        </ul>
  <li>Математика переноса, поворота и масштабирования в 2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-translation.html">2D-перенос в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-rotation.html">2D-поворот в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-scale.html">2D-масштабирование в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrices.html">2D-матрицы в WebGL</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-orthographic.html">WebGL 3D - Ортогональ</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective.html">WebGL 3D - Перспектива</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-camera.html">WebGL 3D - Камеры</a></li>
        </ul>
  <li>Освещение</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-lighting-directional.html">WebGL 3D - Направленное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-point.html">WebGL 3D - Точечное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-spot.html">WebGL 3D - Прожектор</a></li>
        </ul>
  <li>Структура и устройство</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-less-code-more-fun.html">WebGL - Меньше кода, больше веселья</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-multiple-things.html">WebGL - Отрисовка нескольких объектов</a></li>
<li><a href="/webgl/lessons/ru/webgl-scene-graph.html">WebGL - Графы сцены</a></li>
        </ul>
  <li>Геометрия</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-geometry-lathe.html">WebGL 3D - Создание модели</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj.html">Loading .obj files</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>Текстуры</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-textures.html">WebGL 3D - Текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-data-textures.html">WebGL - Данные для текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-2-textures.html">WebGL - Использование 2 и более текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-cors-permission.html">WebGL - Кросс-доменные изображения</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective-correct-texturemapping.html">WebGL 3D - Перспективная коррекция текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>Рендеринг в текстуру</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-render-to-texture.html">WebGL - Рендеринг в текстуру</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>Приёмы</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-drawimage.html">WebGL 2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrix-stack.html">WebGL 2D - Стек матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-sprites.html">Sprites</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/ru/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/ru/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/ru/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/ru/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ru/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Текст</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-text-html.html">WebGL текст - HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-canvas2d.html">WebGL текст - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-texture.html">WebGL текст - Используем текстуру</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-glyphs.html">WebGL текст - Используем глиф-текстуру</a></li>
        </ul>
  <li>Текстуры</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-ramp-textures.html">Ramp Textures (Toon Shading)</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/ru/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ru/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ru/webgl-instanced-drawing.html">Instanced Drawing</a></li>
        </ul>
  <li>Разное</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-setup-and-installation.html">WebGL Установка и настройка</a></li>
<li><a href="/webgl/lessons/ru/webgl-boilerplate.html">Шаблон WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-resizing-the-canvas.html">Изменение размера Canvas в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-animation.html">WebGL - Анимация</a></li>
<li><a href="/webgl/lessons/ru/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/ru/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/ru/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/ru/webgl-and-alpha.html">WebGL и прозрачность</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-vs-3d-library.html">WebGL - 2D и 3D библиотеки</a></li>
<li><a href="/webgl/lessons/ru/webgl-anti-patterns.html">WebGL - Антипаттерны</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/ru/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#html-background">Use WebGL as Background in HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/ru/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/ru/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/ru/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ru/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Документация по вспомогательным функциям</a></li>
  <li><a href="https://twgljs.org">TWGL, лёгкая библиотека-помощник для WebGL</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>Вопросы? <a href="https://stackoverflow.com/questions/tagged/webgl">Спросите на stackoverflow</a>.</div>
        <div>Нашли ошибку? <a href="https://github.com/gfxfundamentals/webgl-fundamentals/issues">Создайте задачу на github</a>.</div>

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL - Антипаттерны';
            var disqus_title = 'WebGL - Антипаттерны';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
      return;
  }

  function addScript(src, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  addScript('//cdn.webglstats.com/stat.js');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>



