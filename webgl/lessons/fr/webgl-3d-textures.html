<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/fr/webgl-3d-textures.md. Do not edited directly -->
<!--
Copyright 2021 GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Comment fonctionne les textures en WebGL">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-3d-textures_fr.jpg">

<meta property="og:title" content="WebGL Textures">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-3d-textures_fr.jpg">
<meta property="og:description" content="Comment fonctionne les textures en WebGL">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/fr/webgl-3d-textures.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGL Textures">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/fr/webgl-3d-textures.html">
<meta name="twitter:description" content="Comment fonctionne les textures en WebGL">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-3d-textures_fr.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/fr/webgl-3d-textures.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-3d-textures_fr.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/fr/webgl-3d-textures.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/fr/webgl-3d-textures.html",
      "inLanguage":"fr",
      "name":"WebGL Textures",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/fr/webgl-3d-textures.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL Textures</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-3d-textures.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-3d-textures.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-3d-textures.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-3d-textures.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-3d-textures.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-3d-textures.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-3d-textures.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-3d-textures.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-3d-textures.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-3d-textures.html" selected>Français</a>
    <option value="/webgl/lessons/ja/webgl-3d-textures.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-3d-textures.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-3d-textures.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-3d-textures.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-3d-textures.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-3d-textures.html" >简体中文</a>
</select>


    <a href="#toc">Table des Matières</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/fr/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL Textures</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Cet article est la suite d&#39;une série d&#39;articles sur WebGL. Le premier <a href="webgl-fundamentals.html">a
commencé avec les fondamentaux</a> et le précédent
concernait <a href="webgl-animation.html">animation</a>.</p>
<p>Comment appliquons-nous les textures en WebGL ? Vous pourriez probablement
déduire comment si vous avez lu <a href="webgl-image-processing.html">les articles sur le traitement
d&#39;image</a> mais ce sera probablement plus facile à
comprendre si nous l&#39;examinons plus en détail détail.</p>
<p>La première chose que nous devons faire est d&#39;ajuster nos shaders pour utiliser
des textures. Voici les modifications apportées au vertex shader, il faut lui
passer les coordonnées de la texture. Ensuite, nous les transmettrons directement au
fragment shader.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">attribute vec4 a_position;
*attribute vec2 a_texcoord;

uniform mat4 u_matrix;

*varying vec2 v_texcoord;

void main() {
  // Multiply the position by the matrix.
  gl_Position = u_matrix * a_position;

*  // Pass the texcoord to the fragment shader.
*  v_texcoord = a_texcoord;
}
</code></pre><p>Dans le fragment shader nous déclarons une variable uniform sampler2D qui nous permet
de référencer une texture. Nous utilisons les coordonnées de texture passées du
vertex shader et nous appelons <code class="notranslate" translate="no">texture2D</code> pour rechercher la couleur à partir
de cette texture.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">precision mediump float;

// Passed in from the vertex shader.
*varying vec2 v_texcoord;

*// The texture.
*uniform sampler2D u_texture;

void main() {
*   gl_FragColor = texture2D(u_texture, v_texcoord);
}
</code></pre><p>Nous devons configurer les coordonnées de texture</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// look up where the vertex data needs to go.
var positionLocation = gl.getAttribLocation(program, &quot;a_position&quot;);
*var texcoordLocation = gl.getAttribLocation(program, &quot;a_texcoord&quot;);

...

*// Create a buffer for texcoords.
var buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
*gl.enableVertexAttribArray(texcoordLocation);
*
*// We&#39;ll supply texcoords as floats.
*gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);
*
*// Set Texcoords.
*setTexcoords(gl);
</code></pre><p>Et vous pouvez voir les coordonnées que nous utilisons et qui cartographient
l&#39;ensemble de la texture à chaque quad sur notre &#39;F&#39;.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">*// Fill the buffer with texture coordinates for the F.
*function setTexcoords(gl) {
*  gl.bufferData(
*      gl.ARRAY_BUFFER,
*      new Float32Array([
*        // left column front
*        0, 0,
*        0, 1,
*        1, 0,
*        0, 1,
*        1, 1,
*        1, 0,
*
*        // top rung front
*        0, 0,
*        0, 1,
*        1, 0,
*        0, 1,
*        1, 1,
*        1, 0,
* ...
*       ]),
*       gl.STATIC_DRAW);
</code></pre><p>Nous avons également besoin d&#39;une texture. Nous pourrions en créer une à partir
de zéro, mais ici nous chargeons une image, car c&#39;est probablement le moyen le
plus courant.</p>
<p>Voici l&#39;image que nous allons utiliser</p>
<p><img class="webgl_center" src="../../resources/f-texture.png" /></p>
<p>Quelle image passionnante ! En fait, une image avec un &#39;F&#39; dessus a
une direction clair afin qu&#39;il soit facile de dire si elle est tournée ou retournée, etc.
lorsque nous l&#39;utilisons comme une texture.</p>
<p>La chose à propos du chargement d&#39;une image est qu&#39;elle se produit de manière
asynchrone. Nous selectionnons l&#39;image à charger mais le navigateur met un certain
temps à la télécharger. Il y a généralement 2 solutions à cela. On pourrait
faire attendre le code jusqu&#39;à ce que la texture soit téléchargée et ensuite
seulement commencer à dessiner. L&#39;autre solution consiste à créer une texture
à utiliser jusqu&#39;à ce que l&#39;image soit téléchargée. De cette façon, nous pouvons
commencer le rendu immédiatement. Ensuite, une fois que l&#39;image a été
téléchargé, nous copions l&#39;image dans la texture. Nous utiliserons cette méthode
ci-dessous.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">*// Create a texture.
*var texture = gl.createTexture();
*gl.bindTexture(gl.TEXTURE_2D, texture);
*
*// Fill the texture with a 1x1 blue pixel.
*gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
*              new Uint8Array([0, 0, 255, 255]));
*
*// Asynchronously load an image
*var image = new Image();
*image.src = &quot;resources/f-texture.png&quot;;
*image.addEventListener(&#39;load&#39;, function() {
*  // Now that the image has loaded make copy it to the texture.
*  gl.bindTexture(gl.TEXTURE_2D, texture);
*  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, image);
*  gl.generateMipmap(gl.TEXTURE_2D);
*});
</code></pre><p>Et voilà</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures.html" target="_blank">Cliquer ici pour ouvrir dans une nouvelle fenêtre</a>
</div>

</p>
<p>Et si nous voulions simplement utiliser une partie de la texture sur le devant
du « F » ? Les textures sont référencées avec des &quot;coordonnées de texture&quot; et les
coordonnées de texture vont de 0.0 à 1.0 de gauche à la largeur de la texture, et de
0,0 à 1,0 du premier pixel de la première ligne au dernier pixel de la dernière
ligne. Remarquez que je n&#39;ai pas dit en haut ou en bas. Le haut et le bas
n&#39;ont aucun sens dans l&#39;espace de texture parce que jusqu&#39;à ce que vous
dessiniez quelque chose et que vous l&#39;orientiez, il n&#39;y a ni haut ni bas. Ce qui
compte, c&#39;est de fournir des données de texture à WebGL. Le début de ces données
commence à la coordonnée de texture 0,0 et la fin de ces données est à 1,1</p>
<p><img class="webgl_center noinvertdark" width="405" src="../resources/texture-coordinates-diagram.svg" /></p>
<p>J&#39;ai chargé la texture dans Photoshop et j&#39;ai recherché les différentes
coordonnées en pixels.</p>
<p><img class="webgl_center" width="256" height="256" src="../../resources/f-texture-pixel-coords.png" /></p>
<p>Pour convertir des coordonnées en pixel en coordonnées de texture, nous pouvons
simplement utiliser</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">texcoordX = pixelCoordX / (width  - 1)
texcoordY = pixelCoordY / (height - 1)
</code></pre><p>Voici les coordonnées de texture pour le devant.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// left column front
 38 / 255,  44 / 255,
 38 / 255, 223 / 255,
113 / 255,  44 / 255,
 38 / 255, 223 / 255,
113 / 255, 223 / 255,
113 / 255,  44 / 255,

// top rung front
113 / 255, 44 / 255,
113 / 255, 85 / 255,
218 / 255, 44 / 255,
113 / 255, 85 / 255,
218 / 255, 85 / 255,
218 / 255, 44 / 255,

// middle rung front
113 / 255, 112 / 255,
113 / 255, 151 / 255,
203 / 255, 112 / 255,
113 / 255, 151 / 255,
203 / 255, 151 / 255,
203 / 255, 112 / 255,
</code></pre><p>J&#39;ai également utilisé des coordonnées de texture similaires pour le dos. Et les
voici.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-texture-coords-mapped.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-texture-coords-mapped.html" target="_blank">Cliquer ici pour ouvrir dans une nouvelle fenêtre</a>
</div>

</p>
<p>Pas un affichage très excitant, mais j&#39;espère qu&#39;il montre comment utiliser
coordonnées de texture. Si vous faites de la géométrie dans le code (cubes,
sphères, etc) il est généralement assez facile de calculer les coordonnées de texture que vous
voulez. D&#39;autre part, si vous obtenez des modèles 3D à partir de
logiciel de modélisation 3D comme Blender, Maya, 3D Studio Max, vos
artistes (ou vous) ajusterez les coordonnées de texture dans ces packages.</p>
<p>Que se passe-t-il si nous utilisons des coordonnées de texture en dehors de la gamme 0,0
à 1,0. Par défaut, WebGL répète la texture. 0.0 à 1.0 est une &quot;copie&quot; de
la texture. 1.0 à 2.0 est une autre copie. Même -4,0 à -3,0 est encore un autre
exemplaire. Affichons un plan en utilisant ces coordonnées de texture.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no"> -3, -1,
  2, -1,
 -3,  4,
 -3,  4,
  2, -1,
  2,  4,
</code></pre><p>Et voilà</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-repeat-clamp.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-repeat-clamp.html" target="_blank">Cliquer ici pour ouvrir dans une nouvelle fenêtre</a>
</div>

</p>
<p>Vous pouvez indiquer à WebGL de ne pas répéter la texture dans une certaine
direction en utilisant <code class="notranslate" translate="no">CLAMP_TO_EDGE</code>. Par exemple</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
</code></pre><p>Cliquez sur les boutons dans l&#39;exemple ci-dessus pour voir la différence.</p>
<p>Vous avez peut-être remarqué un appel à <code class="notranslate" translate="no">gl.generateMipmap</code> lorsque nous avons
chargé la texture. C&#39;est pour quoi ?</p>
<p>Imaginez que nous ayons une texture de 16x16 pixels.</p>
<p><img class="webgl_center" src="../resources/mip-low-res-enlarged.png" style="border: 2px solid black;" /></p>
<p>Imaginez maintenant que nous ayons essayé de dessiner cette texture sur un
polygone de 2x2 pixels de large sur l&#39;écran. De quelles couleurs seront
ces 4 pixels ? Il y a 256 pixels au choix. Dans Photoshop, si vous avez mis à
l&#39;échelle une image de 16x16 pixels en 2x2 pixels, il fera la moyenne des 8x8
pixels de chaque côté de l&#39;image pour calculer les 4 pixels de l&#39;image 2x2.
Malheureusement, lire 64 pixels et en faire la moyenne serait
beaucoup trop lent pour un GPU. En fait, imaginez si vous aviez une texture de
2048x2048 pixels et que vous essayez de la dessiner 2x2 pixels. Pour faire comme
Photoshop le fait pour chacun des 4 pixels du résultat 2x2, il faudrait faire la moyenne
de 1024x1024 pixels (soit 1 million de pixels) 4 fois. C&#39;est beaucoup trop de calcul à
faire pour continuer à avoir un affichage rapide.</p>
<p>Donc, ce que fait le GPU, c&#39;est qu&#39;il utilise un mipmap. Un mipmap est une
collection d&#39;images progressivement plus petites, chacune 1/4 de la taille de
la précédente. Le mipmap pour la texture 16x16 ci-dessus ressemblerait à ceci.</p>
<p><img class="webgl_center noinvertdark nobg" src="../resources/mipmap-low-res-enlarged.png" /></p>
<p>En général, chaque niveau inférieur n&#39;est qu&#39;une interpolation bilinéaire du
niveau précédent et c&#39;est ce que fait <code class="notranslate" translate="no">gl.generateMipmap</code>. Il regarde le plus
grand niveau et génère tous les niveaux plus petits pour vous. Bien sûr, vous
pouvez fournir vous-même les plus petits niveaux si vous le souhaitez.</p>
<p>Maintenant, si vous essayez de dessiner cette texture de 16x16 pixels en
2x2 pixels, WebGL peut sélectionner le mip 2x2 qui a déjà été calculé.</p>
<p>Vous pouvez choisir ce que fait WebGL en définissant le filtrage de texture pour
chaque texture. Il y a 6 modes</p>
<ul>
<li><code class="notranslate" translate="no">NEAREST</code> = choisissez 1 pixel du plus grand mip</li>
<li><code class="notranslate" translate="no">LINEAR</code> = choisissez 4 pixels du plus grand mip et mélangez-les</li>
<li><code class="notranslate" translate="no">NEAREST_MIPMAP_NEAREST</code> = choisissez le meilleur mip, puis choisissez un pixel de ce mip</li>
<li><code class="notranslate" translate="no">LINEAR_MIPMAP_NEAREST</code> = choisissez le meilleur mip, puis mélangez 4 pixels de ce mip</li>
<li><code class="notranslate" translate="no">NEAREST_MIPMAP_LINEAR</code> = choisissez les 2 meilleurs mips, choisissez 1 pixel de chacun, mélangez-les</li>
<li><code class="notranslate" translate="no">LINEAR_MIPMAP_LINEAR</code> = choisissez les 2 meilleurs mips. choisissez 4 pixels de chacun, mélangez-les</li>
</ul>
<p>Vous pouvez voir l&#39;importance des mips dans ces 2 exemples. Le premier montre
que si vous utilisez <code class="notranslate" translate="no">NEAREST</code> ou <code class="notranslate" translate="no">LINEAR</code> et ne choisissez que la plus grande
image, vous obtiendrez beaucoup de scintillements car au fur et à mesure que les
choses bougent, pour chaque pixel qu&#39;il dessine, il doit choisir un seul pixel
de la plus grande image. Ça change en fonction de la taille et de la position et
donc parfois il choisira un pixel, d&#39;autres fois un autre et donc il scintille.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-mips.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-mips.html" target="_blank">Cliquer ici pour ouvrir dans une nouvelle fenêtre</a>
</div>

</p>
<p>Remarquez à quel point ceux de gauche et du milieu scintillent tandis que ceux
de droite scintillent moins. Ceux de droite ont également des couleurs mélangées
puisqu&#39;ils utilisent les mips. Plus vous dessinez des textures éloignés, plus WebGL
va choisir des pixels. C&#39;est pourquoi, par exemple, celui en bas au
milieu, même s&#39;il utilise <code class="notranslate" translate="no">LINEAR</code> et le mélange 4 pixels, il scintille car ces
4 pixels proviennent de différents coins de l&#39;image 16x16 selon lequel 4 sont
choisis, vous obtiendrez une couleur différente. Celui en bas à droite reste
cependant d&#39;une couleur cohérente parce qu&#39;il utilise le 2ème au plus petit mip.</p>
<p>Le deuxième exemple montre des polygones qui pénètrent profondément dans
l&#39;écran.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-mips-tri-linear.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-mips-tri-linear.html" target="_blank">Cliquer ici pour ouvrir dans une nouvelle fenêtre</a>
</div>

</p>
<p>Les 6 faisceaux entrant dans l&#39;écran utilisent les 6 modes de filtrage
répertoriés au-dessus de. Le faisceau en haut à gauche utilise <code class="notranslate" translate="no">NEAREST</code> et vous
pouvez voir qu&#39;il est clairement très en bloc. Le milieu supérieur utilise
<code class="notranslate" translate="no">LINEAR</code> et ce n&#39;est pas beaucoup mieux. Le coin supérieur droit utilise
<code class="notranslate" translate="no">NEAREST_MIPMAP_NEAREST</code>. Cliquez sur l&#39;image pour passez à une texture où
chaque mip est d&#39;une couleur différente et vous pourrez facilement voir où il
choisit d&#39;utiliser un mip spécifique. Le bas à gauche utilise
<code class="notranslate" translate="no">LINEAR_MIPMAP_NEAREST</code> signifie qu&#39;il sélectionne le meilleur mip puis mélange
4 pixels dans ce mip. Vous pouvez toujours voir une zone claire où il bascule
d&#39;un mip au mip suivant. Le milieu inférieur utilise <code class="notranslate" translate="no">NEAREST_MIPMAP_LINEAR</code>
signifie qu&#39;il choisit les 2 meilleurs mips, puis il choisit un pixel de chacun et en les
mélangeant. Si vous regardez de près, vous pouvez voir comment c&#39;est encore
polyédrique, surtout dans le sens horizontal. Le coin inférieur droit utilise
<code class="notranslate" translate="no">LINEAR_MIPMAP_LINEAR</code> qui sélectionne les 2 meilleurs mips, en sélectionnant 4
pixels de chacun et mélange les 8 pixels.</p>
<p><img class="webgl_center noinvertdark nobg" src="../resources/different-colored-mips.png" /></p>
<div class="webgl_center">different colored mips</div>

<p>Vous vous demandez peut-être pourquoi choisiriez-vous autre chose que
<code class="notranslate" translate="no">LINEAR_MIPMAP_LINEAR</code> qui est sans doute le meilleur. Il y a beaucoup de
raisons. La première est que <code class="notranslate" translate="no">LINEAR_MIPMAP_LINEAR</code> est le plus lent. Lire 8
pixels est plus lent que lire 1 pixel. Sur le matériel GPU moderne,
c&#39;est probablement pas un problème si vous n&#39;utilisez qu&#39;une seule texture à la
fois, mais les jeux modernes peuvent utiliser 2 à 4 textures à la fois. 4 textures
* 8 pixels par texture = besoin de lire 32 pixels pour chaque pixel dessiné. ça
va être lent. Une autre raison est que si vous essayez d&#39;atteindre un certain
effet. Par exemple, si vous voulez que quelque chose ait un effet <em>rétro</em> pixélisé
peut-être que vous utiliserez <code class="notranslate" translate="no">NEAREST</code>. Les mips prennent
également de la mémoire. En fait ils prennent 33% de mémoire en plus. Cela peut
être beaucoup de mémoire, surtout pour un très grande texture comme vous
pourriez l&#39;utiliser sur un écran de titre d&#39;un jeu. Si vous n&#39;allez jamais
dessiner quelque chose de plus petit que le plus grand mip pourquoi gaspiller
de la mémoire pour ces mips. Au lieu de cela, utilisez simplement <code class="notranslate" translate="no">NEAREST</code> ou
<code class="notranslate" translate="no">LINEAR</code> car ils n&#39;utilisent que le premier mip.</p>
<p>Pour définir le filtrage, vous appelez <code class="notranslate" translate="no">gl.texParameter</code> comme ceci</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
</code></pre><p><code class="notranslate" translate="no">TEXTURE_MIN_FILTER</code> est le paramètre utilisé lorsque la taille que vous dessinez est inférieure au plus grand mip.
<code class="notranslate" translate="no">TEXTURE_MAG_FILTER</code> est le paramètre utilisé lorsque la taille que vous dessinez est supérieure au
plus grand mip. Pour <code class="notranslate" translate="no">TEXTURE_MAG_FILTER</code>, seuls <code class="notranslate" translate="no">NEAREST</code> et <code class="notranslate" translate="no">LINEAR</code> sont des paramètres valides.</p>
<p>Disons que nous voulions appliquer cette texture.</p>
<p><img class="webgl_center" src="../../resources/keyboard.jpg" /></p>
<p>C&#39;est ici.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-bad-npot.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-bad-npot.html" target="_blank">Cliquer ici pour ouvrir dans une nouvelle fenêtre</a>
</div>

</p>
<p>Pourquoi la texture du clavier n&#39;apparaît-elle pas ? C&#39;est parce que WebGL a une
sorte de restriction sévère sur les textures qui ne sont pas une puissance de 2
dans les deux dimensions. Les puissances de 2 sont 1, 2, 4, 8, 16, 32, 64, 128,
256, 512, 1024, 2048, etc. La texture &#39;F&#39; était de 256x256. 256 est une
puissance de 2. La texture du clavier est de 320x240. Ni l&#39;un ni l&#39;autre ne sont
un pouvoir de 2 donc essayer d&#39;afficher la texture échoue. Dans le shader
lorsque <code class="notranslate" translate="no">texture2D</code> est appelé et lorsque la texture référencé n&#39;est pas
configuré correctement WebGL utilisera la couleur (0, 0, 0, 1) qui est le noir.
Si vous ouvrez la console JavaScript ou Web Console, selon le navigateur, vous
pouvez voir des erreurs indiquant le problème comme celui-ci</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">WebGL: INVALID_OPERATION: generateMipmap: level 0 not power of 2
   or not all the same size
WebGL: drawArrays: texture bound to texture unit 0 is not renderable.
   It maybe non-power-of-2 and have incompatible texture filtering or
   is not &#39;texture complete&#39;.
</code></pre><p>Pour résoudre ce problème, nous devons définir le mode d&#39;habillage sur
<code class="notranslate" translate="no">CLAMP_TO_EDGE</code> et désactiver le mapping mip en définissant le filtrage à
<code class="notranslate" translate="no">LINEAR</code> ou <code class="notranslate" translate="no">NEAREST</code>.</p>
<p>Mettons à jour notre code de chargement d&#39;image pour gérer cela. Nous avons
d&#39;abord besoin d&#39;une fonction qui nous dira si une valeur est une puissance de
2.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function isPowerOf2(value) {
  return (value &amp; (value - 1)) == 0;
}
</code></pre><p>Je ne vais pas entrer dans les calculs binaires pour savoir pourquoi cela
fonctionne. Comme cela fonctionne, nous pouvons l&#39;utiliser comme suit.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// Asynchronously load an image
var image = new Image();
image.src = &quot;resources/keyboard.jpg&quot;;
image.addEventListener(&#39;load&#39;, function() {
  // Now that the image has loaded make copy it to the texture.
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, image);

*  // Check if the image is a power of 2 in both dimensions.
*  if (isPowerOf2(image.width) &amp;&amp; isPowerOf2(image.height)) {
*     // Yes, it&#39;s a power of 2. Generate mips.
     gl.generateMipmap(gl.TEXTURE_2D);
*  } else {
*     // No, it&#39;s not a power of 2. Turn off mips and set wrapping to clamp to edge
*     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
*     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
*     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
*  }
}
</code></pre><p>Et voilà</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-good-npot.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-good-npot.html" target="_blank">Cliquer ici pour ouvrir dans une nouvelle fenêtre</a>
</div>

</p>
<p>Ce ne sont pas seulement les textures en puissance de 2 qui ne seront pas rendue. WebGL
exige que les textures soient &quot;texture complète&quot;. &quot;texture complète&quot; signifie
que soit</p>
<ol>
<li><p>Vous avez défini le filtrage de sorte qu&#39;il n&#39;utilise que le premier niveau
mip, ce qui signifie en définissant <code class="notranslate" translate="no">TEXTURE_MIN_FILTER</code> sur <code class="notranslate" translate="no">LINEAR</code> ou
<code class="notranslate" translate="no">NEAREST</code>.</p>
</li>
<li><p>Si vous utilisez des mips, ils doivent être de la bonne taille et vous devez
TOUS les fournir. jusqu&#39;à la taille 1x1.</p>
<p>La façon la plus simple de le faire est d&#39;appeler <code class="notranslate" translate="no">gl.generateMipmap</code>. Sinon, si
vous fournissez vos propres mips, vous devez les fournir tous.</p>
</li>
<li><p>Si les textures ne sont pas une puissance de 2 dans les deux dimensions,
alors comme mentionné ci-dessus vous devez définir <code class="notranslate" translate="no">TEXTURE_MIN_FILTER</code> sur
<code class="notranslate" translate="no">LINEAR</code> ou <code class="notranslate" translate="no">NEAREST</code> <strong>et</strong> vous devez définissez <code class="notranslate" translate="no">TEXTURE_WRAP_S</code> et
<code class="notranslate" translate="no">TEXTURE_WRAP_T</code> sur <code class="notranslate" translate="no">CLAMP_TO_EDGE</code>.</p>
</li>
</ol>
<p>Si l&#39;un des points ci-dessous n&#39;est pas remplis, lorsque vous récupérerez dans la valeur de la
texture dans votre shader 0,0,0,1.</p>
<p>Une question courante est &quot;Comment appliquer une image différente à chaque face
d&#39;un cube ?&quot;. Par exemple disons que nous avait ces 6 images.</p>
<div class="webgl_table_div_center">
<table class="webgl_table_center">
<tr><td><img src="../resources/noodles-01.jpg" /></td><td><img src="../resources/noodles-02.jpg" /></td></tr>
<tr><td><img src="../resources/noodles-03.jpg" /></td><td><img src="../resources/noodles-04.jpg" /></td></tr>
<tr><td><img src="../resources/noodles-05.jpg" /></td><td><img src="../resources/noodles-06.jpg" /></td></tr>
</table>
</div>

<p>3 réponses me viennent à l&#39;esprit</p>
<p>1) créer un shader compliqué qui référence 6 textures et transmettre des
informations supplémentaires par sommet dans le vertex shader qui est passé au
fragment shader pour décider quelle texture utiliser. NE FAITES PAS CELA ! Une
petite réflexion montrerait clairement que vous finiriez par devoir écrire des
tonnes de shaders différents si vous vouliez faire la même chose pour
différentes formes avec plus de côtés, etc.</p>
<p>2) dessiner 6 plans au lieu d&#39;un cube. C&#39;est une solution commune. Ce n&#39;est pas
mal mais ça marche aussi vraiment pour les petites formes comme un cube. Si vous
aviez une sphère avec 1000 quads et que vous vouliez mettre une texture
différente sur chaque quad il faudrait dessiner 1000 plans et ce serait lent.</p>
<p>3) La, oserais-je dire, <em>la meilleure solution</em> est de mettre toutes les images
dans 1 texture et d&#39;utiliser les coordonnées de texture pour mapper une partie
différente de la texture sur chaque face du cube. C&#39;est à peu près la technique
que toutes les applications hautes performances (comprendre <em>jeux</em>) utilisent. Ainsi, par
exemple, nous mettrions toutes les images dans une texture éventuellement comme
ça</p>
<p><img class="webgl_center" src="../../resources/noodles.jpg" /></p>
<p>Et puis utilisez un ensemble différent de coordonnées de texture pour chaque
face du cube.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">    // select the top left image
    0   , 0  ,
    0   , 0.5,
    0.25, 0  ,
    0   , 0.5,
    0.25, 0.5,
    0.25, 0  ,
    // select the top middle image
    0.25, 0  ,
    0.5 , 0  ,
    0.25, 0.5,
    0.25, 0.5,
    0.5 , 0  ,
    0.5 , 0.5,
    // select to top right image
    0.5 , 0  ,
    0.5 , 0.5,
    0.75, 0  ,
    0.5 , 0.5,
    0.75, 0.5,
    0.75, 0  ,
    // select the bottom left image
    0   , 0.5,
    0.25, 0.5,
    0   , 1  ,
    0   , 1  ,
    0.25, 0.5,
    0.25, 1  ,
    // select the bottom middle image
    0.25, 0.5,
    0.25, 1  ,
    0.5 , 0.5,
    0.25, 1  ,
    0.5 , 1  ,
    0.5 , 0.5,
    // select the bottom right image
    0.5 , 0.5,
    0.75, 0.5,
    0.5 , 1  ,
    0.5 , 1  ,
    0.75, 0.5,
    0.75, 1  ,
</code></pre><p>Et nous obtenons</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-texture-atlas.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-texture-atlas.html" target="_blank">Cliquer ici pour ouvrir dans une nouvelle fenêtre</a>
</div>

</p>
<p>Ce style d&#39;application utilisant plusieurs images à l&#39;aide d&#39;une seule texture est
souvent appelé un <em>atlas de textures</em>. C&#39;est mieux parce qu&#39;il n&#39;y a qu&#39;une
seule texture à charger, la shader reste simple car il n&#39;y a qu&#39;à référencer 1
texture, et il ne nécessite qu&#39;1 rafraichissement pour dessiner la forme au lieu d&#39;
1 rafraichissement par texture comme cela pourrait être le cas si nous le
divisions en plans.</p>
<p>A few other very important things you might want to know about textures.
One is <a href="webgl-texture-units.html">how texture unit state works</a>.
One is <a href="webgl-2-textures.html">how to use 2 or more textures at once</a>. Another
is <a href="webgl-cors-permission.html">how to use images from other domains</a>. And
one more is <a href="webgl-3d-perspective-correct-texturemapping.html">perspective correct texture mapping</a> which in some ways
is trivia but it&#39;s good to know.
Quelques autres choses très importantes que vous voudriez peut-être savoir sur
les textures. L&#39;une est [comment fonctionne l&#39;état de l&#39;unité de texture]
(webgl-texture-units.html). Une autre est [comment utiliser 2 textures ou plus à la
fois] (webgl-2-textures.html). Encore une autre est [comment utiliser des images
d&#39;autres domaines] (webgl-cors-permission.html). Et une dernière serait la [perspective
correct des mapping de texture] (webgl-3d-perspective-correct-texturemapping.html) qui,
à certains égards est banal mais c&#39;est bon à savoir.</p>
<p>Next up <a href="webgl-data-textures.html">supplying data to a texture from JavaScript</a>.
Or, you could also check out <a href="webgl-less-code-more-fun.html">simplifying WebGL with less code more fun</a>.
La suite [fournir des données à une texture à partir de JavaScript]
(webgl-data-textures.html). Ou, vous pouvez également consulter <a href="webgl-less-code-more-fun.html">simplifier
WebGL avec moins de code et de manière plus amusante</a>.</p>
<div class="webgl_bottombar">
<h3>UVs vs. Coordonées de Texture</h3>
<p>Les coordonnées de texture sont souvent raccourcies en texture coords,
texcoords ou UV (prononcé Yu-Vi). Je n'ai aucune idée d'où vient le terme UV,
sauf que les positions des sommets utilisent souvent <code class="notranslate" translate="no">x, y, z, w</code>
donc pour les coordonnées de texture, ils ont décidé d'utiliser <code class="notranslate" translate="no">s, t, u,
v</code> pour essayer de préciser à quel type des 2 types vous faites référence.
Étant donné que les deux premiers paramètres s'appellent ST, si
vous regardez aux paramètres de wrapping de texture, ils sont appelés
<code class="notranslate" translate="no">TEXTURE_WRAP_S</code> et <code class="notranslate" translate="no">TEXTURE_WRAP_T</code> mais pour une raison
quelconque depuis que je travaille dans les graphismes, les gens les ont appelés
UV.
</p>
<p>Alors maintenant, vous savez si quelqu'un parle d'UV, il parle de coordonnées de
texture.</p>
</div>




    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-3d-textures.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-3d-textures.html" selected>Français</a>
    <option value="/webgl/lessons/ja/webgl-3d-textures.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-3d-textures.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-3d-textures.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-3d-textures.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-3d-textures.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-3d-textures.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Les bases</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-fundamentals.html">WebGL - Les bases</a></li>
<li><a href="/webgl/lessons/fr/webgl-how-it-works.html">WebGL - Comment ça marche</a></li>
<li><a href="/webgl/lessons/fr/webgl-shaders-and-glsl.html">WebGL - Shaders et GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL State Diagram</a></li>
        </ul>
  <li>Traitement d'image</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-image-processing.html">Image Processing</a></li>
<li><a href="/webgl/lessons/fr/webgl-image-processing-continued.html">Image Processing Continued</a></li>
        </ul>
  <li>2D : translation, rotation, échelle, matrices</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-2d-translation.html">WebGL 2D - Translation</a></li>
<li><a href="/webgl/lessons/fr/webgl-2d-rotation.html">WebGL 2D - Rotation</a></li>
<li><a href="/webgl/lessons/fr/webgl-2d-scale.html">WebGL 2D - Echelle</a></li>
<li><a href="/webgl/lessons/fr/webgl-2d-matrices.html">WebGL 2D - Matrices</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-3d-orthographic.html">WebGL 3D - Projection orthographique</a></li>
<li><a href="/webgl/lessons/fr/webgl-3d-perspective.html">WebGL 3D - La perspective</a></li>
<li><a href="/webgl/lessons/fr/webgl-3d-camera.html">WebGL 3D - Les caméras</a></li>
        </ul>
  <li>Lumières</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-3d-lighting-directional.html">WebGL 3D - Lumière directionnelle</a></li>
<li><a href="/webgl/lessons/fr/webgl-3d-lighting-point.html">WebGL 3D - Lumière-point</a></li>
<li><a href="/webgl/lessons/fr/webgl-3d-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Structure et Organisation</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/fr/webgl-drawing-multiple-things.html">Dessiner plusieurs choses</a></li>
<li><a href="/webgl/lessons/fr/webgl-scene-graph.html">WebGL - Graphes de scène</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-3d-geometry-lathe.html">Geometry - Lathe</a></li>
<li><a href="/webgl/lessons/fr/webgl-load-obj.html">Loading .obj files</a></li>
<li><a href="/webgl/lessons/fr/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>Divers</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-3d-textures.html">Textures</a></li>
<li><a href="/webgl/lessons/fr/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/fr/webgl-2-textures.html">Using 2 or More Textures</a></li>
<li><a href="/webgl/lessons/fr/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/fr/webgl-3d-perspective-correct-texturemapping.html">Perspective Correct Texture Mapping</a></li>
<li><a href="/webgl/lessons/fr/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>Rendering To A Texture</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-render-to-texture.html">Render to Texture</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/fr/webgl-2d-matrix-stack.html">2D - Matrix Stack</a></li>
<li><a href="/webgl/lessons/fr/webgl-sprites.html">Sprites</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/fr/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/fr/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/fr/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/fr/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/fr/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Texte</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-text-html.html">Text - HTML</a></li>
<li><a href="/webgl/lessons/fr/webgl-text-canvas2d.html">Text - Canvas 2D</a></li>
<li><a href="/webgl/lessons/fr/webgl-text-texture.html">Text - Using a Texture</a></li>
<li><a href="/webgl/lessons/fr/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
  <li>Divers</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-ramp-textures.html">Ramp Textures (Toon Shading)</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/fr/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/fr/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/fr/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/fr/webgl-instanced-drawing.html">Instanced Drawing</a></li>
        </ul>
  <li>Divers</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-setup-and-installation.html">Setup And Installation</a></li>
<li><a href="/webgl/lessons/fr/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/fr/webgl-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgl/lessons/fr/webgl-animation.html">Animation</a></li>
<li><a href="/webgl/lessons/fr/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/fr/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/fr/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/fr/webgl-and-alpha.html">WebGL and Alpha</a></li>
<li><a href="/webgl/lessons/fr/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/fr/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/fr/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/fr/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/fr/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/fr/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/fr/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/fr/webgl-tips.html#html-background">Use WebGL as Background in HTML</a></li>
<li><a href="/webgl/lessons/fr/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/fr/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/fr/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/fr/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/fr/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/fr/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Aide pour la doc de l'API</a></li>
  <li><a href="https://twgljs.org">TWGL, une librairie de base pour WebGL</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>Une question ? <a href="https://stackoverflow.com/questions/tagged/webgl">Demander sur stackoverflow</a>.</div>
        <div>Un problème ? <a href="https://github.com/vinci-mz/webgl-fundamentals/issues">Signaler sur github</a>.</div>

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL Textures';
            var disqus_title = 'WebGL Textures';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
      return;
  }

  function addScript(src, type, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    script.type = type || 'javascript';
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  // can't do this because it would eat contexts
  //addScript('//gpustats.org/stats.js', 'module');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>



