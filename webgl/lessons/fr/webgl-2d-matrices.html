<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/fr/webgl-2d-matrices.md. Do not edited directly -->
<!--
Copyright 2021 GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Comment les matrices sont utilisées en graphisme">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-2d-matrices_fr.jpg">

<meta property="og:title" content="WebGL 2D - Matrices">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-2d-matrices_fr.jpg">
<meta property="og:description" content="Comment les matrices sont utilisées en graphisme">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/fr/webgl-2d-matrices.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGL 2D - Matrices">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/fr/webgl-2d-matrices.html">
<meta name="twitter:description" content="Comment les matrices sont utilisées en graphisme">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-2d-matrices_fr.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/fr/webgl-2d-matrices.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-2d-matrices_fr.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/fr/webgl-2d-matrices.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/fr/webgl-2d-matrices.html",
      "inLanguage":"fr",
      "name":"WebGL 2D - Matrices",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/fr/webgl-2d-matrices.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL 2D - Matrices</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-2d-matrices.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-2d-matrices.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-2d-matrices.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-2d-matrices.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-2d-matrices.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-2d-matrices.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-2d-matrices.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-2d-matrices.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-2d-matrices.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-2d-matrices.html" selected>Français</a>
    <option value="/webgl/lessons/ja/webgl-2d-matrices.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-2d-matrices.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-2d-matrices.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-2d-matrices.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-2d-matrices.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-2d-matrices.html" >简体中文</a>
</select>


    <a href="#toc">Table des Matières</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/fr/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL 2D - Matrices</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Cet article est la suite d&#39;une série de posts à propos de WebGL. Le premier <a href="webgl-fundamentals.html">évoquait les bases</a> et le précédent parlait de <a href="webgl-2d-scale.html">changement d&#39;échelle</a> de géométries.</p>
<p>Dans les 3 derniers posts on a parlé des <a href="webgl-2d-translation.html">translations</a>, <a href="webgl-2d-rotation.html">rotations</a> et <a href="webgl-2d-scale.html">changement d&#39;échelle</a>. Translation, rotation et changement d&#39;échelle sont les 3 types de &#39;transformation&#39;. Chacune de ces transformations demande des changements dans le shader de vertex et on a vu que le résultat dépend de l&#39;ordre dans lequel elles sont appliquées : certaines sont non-commutatives. Dans le <a href="webgl-2d-scale.html">précédent exemple</a> on a changé l&#39;échelle, puis tourné et déplacé. Dans un autre ordre on aurait eu un résultat différent.
<!--more-->
Par exemple, voici la suite de transformations suivantes : échelle de (2,1), rotation de 30 degrés et translation de (100, 0) :</p>
<p><img src="../../resources/f-scale-rotation-translation.svg" class="webgl_center" width="400" /></p>
<p>Et voici un déplacement de (100,0) suivi d&#39;une rotation de 30 degrés et un changement d&#39;échelle de (2,1) :</p>
<p><img src="../../resources/f-translation-rotation-scale.svg" class="webgl_center" width="400" /></p>
<p>Les résultats sont complètement différents. Pire, si on veut aboutir au second exemple il nous faut écrire un autre shader qui applique les transformations dans l&#39;ordre qu&#39;on souhaite.</p>
<p>Eh bien, des personnes plus futées que moi ont réalisé qu&#39;on peut faire la même chose avec des matrices. Pour la 2D on utilise une matrice carrée d&#39;ordre 3 (3x3). Une matrice 3x3 est comme une grille de 9 cases :</p>
<p><link href="../resources/webgl-2d-matrices.css" rel="stylesheet"></p>
<div class="glocal-center"><table class="glocal-center-content glocal-mat"><tr><td>1.0</td><td>2.0</td><td>3.0</td></tr><tr><td>4.0</td><td>5.0</td><td>6.0</td></tr><tr><td>7.0</td><td>8.0</td><td>9.0</td></tr></table></div>

<p>Pour trouver le résultat d&#39;une transformation matricielle on dispose les composantes du vecteur à la verticale devant la matrice et pour chaque colonne, on multiplie les valeurs des composantes à leur niveau. Comme en 2D on a deux composantes x et y, et que les colonnes ont 3 valeurs, on ajoute une composante à la position, de valeur 1.</p>
<p>Dans ce cas notre résultat serait :</p>
<div class="glocal-center"><table class="glocal-center-content">
<col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col class="glocal-b"/>
<tr><td class="glocal-right">nouveauX&nbsp;=&nbsp;</td><td>x&nbsp;*&nbsp;</td><td class="glocal-border">1.0</td><td class="glocal-left">&nbsp;+</td><td class="glocal-right">newY&nbsp;=&nbsp;</td><td>x&nbsp;*&nbsp;</td><td class="glocal-border">2.0</td><td class="glocal-left">&nbsp;+</td><td class="glocal-right">extra&nbsp;=&nbsp;</td><td>x&nbsp;*&nbsp;</td><td class="glocal-border">3.0</td><td>&nbsp;+</td></tr>
<tr><td></td><td>y&nbsp;*&nbsp;</td><td class="glocal-border">4.0</td><td class="glocal-left">&nbsp;+</td><td></td><td>y&nbsp;*&nbsp;</td><td class="glocal-border">5.0</td><td class="glocal-left">&nbsp;+&nbsp;</td><td></td><td>y&nbsp;*&nbsp;</td><td class="glocal-border">6.0</td><td>&nbsp;+</td></tr>
<tr><td></td><td>1&nbsp;*&nbsp;</td><td>7.0</td><td>&nbsp;</td><td></td><td>1&nbsp;*&nbsp;</td><td>8.0</td><td>&nbsp;&nbsp;</td><td></td><td>1&nbsp;*&nbsp;</td><td>9.0</td><td>&nbsp;</td></tr></table></div>

<p>Vous êtes probablement en train de fixer l&#39;écran en vous disant &quot;Non mais allô !&quot;. Hé bien, imaginons qu&#39;on a une translation. Elle peut être décomposée par les valeurs tx et ty. Faisons une matrice pour ça :</p>
<div class="glocal-center"><table class="glocal-center-content glocal-mat"><tr><td>1.0</td><td>0.0</td><td>0.0</td></tr><tr><td>0.0</td><td>1.0</td><td>0.0</td></tr><tr><td>tx</td><td>ty</td><td>1.0</td></tr></table></div>

<p>Et maintenant vérifiez :</p>
<div class="glocal-center"><table class="glocal-center-content">
<col/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/>
<tr><td>nouveauX&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">1.0</td><td class="glocal-left">&nbsp;+</td><td class="glocal-right">nouveauY&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td class="glocal-left">&nbsp;+</td><td class="glocal-right">extra&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td>&nbsp;+</td></tr><tr><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td class="glocal-left">&nbsp;+</td><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">1.0</td><td class="glocal-left">&nbsp;+&nbsp;</td><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td>&nbsp;+</td></tr>
<tr><td></td><td>1</td><td>&nbsp;*&nbsp;</td><td>tx</td><td>&nbsp;</td><td></td><td>1</td><td>&nbsp;*&nbsp;</td><td>ty</td><td>&nbsp;&nbsp;</td><td></td><td>1</td><td>&nbsp;*&nbsp;</td><td>1.0</td><td>&nbsp;</td></tr></table></div>

<p>Si vous avez quelques souvenirs d&#39;algèbre, on peut supprimer les termes multipliés par zéro. Multiplier par 1 ne change rien au terme initial alors simplifions pour voir ce qui se passe :</p>
<div class="glocal-center"><table class="glocal-center-content">
<col/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/>
<tr><td>nouveauX&nbsp;=&nbsp;</td><td>x</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk glocal-border">1.0</td><td class="glocal-left">&nbsp;+</td><td class="glocal-right">nouveauY&nbsp;=&nbsp;</td><td class="glocal-blk">x</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk glocal-border">0.0</td><td class="glocal-blk glocal-left">&nbsp;+</td><td class="glocal-right">extra&nbsp;=&nbsp;</td><td class="glocal-blk">x</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk glocal-border">0.0</td><td class="glocal-blk">&nbsp;+</td></tr>
<tr><td></td><td class="glocal-blk">y</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk glocal-border">0.0</td><td class="glocal-blk glocal-left">&nbsp;+</td><td></td><td>y</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk glocal-border">1.0</td><td class="glocal-left">&nbsp;+&nbsp;</td><td></td><td class="glocal-blk">y</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk glocal-border">0.0</td><td class="glocal-blk">&nbsp;+</td></tr>
<tr><td></td><td class="glocal-blk">1</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td>tx</td><td>&nbsp;</td><td></td><td class="glocal-blk">1</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td>ty</td><td>&nbsp;&nbsp;</td><td></td><td>1</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk">1.0</td><td>&nbsp;</td></tr></table></div>

<p>c&#39;est-à-dire :</p>
<div class="webgl_center"><pre class="webgl_math">
nouveauX = x + tx;
nouveauY = y + ty;
</pre></div>

<p>Et l&#39;extra on s&#39;en fiche. Etonnament, ça revient au <a href="webgl-2d-translation.html">code de notre exemple sur les translations</a>.</p>
<p>Passons aux rotations. Comme on a vu dans le post sur les rotations on a juste besoin du sinus et du cosinus de l&#39;angle de rotation, donc</p>
<div class="webgl_center"><pre class="webgl_math">
s = Math.sin(angleEnRadian);
c = Math.cos(angleEnRadian);
</pre></div>

<p>Et on écrit une matrice comme celle-ci</p>
<div class="glocal-center"><table class="glocal-center-content glocal-mat"><tr><td>c</td><td>-s</td><td>0.0</td></tr><tr><td>s</td><td>c</td><td>0.0</td></tr><tr><td>0.0</td><td>0.0</td><td>1.0</td></tr></table></div>

<p>On applique la matrice :</p>
<div class="glocal-center"><table class="glocal-center-content">
<col/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/>
<tr><td>nouveauX&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">c</td><td class="glocal-left">&nbsp;+</td><td class="glocal-right">nouveauY&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">-s</td><td class="glocal-left">&nbsp;+</td><td class="glocal-right">extra&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td>&nbsp;+</td></tr>
<tr><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">s</td><td class="glocal-left">&nbsp;+</td><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">c</td><td class="glocal-left">&nbsp;+&nbsp;</td><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td>&nbsp;+</td></tr>
<tr><td></td><td>1</td><td>&nbsp;*&nbsp;</td><td>0.0</td><td>&nbsp;</td><td></td><td>1</td><td>&nbsp;*&nbsp;</td><td>0.0</td><td>&nbsp;&nbsp;</td><td></td><td>1</td><td>&nbsp;*&nbsp;</td><td>1.0</td><td>&nbsp;</td></tr></table></div>

<p>En supprimant ce qui est multiplié par zéro et en gardant ce qui est multiplié par 1 :</p>
<div class="glocal-center"><table class="glocal-center-content">
<col/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/>
<tr><td>nouveauX&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">c</td><td class="glocal-left">&nbsp;+</td><td class="glocal-right">nouveauY&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">-s</td><td class="glocal-left">&nbsp;+</td><td class="glocal-right">extra&nbsp;=&nbsp;</td><td class="glocal-blk">x</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk glocal-border">0.0</td><td class="glocal-blk">&nbsp;+</td></tr>
<tr><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">s</td><td class="glocal-left glocal-blk">&nbsp;+</td><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">c</td><td class="glocal-left glocal-blk">&nbsp;+&nbsp;</td><td></td><td class="glocal-blk">y</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk glocal-border">0.0</td><td class="glocal-blk">&nbsp;+</td></tr>
<tr><td></td><td class="glocal-blk">1</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk">0.0</td><td>&nbsp;</td><td></td><td class="glocal-blk">1</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk">0.0</td><td>&nbsp;&nbsp;</td><td></td><td>1</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk">1.0</td><td>&nbsp;</td></tr></table></div>

<p>Simplifions :</p>
<pre class="webgl_center">
nouveauX = x *  c + y * s;
nouveauY = x * -s + y * c;
</pre>

<p>C&#39;est exactement <a href="webgl-2d-rotation.html">ce qu&#39;on a vu dans les rotations</a>.</p>
<p>Enfin l&#39;échelle. Appelons nos deux facteurs d&#39;échelle sx et sy et construisons la matrice :</p>
<div class="glocal-center"><table class="glocal-center-content glocal-mat"><tr><td>sx</td><td>0.0</td><td>0.0</td></tr><tr><td>0.0</td><td>sy</td><td>0.0</td></tr><tr><td>0.0</td><td>0.0</td><td>1.0</td></tr></table></div>

<p>On l&#39;applique :</p>
<div class="glocal-center"><table class="glocal-center-content">
<col/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/>
<tr><td>nouveauX&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">sx</td><td class="glocal-left">&nbsp;+</td><td class="glocal-right">nouveauY&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td class="glocal-left">&nbsp;+</td><td class="glocal-right">extra&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td>&nbsp;+</td></tr>
<tr><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td class="glocal-left">&nbsp;+</td><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">sy</td><td class="glocal-left">&nbsp;+&nbsp;</td><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td>&nbsp;+</td></tr>
<tr><td></td><td>1</td><td>&nbsp;*&nbsp;</td><td>0.0</td><td>&nbsp;</td><td></td><td>1</td><td>&nbsp;*&nbsp;</td><td>0.0</td><td>&nbsp;&nbsp;</td><td></td><td>1</td><td>&nbsp;*&nbsp;</td><td>1.0</td><td>&nbsp;</td></tr></table></div>

<p>Ce qui est en fait</p>
<div class="glocal-center"><table class="glocal-center-content">
<col/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/>
<tr><td>nouveauX&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">sx</td><td class="glocal-left glocal-blk">&nbsp;+</td><td class="glocal-right">nouveauY&nbsp;=&nbsp;</td><td class="glocal-blk">x</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk glocal-border">0.0</td><td class="glocal-left glocal-blk">&nbsp;+</td><td class="glocal-right">extra&nbsp;=&nbsp;</td><td class="glocal-blk">x</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk glocal-border">0.0</td><td class="glocal-blk">&nbsp;+</td></tr>
<tr><td></td><td class="glocal-blk">y</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk glocal-border">0.0</td><td class="glocal-left glocal-blk">&nbsp;+</td><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">sy</td><td class="glocal-left glocal-blk">&nbsp;+&nbsp;</td><td></td><td class="glocal-blk">y</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk glocal-border">0.0</td><td class="glocal-blk">&nbsp;+</td></tr>
<tr><td></td><td class="glocal-blk">1</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk">0.0</td><td>&nbsp;</td><td></td><td class="glocal-blk">1</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk">0.0</td><td>&nbsp;&nbsp;</td><td></td><td>1</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk">1.0</td><td>&nbsp;</td></tr></table></div>

<p>Ce qui revient à</p>
<pre class="webgl_center">
nouveauX = x * sx;
nouveauY = y * sy;
</pre>

<p>Et c&#39;est pareil que ce qu&#39;on avait dans <a href="webgl-2d-scale.html">l&#39;article sur le changement d&#39;échelle</a> !</p>
<p>Maintenant je parie que vous fixez toujours l&#39;écran en pensant &quot;Alors quoi ?! C&#39;est quoi le truc ?&quot; Ca a l&#39;air d&#39;un beaucoup plus gros boulot pour faire ce qu&#39;on faisait déjà.</p>
<p>C&#39;est là que la magie arrive. Il se trouve qu&#39;on peut multiplier des matrices ensemble. Et qu&#39;on peut appliquer toutes les transformations d&#39;un coup. Imaginons qu&#39;on a une fonction, <code class="notranslate" translate="no">multiplierMatrices</code>, qui prend deux matrices, les multiplie et retourne la matrice finale.</p>
<p>Pour rendre les choses plus claires faisons des fonctions pour fabriquer des matrices pour le déplacement, la rotation et l&#39;échelle :</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function deplacer(tx, ty) {
  return [
    1, 0, 0,
    0, 1, 0,
    tx, ty, 1
  ];
}

function tourner(angleEnRadians) {
  var c = Math.cos(angleEnRadians);
  var s = Math.sin(angleEnRadians);
  return [
    c,-s, 0,
    s, c, 0,
    0, 0, 1
  ];
}

function changerEchelle(sx, sy) {
  return [
    sx, 0, 0,
    0, sy, 0,
    0, 0, 1
  ];
}
</code></pre><p>Maintenant changeons le shader. Le shader actuel est :</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">&lt;script id=&quot;shader-de-vertex-2d&quot; type=&quot;x-shader/x-vertex&quot;&gt;
attribute vec2 a_position;

uniform vec2 u_resolution;
uniform vec2 u_deplacement;
uniform vec2 u_rotation;
uniform vec2 u_echelle;

void main() {
  // Change l&#39;échelle
  vec2 positionEchelle = a_position * u_echelle;

  // Tourne
  vec2 positionTournee = vec2(
     positionEchelle.x * u_rotation.y + positionEchelle.y * u_rotation.x,
     positionEchelle.y * u_rotation.y - positionEchelle.x * u_rotation.x);

  // Déplace
  vec2 position = positionTournee + u_deplacement;
  ...
</code></pre><p>Notre nouveau shader va être beaucoup plus simple</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">&lt;script id=&quot;shader-de-vertex-2d&quot; type=&quot;x-shader/x-vertex&quot;&gt;
attribute vec2 a_position;

uniform vec2 u_resolution;
uniform mat3 u_matrice;

void main() {
  // Multiplie la position par la matrice
  vec2 position = (u_matrice * vec3(a_position, 1)).xy;
  ...
</code></pre><p>Et voilà comment on l&#39;utilise :</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  // Rend la scène
  function rendreScene() {
    // Efface le canvas
    gl.clear(gl.COLOR_BUFFER_BIT);

    // Calcule les matrices
    var matriceDeplacement = deplacer(deplacement[0], deplacement[1]);
    var matriceRotation = tourne(angleEnRadians);
    var matriceEchelle = changerEchelle(echelle[0], echelle[1]);

    // Multiplie les matrices
    var matrice = multiplierMatrices(matriceEchelle, matriceRotation);
    matrice = multiplierMatrices(matrice, matriceDeplacement);

    // Transmet la valeur au programme
    gl.uniformMatrix3fv(emplacementMatrice, false, matrice);

    // Dessine le rectangle
    gl.drawArrays(gl.TRIANGLES, 0, 18);
  }
</code></pre><p>Voilà un exemple avec le nouveau code. Les sliders sont les mêmes, déplacement, rotation, échelle. Mais la façon dont le shader les utilise est beaucoup plus simple.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-geometry-matrix-transform.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-geometry-matrix-transform.html" target="_blank">Cliquer ici pour ouvrir dans une nouvelle fenêtre</a>
</div>

</p>
<p>Mais, vous vous demandez peut-être encore, alors quoi ? Ca n&#39;a pas l&#39;air plus pratique. Mais maintenant si on veut changer l&#39;ordre des transformations on n&#39;a pas besoin d&#39;écrire un nouveau shader. On a juste à changer l&#39;ordre de nos fonctions. </p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">    ...
    // Multiplie les matrices
    var matrice = multiplierMatrices(matriceDeplacement, matriceRotation);
    matrice = multiplierMatrices(matrice, matriceEchelle);
    ...
</code></pre><p>Voilà cette version :</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-geometry-matrix-transform-trs.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-geometry-matrix-transform-trs.html" target="_blank">Cliquer ici pour ouvrir dans une nouvelle fenêtre</a>
</div>

</p>
<p>Pouvoir multiplier par des matrices comme ça est particulièrement important dans les hiérarchies d&#39;animation comme des bras sur un corps, des lunes autour d&#39;une planète autour d&#39;un soleil, ou les branches d&#39;un arbre. Pour un exemple simple avec une animation hiérarchique dessinons notre &quot;F&quot; cinq fois mais chaque fois, partons de la matrice du F précédent. </p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  // Rend la scène
  function rendreScene() {
    // Efface le canvas
    gl.clear(gl.COLOR_BUFFER_BIT);

    // Calcule les matrices
    var matriceDeplacement = deplacer(deplacement[0], deplacement[1]);
    var matriceRotation = tourner(angleEnRadians);
    var matriceEchelle = changerEchelle(echelle[0], echelle[1]);

    // initialise la matrice à l&#39;identité
    var matrice = matriceIdentite();

    for (var i = 0; i &lt; 5; ++i) {
      // Multiplie les matrices
      matrice = multiplierMatrices(matrice, matriceDeplacement);
      matrice = multiplierMatrices(matrice, matriceRotation);
      matrice = multiplierMatrices(matrice, matriceEchelle);

      // Transmet la valeur au programme
      gl.uniformMatrix3fv(emplacementMatrice, false, matrice);

      // Dessine la géométrie
      gl.drawArrays(gl.TRIANGLES, 0, 18);
    }
  }
</code></pre><p>Pour faire ça on a eu besoin de la fonction <code class="notranslate" translate="no">matriceIdentite</code>, qui retourne une matrice identité. Une matrice identité est une matrice qui représente &quot;1.0&quot;, c&#39;est-à-dire qu&#39;en la multipliant, il ne se passe rien. Tout comme</p>
<div class="webgl_center">X * 1 = X</div>

<p>de même</p>
<div class="webgl_center">matriceX * identite = matriceX</div>

<p>Voilà le code pour faire une matrice identité :</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function matriceIdentite() {
  return [
    1, 0, 0,
    0, 1, 0,
    0, 0, 1
  ];
}
</code></pre><p>Et voilà nos cinq F.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-geometry-matrix-transform-hierarchical.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-geometry-matrix-transform-hierarchical.html" target="_blank">Cliquer ici pour ouvrir dans une nouvelle fenêtre</a>
</div>

</p>
<p>Voyons un autre exemple. Jusque là dans tous les exemples notre &quot;F&quot; tourne autour de son coin gauche. C&#39;est parce que les opérations qu&#39;on a utilisées faisaient des rotations autour de l&#39;origine et que ce coin gauche, c&#39;est l&#39;origine (0,0).</p>
<p>Mais maintenant, parce qu&#39;on sait faire des opérations matricielles on peut choisir un ordre d&#39;application des transformations et déplacer l&#39;origine avant le reste des opérations :</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">    // créé une matrice qui va déplacer l&#39;origine du F vers son centre :
    var matriceDeplacementOrigine = deplacer(-50, -75);
    ...

    // Multiply the matrices.
    var matrice = multiplierMatrices(matriceDeplacementOrigine, matriceEchelle);
    matrice = multiplierMatrices(matrice, matriceRotation);
    matrice = multiplierMatrices(matrice, matriceDeplacement);
</code></pre><p>Et voilà. Le F tourne et change d&#39;échelle depuis son centre.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-geometry-matrix-transform-center-f.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-geometry-matrix-transform-center-f.html" target="_blank">Cliquer ici pour ouvrir dans une nouvelle fenêtre</a>
</div>

</p>
<p>Avec cette technique vous pouvez tourner et changer d&#39;échelle depuis n&#39;importe quel point. Maintenant vous savez comment Photoshop ou Flash vous laissent changer un centre de rotation.</p>
<p>Allons plus loin dans cette folie. Si on revient au premier article <a href="webgl-fundamentals.html">WebGL - Les bases</a> vous vous rappelez peut-être qu&#39;on avait un code dans nos shaders pour convertir des coordonnées d&#39;écran aux coordonnées d&#39;espace de projection (clipspace). Ca ressemblait à ça :</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  ...
  // convertit le rectangle de l&#39;espace des pixels à 0.0 &gt; 1.0
  vec2 zeroAUn = position / u_resolution;

  // convertit de 0-&gt;1 à 0-&gt;2
  vec2 zeroADeux = zeroAUn * 2.0;

  // convertit de 0-&gt;2 à -1-&gt;+1 (clipspace)
  vec2 clipSpace = zeroADeux - 1.0;

  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
</code></pre><p>Si vous regardez chaque étape, en fait, &quot;convertit le rectangle de l&#39;espace des pixels à 0.0 &gt; 1.0&quot;, est un changement d&#39;échelle. Pareil pour la seconde étape. La troisième est un déplacement et la dernière un changement d&#39;échelle par -1. On peut du coup faire ceci dans une matrice qu&#39;on envoie au shader. On pourrait faire deux matrices d&#39;échelle, une pour l&#39;échelle 1.0 / résolution, une autre pour l&#39;échelle 2.0, une troisième pour le déplacement (-1.0,-1.0) et une quatrième pour changer l&#39;échelle Y à -1.0, enfin multiplier tout ça. Mais à la place, parce que les maths c&#39;est sensé être simple, on va juste écrire une fonction qui retourne une matrice de &#39;projection&#39; pour une résolution donnée directement.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function projeter2D(largeur, hauteur) {
  // Note: Cette matrice inverse l&#39;axe Y, il regarde vers le bas
  return [
    2 / largeur, 0, 0,
    0, -2 / hauteur, 0,
    -1, 1, 1
  ];
}
</code></pre><p>Maintenant on peut simplifier le shader davantage. Voici le nouveau shader de vertex :</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">&lt;script id=&quot;shader-de-vertex-2d&quot; type=&quot;x-shader/x-vertex&quot;&gt;
attribute vec2 a_position;

uniform mat3 u_matrice;

void main() {
  // Multiplie la position par la matrice
  gl_Position = vec4((u_matrice * vec3(a_position, 1)).xy, 0, 1);
}
&lt;/script&gt;
</code></pre><p>Et en javascript il reste à multiplier par la matrice de projection :</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  // Rend la scène
  function rendreScene() {
    ...
    // Calcule les matrices
    var matriceProjection = projeter2D(
        canvas.clientWidth, canvas.clientHeight);
    ...

    // Multiplie les matrices
    var matrice = multiplierMatrices(matriceEchelle, matriceRotation);
    matrice = multiplierMatrices(matrice, matriceDeplacement);
    matrice = multiplierMatrices(matrice, matriceProjection);
    ...
  }
</code></pre><p>On a aussi supprimé le code qui indique la résolution. Avec cette dernière étape on est parti d&#39;un shader compliqué avec 6 ou 7 étapes à un shader simplifié à une seule étape, tout ça grâce à la magie des matrices.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-geometry-matrix-transform-with-projection.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-geometry-matrix-transform-with-projection.html" target="_blank">Cliquer ici pour ouvrir dans une nouvelle fenêtre</a>
</div>

</p>
<p>J&#39;espère que ces posts aident à démystifier les matrices. <a href="webgl-3d-orthographic.html">On peut passer à la 3D</a>. En 3D les matrices suivent les mêmes principes. J&#39;ai démarré avec la 2D pour rendre ça plus facile à comprendre. </p>
<div class="webgl_bottombar">
<h3>Que signifient <code class="notranslate" translate="no">clientWidth</code> et <code class="notranslate" translate="no">clientHeight</code>?</h3>
<p>Jusqu'à maintenant quand je faisais référence aux dimensions du canvas j'utilisais <code class="notranslate" translate="no">canvas.width</code> et <code class="notranslate" translate="no">canvas.height</code>
mais dans <code class="notranslate" translate="no">projeter2D</code> j'ai préféré <code class="notranslate" translate="no">canvas.clientWidth</code> et <code class="notranslate" translate="no">canvas.clientHeight</code>. Pourquoi ?</p>
<p>Les matrices de projection ont besoin de connaître les dimensions du canvas pour créer un espace de projection qui ne déforme pas l'objet. 
Mais, dans le navigateur, il y a deux types de pixels qu'on doit gérer. Le premier est le nombre de pixels dans le canvas. Par exemple un canvas défini comme ça </p>
<pre class="prettyprint">
  &lt;canvas width="400" height="300"&gt;&lt;/canvas&gt;
</pre>
<p>ou comme ça</p>
<pre class="prettyprint">
  var canvas = document.createElement("canvas");
  canvas.width = 400;
  canvas.height = 300;
</pre>
<p>les deux contiennent une image de 400 par 300. C'est le nombre de pixel qu'il y aura dans le tampon d'ailleurs. 
Mais cette taille est indépendante de la taille à laquelle le navigateur affiche le canvas. C'est la CSS qui s'en occupe.
Par exemple si on a le canvas suivant, avec ce style appliqué :</p>
<pre class="prettyprint"><!>
  &lt;style&gt;
  canvas {
    width: 100%;
    height: 100%;
  }
  &lt;/style&gt;
  ...
  &lt;canvas width="400" height="300">&lt;/canvas&gt;
</pre>
<p>Le canvas va être affiché dans tout son contenant parent, quel que soit sa propre taille, 400x300 ou une autre.</p>
<p>Voici deux exemples qui définissent la taille d'affichage CSS pour étirer le canvas sur toute la page. Le premier utilise 
<code class="notranslate" translate="no">canvas.width</code> et <code class="notranslate" translate="no">canvas.height</code>. Ouvrez-le dans une nouvelle fenêtre et redimensionnez-là. Le <code class="notranslate" translate="no">F</code> n'a plus le bon aspect, il est déformé.</p>
<div class="webgl_example_container">
  <iframe class="webgl_example" style="width:  500px; height: 150px;" src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-canvas-width-height.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-canvas-width-height.html" target="_blank">Cliquer ici pour ouvrir dans une nouvelle fenêtre</a>
</div>


<p>Dans le second exemple on utilise <code class="notranslate" translate="no">canvas.clientWidth</code> et <code class="notranslate" translate="no">canvas.clientHeight</code>. <code class="notranslate" translate="no">canvas.clientWidth</code> et <code class="notranslate" translate="no">canvas.clientHeight</code> reprennent la taille avec laquelle le canvas est effectivement affiché dans le navigateur donc dans ce cas, même s'il n'a toujours que 400x300 pixels, puisqu'on définit l'aspect en se basant sur l'aspect réel du canvas, le <code class="notranslate" translate="no">F</code> n'est plus déformé.</p>
<div class="webgl_example_container">
  <iframe class="webgl_example" style="width:  500px; height: 150px;" src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-canvas-clientwidth-clientheight.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-canvas-clientwidth-clientheight.html" target="_blank">Cliquer ici pour ouvrir dans une nouvelle fenêtre</a>
</div>


<p>La plupart des applis qui permettent le redimensionnement du canvas essaient de vérifier si <code class="notranslate" translate="no">canvas.clientWidth</code> et <code class="notranslate" translate="no">canvas.clientHeight</code> valent <code class="notranslate" translate="no">canvas.width</code> et <code class="notranslate" translate="no">canvas.height</code> parce qu'ils veulent qu'un pixel du canvas vale un pixel sur l'écran. Mais comme on l'a vu plus haut, ce n'est pas toujours le cas. Donc, dans la plupart des cas, c'est plus correct de calculer une matrice de projection en calculant l'aspect depuis <code class="notranslate" translate="no">canvas.clientHeight</code> et <code class="notranslate" translate="no">canvas.clientWidth</code>.
</p>
</div>


    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-2d-matrices.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-2d-matrices.html" selected>Français</a>
    <option value="/webgl/lessons/ja/webgl-2d-matrices.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-2d-matrices.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-2d-matrices.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-2d-matrices.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-2d-matrices.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-2d-matrices.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Les bases</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-fundamentals.html">WebGL - Les bases</a></li>
<li><a href="/webgl/lessons/fr/webgl-how-it-works.html">WebGL - Comment ça marche</a></li>
<li><a href="/webgl/lessons/fr/webgl-shaders-and-glsl.html">WebGL - Shaders et GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL State Diagram</a></li>
        </ul>
  <li>Traitement d'image</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-image-processing.html">Image Processing</a></li>
<li><a href="/webgl/lessons/fr/webgl-image-processing-continued.html">Image Processing Continued</a></li>
        </ul>
  <li>2D : translation, rotation, échelle, matrices</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-2d-translation.html">WebGL 2D - Translation</a></li>
<li><a href="/webgl/lessons/fr/webgl-2d-rotation.html">WebGL 2D - Rotation</a></li>
<li><a href="/webgl/lessons/fr/webgl-2d-scale.html">WebGL 2D - Echelle</a></li>
<li><a href="/webgl/lessons/fr/webgl-2d-matrices.html">WebGL 2D - Matrices</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-3d-orthographic.html">WebGL 3D - Projection orthographique</a></li>
<li><a href="/webgl/lessons/fr/webgl-3d-perspective.html">WebGL 3D - La perspective</a></li>
<li><a href="/webgl/lessons/fr/webgl-3d-camera.html">WebGL 3D - Les caméras</a></li>
        </ul>
  <li>Lumières</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-3d-lighting-directional.html">WebGL 3D - Lumière directionnelle</a></li>
<li><a href="/webgl/lessons/fr/webgl-3d-lighting-point.html">WebGL 3D - Lumière-point</a></li>
<li><a href="/webgl/lessons/fr/webgl-3d-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Structure et Organisation</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/fr/webgl-drawing-multiple-things.html">Drawing Multiple Things</a></li>
<li><a href="/webgl/lessons/fr/webgl-scene-graph.html">WebGL - Graphes de scène</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-3d-geometry-lathe.html">Geometry - Lathe</a></li>
<li><a href="/webgl/lessons/fr/webgl-load-obj.html">Loading .obj files</a></li>
<li><a href="/webgl/lessons/fr/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>Divers</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-3d-textures.html">Textures</a></li>
<li><a href="/webgl/lessons/fr/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/fr/webgl-2-textures.html">Using 2 or More Textures</a></li>
<li><a href="/webgl/lessons/fr/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/fr/webgl-3d-perspective-correct-texturemapping.html">Perspective Correct Texture Mapping</a></li>
<li><a href="/webgl/lessons/fr/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>Rendering To A Texture</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-render-to-texture.html">Render to Texture</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/fr/webgl-2d-matrix-stack.html">2D - Matrix Stack</a></li>
<li><a href="/webgl/lessons/fr/webgl-sprites.html">Sprites</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/fr/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/fr/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/fr/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/fr/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/fr/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Texte</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-text-html.html">Text - HTML</a></li>
<li><a href="/webgl/lessons/fr/webgl-text-canvas2d.html">Text - Canvas 2D</a></li>
<li><a href="/webgl/lessons/fr/webgl-text-texture.html">Text - Using a Texture</a></li>
<li><a href="/webgl/lessons/fr/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
  <li>Divers</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-ramp-textures.html">Ramp Textures (Toon Shading)</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/fr/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/fr/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/fr/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/fr/webgl-instanced-drawing.html">Instanced Drawing</a></li>
        </ul>
  <li>Divers</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-setup-and-installation.html">Setup And Installation</a></li>
<li><a href="/webgl/lessons/fr/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/fr/webgl-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgl/lessons/fr/webgl-animation.html">Animation</a></li>
<li><a href="/webgl/lessons/fr/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/fr/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/fr/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/fr/webgl-and-alpha.html">WebGL and Alpha</a></li>
<li><a href="/webgl/lessons/fr/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/fr/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/fr/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/fr/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/fr/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/fr/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/fr/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/fr/webgl-tips.html#html-background">Use WebGL as Background in HTML</a></li>
<li><a href="/webgl/lessons/fr/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/fr/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/fr/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/fr/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/fr/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/fr/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Aide pour la doc de l'API</a></li>
  <li><a href="https://twgljs.org">TWGL, une librairie de base pour WebGL</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>Une question ? <a href="https://stackoverflow.com/questions/tagged/webgl">Demander sur stackoverflow</a>.</div>
        <div>Un problème ? <a href="https://github.com/vinci-mz/webgl-fundamentals/issues">Signaler sur github</a>.</div>

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL 2D - Matrices';
            var disqus_title = 'WebGL 2D - Matrices';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
      return;
  }

  function addScript(src, type, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    script.type = type || 'javascript';
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  // can't do this because it would eat contexts
  //addScript('//gpustats.org/stats.js', 'module');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>



