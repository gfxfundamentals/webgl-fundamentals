<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/webgl-fundamentals.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Your first WebGL lesson starting with the fundamentals">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-fundamentals_en.jpg">

<meta property="og:title" content="WebGL Fundamentals">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-fundamentals_en.jpg">
<meta property="og:description" content="Your first WebGL lesson starting with the fundamentals">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGL Fundamentals">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html">
<meta name="twitter:description" content="Your first WebGL lesson starting with the fundamentals">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-fundamentals_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-fundamentals_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html",
      "inLanguage":"en",
      "name":"WebGL Fundamentals",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL Fundamentals</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-fundamentals.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-fundamentals.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-fundamentals.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-fundamentals.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-fundamentals.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-fundamentals.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-fundamentals.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-fundamentals.html" selected>English</a>
    <option value="/webgl/lessons/fr/webgl-fundamentals.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-fundamentals.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-fundamentals.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-fundamentals.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-fundamentals.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-fundamentals.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-fundamentals.html" >简体中文</a>
</select>


    <a href="#toc">Table of Contents</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub a {
    background: #000;
    color: #fff;
    text-decoration: none;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 2rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 300px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(150px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a:hover {
    background: #c11;
    color: #fff;
}
#forkongithub a::before,#forkongithub a::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub a::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
@media (max-width: 900px) {
    #forkongithub a{
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub a{
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL Fundamentals</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>WebGL (Web Graphics Library) is often thought of as a 3D API. People think &quot;I&#39;ll use WebGL and <em>magic</em> I&#39;ll get cool 3d&quot;.
In reality <a href="webgl-2d-vs-3d-library.html">WebGL is just a rasterization engine</a>. It draws points, lines, and triangles based
on code you supply. Getting WebGL to do anything else is up to you to provide code to use
<a href="webgl-points-lines-triangles.html">points, lines, and triangles</a> to accomplish your task.</p>
<p>WebGL runs on the GPU on your computer. As such you need to provide the code that runs on that GPU.
You provide that code in the form of pairs of functions. Those 2 functions are called a vertex shader
and a fragment shader and they are each written in a very strictly typed C/C++ like language called
<a href="webgl-shaders-and-glsl.html">GLSL</a>. (GL Shader Language). Paired together they are called a <em>program</em>.</p>
<p>A vertex shader&#39;s job is to compute vertex positions. Based on the positions the function outputs
WebGL can then rasterize various kinds of primitives including
<a href="webgl-points-lines-triangles.html">points, lines, or triangles</a>.
When rasterizing these primitives it calls a second user supplied function called a fragment shader.
A fragment shader&#39;s job is to compute a color for each pixel of the primitive currently being drawn.</p>
<p>Nearly all of the entire WebGL API is about <a href="resources/webgl-state-diagram.html">setting up state</a> for these pairs of functions to run.
For each thing you want to draw you setup a bunch of state then execute a pair of functions by calling
<code class="notranslate" translate="no">gl.drawArrays</code> or <code class="notranslate" translate="no">gl.drawElements</code> which executes your shaders on the GPU.</p>
<p>Any data you want those functions to have access to must be provided to the GPU. There are 4 ways
a shader can receive data.</p>
<ol>
<li><p>Attributes and Buffers</p>
<p>Buffers are arrays of binary data you upload to the GPU. Usually buffers contain
things like positions, normals, texture coordinates, vertex colors, etc although
you&#39;re free to put anything you want in them.</p>
<p>Attributes are used to specify how to
pull data out of your buffers and provide them to your vertex shader.
For example you might put positions in a buffer as three 32bit floats
per position. You would tell a particular attribute which buffer to pull the positions out of, what type
of data it should pull out (3 component 32 bit floating point numbers), what offset
in the buffer the positions start, and how many bytes to get from one position to the next.</p>
<p>Buffers are not random access. Instead a vertex shader is executed a specified number
of times. Each time it&#39;s executed the next value from each specified buffer is pulled
out and assigned to an attribute.</p>
</li>
<li><p>Uniforms</p>
<p>Uniforms are effectively global variables you set before you execute your shader program.</p>
</li>
<li><p>Textures</p>
<p>Textures are arrays of data you can randomly access in your shader program. The most
common thing to put in a texture is image data but textures are just data and can just
as easily contain something other than colors.</p>
</li>
<li><p>Varyings</p>
<p>Varyings are a way for a vertex shader to pass data to a fragment shader. Depending
on what is being rendered, points, lines, or triangles, the values set on a varying
by a vertex shader will be interpolated while executing the fragment shader.</p>
</li>
</ol>
<h2 id="webgl-hello-world">WebGL Hello World</h2>
<p>WebGL only cares about 2 things: clip space coordinates and colors.
Your job as a programmer using WebGL is to provide WebGL with those 2 things.
You provide your 2 &quot;shaders&quot; to do this. A Vertex shader which provides the
clip space coordinates, and a fragment shader that provides the color.</p>
<p>Clip space coordinates always go from -1 to +1 no matter what size your
canvas is.</p>
<div class="webgl_center"><img src="resources/clipspace.svg" style="width: 400px"></div>

<p>Here is a simple WebGL example that shows WebGL in its simplest form.</p>
<p>Let&#39;s start with a vertex shader</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// an attribute will receive data from a buffer
attribute vec4 a_position;

// all shaders have a main function
void main() {

  // gl_Position is a special variable a vertex shader
  // is responsible for setting
  gl_Position = a_position;
}
</code></pre><p>When executed, if the entire thing was written in JavaScript instead of GLSL
you could imagine it would be used like this</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// *** PSEUDO CODE!! ***

var positionBuffer = [
  0, 0, 0, 0,
  0, 0.5, 0, 0,
  0.7, 0, 0, 0,
];
var attributes = {};
var gl_Position;

drawArrays(..., offset, count) {
  var stride = 4;
  var size = 4;
  for (var i = 0; i &lt; count; ++i) {
     // copy the next 4 values from positionBuffer to the a_position attribute
     const start = offset + i * stride;
     attributes.a_position = positionBuffer.slice(start, start + size);
     runVertexShader();
     ...
     doSomethingWith_gl_Position();
}
</code></pre><p>In reality it&#39;s not quite that simple because <code class="notranslate" translate="no">positionBuffer</code> would need to be converted to binary
data (see below) and so the actual computation for getting data out of the buffer
would be a little different but hopefully this gives you an idea of how a vertex
shader will be executed.</p>
<p>Next we need a fragment shader</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// fragment shaders don&#39;t have a default precision so we need
// to pick one. mediump is a good default. It means &quot;medium precision&quot;
precision mediump float;

void main() {
  // gl_FragColor is a special variable a fragment shader
  // is responsible for setting
  gl_FragColor = vec4(1, 0, 0.5, 1); // return reddish-purple
}
</code></pre><p>Above we&#39;re setting <code class="notranslate" translate="no">gl_FragColor</code> to <code class="notranslate" translate="no">1, 0, 0.5, 1</code> which is 1 for red, 0 for green,
0.5 for blue, 1 for alpha. Colors in WebGL go from 0 to 1.</p>
<p>Now that we have written the 2 shader functions lets get started with WebGL</p>
<p>First we need an HTML canvas element</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no"> &lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;
</code></pre><p>Then in JavaScript we can look that up</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no"> var canvas = document.querySelector(&quot;#c&quot;);
</code></pre><p>Now we can create a WebGLRenderingContext</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no"> var gl = canvas.getContext(&quot;webgl&quot;);
 if (!gl) {
    // no webgl for you!
    ...
</code></pre><p>Now we need to compile those shaders to put them on the GPU so first we need to get them into strings.
You can create your GLSL strings any way you normally create strings in JavaScript: by concatenating,
by using AJAX to download them, by using multiline template strings. Or in this case, by
putting them in non-JavaScript typed script tags.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">&lt;script id=&quot;vertex-shader-2d&quot; type=&quot;notjs&quot;&gt;

  // an attribute will receive data from a buffer
  attribute vec4 a_position;

  // all shaders have a main function
  void main() {

    // gl_Position is a special variable a vertex shader
    // is responsible for setting
    gl_Position = a_position;
  }

&lt;/script&gt;

&lt;script id=&quot;fragment-shader-2d&quot; type=&quot;notjs&quot;&gt;

  // fragment shaders don&#39;t have a default precision so we need
  // to pick one. mediump is a good default
  precision mediump float;

  void main() {
    // gl_FragColor is a special variable a fragment shader
    // is responsible for setting
    gl_FragColor = vec4(1, 0, 0.5, 1); // return reddish-purple
  }

&lt;/script&gt;
</code></pre><p>In fact, most 3D engines generate GLSL shaders on the fly using various types of templates, concatenation, etc.
For the samples on this site though none of them are complex enough to need to generate GLSL at runtime.</p>
<p>Next we need a function that will create a shader, upload the GLSL source, and compile the shader.
Note I haven&#39;t written any comments because it should be clear from the names of the functions
what is happening.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function createShader(gl, type, source) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (success) {
    return shader;
  }

  console.log(gl.getShaderInfoLog(shader));
  gl.deleteShader(shader);
}
</code></pre><p>We can now call that function to create the 2 shaders</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var vertexShaderSource = document.querySelector(&quot;#vertex-shader-2d&quot;).text;
var fragmentShaderSource = document.querySelector(&quot;#fragment-shader-2d&quot;).text;

var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
</code></pre><p>We then need to <em>link</em> those 2 shaders into a <em>program</em></p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function createProgram(gl, vertexShader, fragmentShader) {
  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  var success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (success) {
    return program;
  }

  console.log(gl.getProgramInfoLog(program));
  gl.deleteProgram(program);
}
</code></pre><p>And call it</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var program = createProgram(gl, vertexShader, fragmentShader);
</code></pre><p>Now that we&#39;ve created a GLSL program on the GPU we need to supply data to it.
The majority of the WebGL API is about setting up state to supply data to our GLSL programs.
In this case our only input to our GLSL program is <code class="notranslate" translate="no">a_position</code> which is an attribute.
The first thing we should do is look up the location of the attribute for the program
we just created</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var positionAttributeLocation = gl.getAttribLocation(program, &quot;a_position&quot;);
</code></pre><p>Looking up attribute locations (and uniform locations) is something you should
do during initialization, not in your render loop.</p>
<p>Attributes get their data from buffers so we need to create a buffer</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var positionBuffer = gl.createBuffer();
</code></pre><p>WebGL lets us manipulate many WebGL resources on global bind points.
You can think of bind points as internal global variables inside WebGL.
First you bind a resource to a bind point. Then, all other functions
refer to the resource through the bind point. So, let&#39;s bind the position buffer.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
</code></pre><p>Now we can put data in that buffer by referencing it through the bind point</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// three 2d points
var positions = [
  0, 0,
  0, 0.5,
  0.7, 0,
];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
</code></pre><p>There&#39;s a lot going on here. The first thing is we have <code class="notranslate" translate="no">positions</code> which is a
JavaScript array. WebGL on the other hand needs strongly typed data so the part
<code class="notranslate" translate="no">new Float32Array(positions)</code> creates a new array of 32bit floating point numbers
and copies the values from <code class="notranslate" translate="no">positions</code>. <code class="notranslate" translate="no">gl.bufferData</code> then copies that data to
the <code class="notranslate" translate="no">positionBuffer</code> on the GPU. It&#39;s using the position buffer because we bound
it to the <code class="notranslate" translate="no">ARRAY_BUFFER</code> bind point above.</p>
<p>The last argument, <code class="notranslate" translate="no">gl.STATIC_DRAW</code> is a hint to WebGL about how we&#39;ll use the data.
WebGL can try to use that hint to optimize certain things. <code class="notranslate" translate="no">gl.STATIC_DRAW</code> tells WebGL
we are not likely to change this data much.</p>
<p>The code up to this point is <em>initialization code</em>. Code that gets run once when we
load the page. The code below this point is <em>rendering code</em> or code that should
get executed each time we want to render/draw.</p>
<h2 id="rendering">Rendering</h2>
<p>Before we draw we should resize the canvas to match its display size. Canvases just like Images have 2 sizes.
The number of pixels actually in them and separately the size they are displayed. CSS determines the size
the canvas is displayed. <strong>You should always set the size you want a canvas to be with CSS</strong> since it is far
far more flexible than any other method.</p>
<p>To make the number of pixels in the canvas match the size it&#39;s displayed
<a href="webgl-resizing-the-canvas.html">I&#39;m using a helper function you can read about here</a>.</p>
<p>In nearly all of these samples the canvas size is 400x300 pixels if the sample is run in its own window
but stretches to fill the available space if it&#39;s inside an iframe like it is on this page.
By letting CSS determine the size and then adjusting to match we easily handle both of these cases.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">webglUtils.resizeCanvasToDisplaySize(gl.canvas);
</code></pre><p>We need to tell WebGL how to convert from the clip space
values we&#39;ll be setting <code class="notranslate" translate="no">gl_Position</code> to back into pixels, often called screen space.
To do this we call <code class="notranslate" translate="no">gl.viewport</code> and pass it the current size of the canvas.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
</code></pre><p>This tells WebGL the -1 +1 clip space maps to 0 &lt;-&gt; <code class="notranslate" translate="no">gl.canvas.width</code> for x and 0 &lt;-&gt; <code class="notranslate" translate="no">gl.canvas.height</code>
for y.</p>
<p>We clear the canvas. <code class="notranslate" translate="no">0, 0, 0, 0</code> are red, green, blue, alpha respectively so in this case we&#39;re making the canvas transparent.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// Clear the canvas
gl.clearColor(0, 0, 0, 0);
gl.clear(gl.COLOR_BUFFER_BIT);
</code></pre><p>We tell WebGL which shader program to execute.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// Tell it to use our program (pair of shaders)
gl.useProgram(program);
</code></pre><p>Next we need to tell WebGL how to take data from the buffer we setup above and supply it to the attribute
in the shader. First off we need to turn the attribute on</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.enableVertexAttribArray(positionAttributeLocation);
</code></pre><p>Then we need to specify how to pull the data out</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// Bind the position buffer.
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

// Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
var size = 2;          // 2 components per iteration
var type = gl.FLOAT;   // the data is 32bit floats
var normalize = false; // don&#39;t normalize the data
var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
var offset = 0;        // start at the beginning of the buffer
gl.vertexAttribPointer(
    positionAttributeLocation, size, type, normalize, stride, offset)
</code></pre><p>A hidden part of <code class="notranslate" translate="no">gl.vertexAttribPointer</code> is that it binds the current <code class="notranslate" translate="no">ARRAY_BUFFER</code>
to the attribute. In other words now this attribute is bound to
<code class="notranslate" translate="no">positionBuffer</code>. That means we&#39;re free to bind something else to the <code class="notranslate" translate="no">ARRAY_BUFFER</code> bind point.
The attribute will continue to use <code class="notranslate" translate="no">positionBuffer</code>.</p>
<p>note that from the point of view of our GLSL vertex shader the <code class="notranslate" translate="no">a_position</code> attribute is a <code class="notranslate" translate="no">vec4</code></p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">attribute vec4 a_position;
</code></pre><p><code class="notranslate" translate="no">vec4</code> is a 4 float value. In JavaScript you could think of it something like
<code class="notranslate" translate="no">a_position = {x: 0, y: 0, z: 0, w: 0}</code>. Above we set <code class="notranslate" translate="no">size = 2</code>. Attributes
default to <code class="notranslate" translate="no">0, 0, 0, 1</code> so this attribute will get its first 2 values (x and y)
from our buffer. The z, and w will be the default 0 and 1 respectively.</p>
<p>After all that we can finally ask WebGL to execute our GLSL program.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var primitiveType = gl.TRIANGLES;
var offset = 0;
var count = 3;
gl.drawArrays(primitiveType, offset, count);
</code></pre><p>Because the count is 3 this will execute our vertex shader 3 times. The first time <code class="notranslate" translate="no">a_position.x</code> and <code class="notranslate" translate="no">a_position.y</code>
in our vertex shader attribute will be set to the first 2 values from the positionBuffer.
The second time <code class="notranslate" translate="no">a_position.x</code> and <code class="notranslate" translate="no">a_position.y</code> will be set to the second 2 values. The last time they will be
set to the last 2 values.</p>
<p>Because we set <code class="notranslate" translate="no">primitiveType</code> to <code class="notranslate" translate="no">gl.TRIANGLES</code>, each time our vertex shader is run 3 times
WebGL will draw a triangle based on the 3 values we set <code class="notranslate" translate="no">gl_Position</code> to. No matter what size
our canvas is those values are in clip space coordinates that go from -1 to 1 in each direction.</p>
<p>Because our vertex shader is simply copying our positionBuffer values to <code class="notranslate" translate="no">gl_Position</code> the
triangle will be drawn at clip space coordinates</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  0, 0,
  0, 0.5,
  0.7, 0,
</code></pre><p>Converting from clip space to screen space if the canvas size
happened to be 400x300 we&#39;d get something like this</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no"> clip space      screen space
   0, 0       -&gt;   200, 150
   0, 0.5     -&gt;   200, 225
 0.7, 0       -&gt;   340, 150
</code></pre><p>WebGL will now render that triangle. For every pixel it is about to draw WebGL will call our fragment shader.
Our fragment shader just sets <code class="notranslate" translate="no">gl_FragColor</code> to <code class="notranslate" translate="no">1, 0, 0.5, 1</code>. Since the Canvas is an 8bit
per channel canvas that means WebGL is going to write the values <code class="notranslate" translate="no">[255, 0, 127, 255]</code> into the canvas.</p>
<p>Here&#39;s a live version</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-fundamentals.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-fundamentals.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>In the case above you can see our vertex shader is doing nothing
but passing on our position data directly. Since the position data is
already in clip space there is no work to do. <em>If you want 3D it&#39;s up to you
to supply shaders that convert from 3D to clip space because WebGL is only
a rasterization API</em>.</p>
<p>You might be wondering why does the triangle start in the middle and go to toward the top right.
Clip space in <code class="notranslate" translate="no">x</code> goes from -1 to +1. That means 0 is in the center and positive values will
be to the right of that.</p>
<p>As for why it&#39;s on the top, in clip space -1 is at the bottom and +1 is at the top. That means
0 is in the center and so positive numbers will be above the center.</p>
<p>For 2D stuff you would probably rather work in pixels than clip space so
let&#39;s change the shader so we can supply the position in pixels and have
it convert to clip space for us. Here&#39;s the new vertex shader</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">&lt;script id=&quot;vertex-shader-2d&quot; type=&quot;notjs&quot;&gt;

-  attribute vec4 a_position;
*  attribute vec2 a_position;

+  uniform vec2 u_resolution;

  void main() {
+    // convert the position from pixels to 0.0 to 1.0
+    vec2 zeroToOne = a_position / u_resolution;
+
+    // convert from 0-&gt;1 to 0-&gt;2
+    vec2 zeroToTwo = zeroToOne * 2.0;
+
+    // convert from 0-&gt;2 to -1-&gt;+1 (clip space)
+    vec2 clipSpace = zeroToTwo - 1.0;
+
*    gl_Position = vec4(clipSpace, 0, 1);
  }

&lt;/script&gt;
</code></pre><p>Some things to notice about the changes. We changed <code class="notranslate" translate="no">a_position</code> to a <code class="notranslate" translate="no">vec2</code> since we&#39;re
only using <code class="notranslate" translate="no">x</code> and <code class="notranslate" translate="no">y</code> anyway. A <code class="notranslate" translate="no">vec2</code> is similar to a <code class="notranslate" translate="no">vec4</code> but only has <code class="notranslate" translate="no">x</code> and <code class="notranslate" translate="no">y</code>.</p>
<p>Next we added a <code class="notranslate" translate="no">uniform</code> called <code class="notranslate" translate="no">u_resolution</code>. To set that we need to look up its location.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var resolutionUniformLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);
</code></pre><p>The rest should be clear from the comments. By setting <code class="notranslate" translate="no">u_resolution</code> to the resolution
of our canvas the shader will now take the positions we put in <code class="notranslate" translate="no">positionBuffer</code> supplied
in pixels coordinates and convert them to clip space.</p>
<p>Now we can change our position values from clip space to pixels. This time we&#39;re going to draw a rectangle
made from 2 triangles, 3 points each.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var positions = [
*  10, 20,
*  80, 20,
*  10, 30,
*  10, 30,
*  80, 20,
*  80, 30,
];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
</code></pre><p>And after we set which program to use we can set the value for the uniform we created.
<code class="notranslate" translate="no">gl.useProgram</code> is like <code class="notranslate" translate="no">gl.bindBuffer</code> above in that it sets the current program. After
that all the <code class="notranslate" translate="no">gl.uniformXXX</code> functions set uniforms on the current program.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.useProgram(program);

...

// set the resolution
gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
</code></pre><p>And of course to draw 2 triangles we need to have WebGL call our vertex shader 6 times
so we need to change the <code class="notranslate" translate="no">count</code> to <code class="notranslate" translate="no">6</code>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// draw
var primitiveType = gl.TRIANGLES;
var offset = 0;
*var count = 6;
gl.drawArrays(primitiveType, offset, count);
</code></pre><p>And here it is</p>
<p>Note: This example and all following examples use <a href="/webgl/resources/webgl-utils.js"><code class="notranslate" translate="no">webgl-utils.js</code></a>
which contains functions to compile and link the shaders. No reason to clutter the examples
with that <a href="webgl-boilerplate.html">boilerplate</a> code.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangle.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangle.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>Again you might notice the rectangle is near the bottom of that area. WebGL considers positive Y as
up and negative Y as down. In clip space the bottom left corner -1,-1. We haven&#39;t changed any signs
so with our current math 0, 0 becomes the bottom left corner.
To get it to be the more traditional top left corner used for 2d graphics APIs
we can just flip the clip space y coordinate.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">*   gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
</code></pre><p>And now our rectangle is where we expect it.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangle-top-left.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangle-top-left.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>Let&#39;s make the code that defines a rectangle into a function so
we can call it for different sized rectangles. While we&#39;re at it
we&#39;ll make the color settable.</p>
<p>First we make the fragment shader take a color uniform input.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">&lt;script id=&quot;fragment-shader-2d&quot; type=&quot;notjs&quot;&gt;
  precision mediump float;

+  uniform vec4 u_color;

  void main() {
*    gl_FragColor = u_color;
  }
&lt;/script&gt;
</code></pre><p>And here&#39;s the new code that draws 50 rectangles in random places and random colors.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  var colorUniformLocation = gl.getUniformLocation(program, &quot;u_color&quot;);
  ...

  // draw 50 random rectangles in random colors
  for (var ii = 0; ii &lt; 50; ++ii) {
    // Setup a random rectangle
    // This will write to positionBuffer because
    // its the last thing we bound on the ARRAY_BUFFER
    // bind point
    setRectangle(
        gl, randomInt(300), randomInt(300), randomInt(300), randomInt(300));

    // Set a random color.
    gl.uniform4f(colorUniformLocation, Math.random(), Math.random(), Math.random(), 1);

    // Draw the rectangle.
    gl.drawArrays(gl.TRIANGLES, 0, 6);
  }
}

// Returns a random integer from 0 to range - 1.
function randomInt(range) {
  return Math.floor(Math.random() * range);
}

// Fills the buffer with the values that define a rectangle.

function setRectangle(gl, x, y, width, height) {
  var x1 = x;
  var x2 = x + width;
  var y1 = y;
  var y2 = y + height;

  // NOTE: gl.bufferData(gl.ARRAY_BUFFER, ...) will affect
  // whatever buffer is bound to the `ARRAY_BUFFER` bind point
  // but so far we only have one buffer. If we had more than one
  // buffer we&#39;d want to bind that buffer to `ARRAY_BUFFER` first.

  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
     x1, y1,
     x2, y1,
     x1, y2,
     x1, y2,
     x2, y1,
     x2, y2]), gl.STATIC_DRAW);
}
</code></pre><p>And here&#39;s the rectangles.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangles.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangles.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>I hope you can see that WebGL is actually a pretty simple API.
Okay, simple might be the wrong word. What it does is simple. It just
executes 2 user supplied functions, a vertex shader and fragment shader and
draws triangles, lines, or points.
While it can get more complicated to do 3D that complication is
added by you, the programmer, in the form of more complex shaders.
The WebGL API itself is just a rasterizer and conceptually fairly simple.</p>
<p>We covered a small example that showed how to supply data in an attribute and 2 uniforms.
It&#39;s common to have multiple attributes and many uniforms. Near the top of this article
we also mentioned <em>varyings</em> and <em>textures</em>. Those will show up in subsequent lessons.</p>
<p>Before we move on I want to mention that for <em>most</em> applications updating
the data in a buffer like we did in <code class="notranslate" translate="no">setRectangle</code> is not common. I used that
example because I thought it was easiest to explain since it shows pixel coordinates
as input and demonstrates doing a small amount of math in GLSL. It&#39;s not wrong, there
are plenty of cases where it&#39;s the right thing to do, but you should <a href="webgl-2d-translation.html">keep reading to find out
the more common way to position, orient and scale things in WebGL</a>.</p>
<p>If you&#39;re new to web development or even if you&#39;re not please check out <a href="webgl-setup-and-installation.html">Setup and Installation</a>
for some tips on how to do WebGL development.</p>
<p>If you&#39;re 100% new to WebGL and have no idea what GLSL is or shaders or what the GPU does
then checkout <a href="webgl-how-it-works.html">the basics of how WebGL really works</a>.
You might also want to take a look at this
<a href="/webgl/lessons/resources/webgl-state-diagram.html">interactive state diagram</a>
for another way of understanding how WebGL works.</p>
<p>You should also, at least briefly read about <a href="webgl-boilerplate.html">the boilerplate code used here</a>
that is used in most of the examples. You should also at least skim
<a href="webgl-drawing-multiple-things.html">how to draw multiple things</a> to give you some idea
of how more typical WebGL apps are structured because unfortunately nearly all the examples
only draw one thing and so do not show that structure.</p>
<p>Otherwise from here you can go in 2 directions. If you are interested in image processing
I&#39;ll show you <a href="webgl-image-processing.html">how to do some 2D image processing</a>.
If you are interested in learning about translation,
rotation and scale and eventually 3D then <a href="webgl-2d-translation.html">start here</a>.</p>
<div class="webgl_bottombar">
<h3>What does type="notjs" mean?</h3>
<p>
<code class="notranslate" translate="no">&lt;script&gt;</code> tags default to having JavaScript in them.
You can put no type or you can put <code class="notranslate" translate="no">type="javascript"</code> or
<code class="notranslate" translate="no">type="text/javascript"</code> and the browser will interpret the
contents as JavaScript. If you put anything for else for <code class="notranslate" translate="no">type</code> the browser ignores the
contents of the script tag. In other words <code class="notranslate" translate="no">type="notjs"</code>
or <code class="notranslate" translate="no">type="foobar"</code> have no meaning as far as the browser
is concerned.</p>
<p>This makes the shaders easy to edit.
Other alternatives include string concatenations like</p>
<pre class="prettyprint">
  var shaderSource =
    "void main() {\n" +
    "  gl_FragColor = vec4(1,0,0,1);\n" +
    "}";
</pre>
<p>or we could load shaders with ajax requests but that is slow and asynchronous.</p>
<p>A more modern alternative would be to use multiline template literals.</p>
<pre class="prettyprint">
  var shaderSource = `
    void main() {
      gl_FragColor = vec4(1,0,0,1);
    }
  `;
</pre>
<p>Multiline template literals work in all browsers that support WebGL.
Unfortunately they don't work in really old browsers so if you care
about supporting a fallback for those browsers you might not want to
use multiline template literals or you might want to use <a href="https://babeljs.io/">a transpiler</a>.
</p>
</div>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-fundamentals.html" selected>English</a>
    <option value="/webgl/lessons/fr/webgl-fundamentals.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-fundamentals.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-fundamentals.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-fundamentals.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-fundamentals.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-fundamentals.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-fundamentals.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Fundamentals</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgl/lessons/webgl-how-it-works.html">How It Works</a></li>
<li><a href="/webgl/lessons/webgl-shaders-and-glsl.html">Shaders and GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL State Diagram</a></li>
        </ul>
  <li>Image Processing</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-image-processing.html">Image Processing</a></li>
<li><a href="/webgl/lessons/webgl-image-processing-continued.html">Image Processing Continued</a></li>
        </ul>
  <li>2D translation, rotation, scale, matrix math</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-translation.html">2D Translation</a></li>
<li><a href="/webgl/lessons/webgl-2d-rotation.html">2D Rotation</a></li>
<li><a href="/webgl/lessons/webgl-2d-scale.html">2D Scale</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrices.html">2D Matrices</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-orthographic.html">Orthographic 3D</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective.html">3D Perspective</a></li>
<li><a href="/webgl/lessons/webgl-3d-camera.html">3D Cameras</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Structure and Organization</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/webgl-drawing-multiple-things.html">Drawing Multiple Things</a></li>
<li><a href="/webgl/lessons/webgl-scene-graph.html">Scene Graphs</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-geometry-lathe.html">Geometry - Lathe</a></li>
<li><a href="/webgl/lessons/webgl-load-obj.html">Loading .obj files</a></li>
<li><a href="/webgl/lessons/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>Textures</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-textures.html">Textures</a></li>
<li><a href="/webgl/lessons/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/webgl-2-textures.html">Using 2 or More Textures</a></li>
<li><a href="/webgl/lessons/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective-correct-texturemapping.html">Perspective Correct Texture Mapping</a></li>
<li><a href="/webgl/lessons/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>Rendering To A Texture</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-render-to-texture.html">Render to Texture</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrix-stack.html">2D - Matrix Stack</a></li>
<li><a href="/webgl/lessons/webgl-sprites.html">Sprites</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-text-html.html">Text - HTML</a></li>
<li><a href="/webgl/lessons/webgl-text-canvas2d.html">Text - Canvas 2D</a></li>
<li><a href="/webgl/lessons/webgl-text-texture.html">Text - Using a Texture</a></li>
<li><a href="/webgl/lessons/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
  <li>Textures</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-ramp-textures.html">Ramp Textures (Toon Shading)</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/webgl-instanced-drawing.html">Instanced Drawing</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-setup-and-installation.html">Setup And Installation</a></li>
<li><a href="/webgl/lessons/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/webgl-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgl/lessons/webgl-animation.html">Animation</a></li>
<li><a href="/webgl/lessons/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/webgl-and-alpha.html">WebGL and Alpha</a></li>
<li><a href="/webgl/lessons/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#html-background">Use WebGL as Background in HTML</a></li>
<li><a href="/webgl/lessons/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="https://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
    <div>Questions? <a href="https://stackoverflow.com/questions/tagged/webgl">Ask on stackoverflow</a>.</div>
    <div>Issue/Bug? <a href="https://github.com/gfxfundamentals/webgl-fundamentals/issues">Create an issue on github</a>.</div>
    <div class="lesson-comment-notes">
       Use <b>&lt;pre&gt;&lt;code&gt;</b>code goes here<b>&lt;/code&gt;&lt;/pre&gt;</b> for code blocks
    </div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL Fundamentals';
            var disqus_title = 'WebGL Fundamentals';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
      return;
  }

  function addScript(src, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  addScript('//cdn.webglstats.com/stat.js');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>



