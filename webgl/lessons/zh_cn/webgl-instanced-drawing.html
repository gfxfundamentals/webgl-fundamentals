<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/zh_cn/webgl-instanced-drawing.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="绘制同一物体的多个实例" />
<meta name="keywords" content="webgl graphics" />
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-instanced-drawing_zh-cn.jpg" />

<meta property="og:title" content="WebGL性能优化 - 实例化绘制" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-instanced-drawing_zh-cn.jpg" />
<meta property="og:description" content="绘制同一物体的多个实例" />
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-instanced-drawing.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webglfundamentals.org" />
<meta name="twitter:title" content="WebGL性能优化 - 实例化绘制" />
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-instanced-drawing.html" />
<meta name="twitter:description" content="绘制同一物体的多个实例" />
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-instanced-drawing_zh-cn.jpg" />

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-instanced-drawing.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-instanced-drawing_zh-cn.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-instanced-drawing.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-instanced-drawing.html",
      "inLanguage":"zh-cn",
      "name":"WebGL性能优化 - 实例化绘制",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-instanced-drawing.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL性能优化 - 实例化绘制</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />



</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-instanced-drawing.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-instanced-drawing.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-instanced-drawing.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-instanced-drawing.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-instanced-drawing.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-instanced-drawing.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-instanced-drawing.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-instanced-drawing.html" selected>简体中文</a>
</select>


    <a href="#toc">目录</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/zh_cn/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub a {
    background: #000;
    color: #fff;
    text-decoration: none;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 2rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 300px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(150px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a:hover {
    background: #c11;
    color: #fff;
}
#forkongithub a::before,#forkongithub a::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub a::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
@media (max-width: 900px) {
    #forkongithub a{
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub a{
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL性能优化 - 实例化绘制</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>WebGL有一个拓展叫做<em>实例化绘制</em>。
一般来说，使用这种方法绘制多个相同的物体比一个一个绘制要快得多。</p>
<p>注意这项功能对于WebGL 1是一项可选的拓展，但是很明显它可以在
<a href="https://webglstats.com/webgl/extension/ANGLE_instanced_arrays">几乎所有的设备上使用</a>。</p>
<p>首先让我们来演示一下如何绘制同一物体的多个实例。</p>
<p>下面的代码<em>类似</em>于我们在
<a href="webgl-3d-orthographic.html">正射投影</a>
这篇文章中的结尾部分。我们先来看下面两个着色器的代码。</p>
<pre class="prettyprint"><code class="lang-html">&lt;!-- 顶点着色器 --&gt;
&lt;script id=&quot;vertex-shader-3d&quot; type=&quot;x-shader/x-vertex&quot;&gt;
attribute vec4 a_position;
uniform mat4 matrix;

void main() {
  // 顶点位置与矩阵相乘。
  gl_Position = matrix * a_position;
}
&lt;/script&gt;
</code></pre>
<p>and</p>
<pre class="prettyprint"><code class="lang-html">&lt;!-- 片元着色器 --&gt;
&lt;script id=&quot;fragment-shader-3d&quot; type=&quot;x-shader/x-fragment&quot;&gt;
precision mediump float;

uniform vec4 color;

void main() {
  gl_FragColor = color;
}
&lt;/script&gt;
</code></pre>
<p>在顶点着色器里我们像<a href="webgl-3d-orthographic.html">那篇文章</a>
一样让实例的每个顶点与一个矩阵相乘，因为这样非常的灵活。
在片元着色器中则使用通过uniform传递的颜色变量。</p>
<p>要进行绘制我们得先编译着色器并连接为一个program，
然后再找到所有attribute和uniform的地址。</p>
<pre class="prettyprint"><code class="lang-js">const program = webglUtils.createProgramFromScripts(
    gl, [&#39;vertex-shader-3d&#39;, &#39;fragment-shader-3d&#39;]);

const positionLoc = gl.getAttribLocation(program, &#39;a_position&#39;);
const colorLoc = gl.getUniformLocation(program, &#39;color&#39;);
const matrixLoc = gl.getUniformLocation(program, &#39;matrix&#39;);
</code></pre>
<p>之后我们需要使用一个缓冲区提供顶点数据。</p>
<pre class="prettyprint"><code class="lang-js">const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -0.1,  0.4,
    -0.1, -0.4,
     0.1, -0.4,
     0.1, -0.4,
    -0.1,  0.4,
     0.1,  0.4,
     0.4, -0.1,
    -0.4, -0.1,
    -0.4,  0.1,
    -0.4,  0.1,
     0.4, -0.1,
     0.4,  0.1,
  ]), gl.STATIC_DRAW);
const numVertices = 12;
</code></pre>
<p>让我们绘制5个实例，并给每个实例分别提供1个矩阵和1种颜色。</p>
<pre class="prettyprint"><code class="lang-js">const numInstances = 5;
const matrices = [
  m4.identity(),
  m4.identity(),
  m4.identity(),
  m4.identity(),
  m4.identity(),
];

const colors = [
  [ 1, 0, 0, 1, ],  // 红色
  [ 0, 1, 0, 1, ],  // 绿色
  [ 0, 0, 1, 1, ],  // 蓝色
  [ 1, 0, 1, 1, ],  // 紫红色
  [ 0, 1, 1, 1, ],  // 青色
];
</code></pre>
<p>要绘制它们我们首先得使用着色器程序，并设置attribute，
然后在一个循环当中为这5个实例分别计算新的矩阵，
再去设置矩阵和颜色的uniform，最后把它们绘制出来。</p>
<pre class="prettyprint"><code class="lang-js">function render(time) {
  time *= 0.001; // seconds

  gl.useProgram(program);

  // 设置顶点位置的attribute
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(
      positionLoc,  // location
      2,            // size (每次迭代从缓冲区里取出的数量)
      gl.FLOAT,     // 缓冲区中的数据类型
      false,        // 归一化
      0,            // stride (0 = 根据size和数据类型进行推断)
      0,            // offset in buffer
  );

  matrices.forEach((mat, ndx) =&gt; {
    m4.translation(-0.5 + ndx * 0.25, 0, 0, mat);
    m4.zRotate(mat, time * (0.1 + 0.1 * ndx), mat);

    const color = colors[ndx];

    gl.uniform4fv(colorLoc, color);
    gl.uniformMatrix4fv(matrixLoc, false, mat);

    gl.drawArrays(
        gl.TRIANGLES,
        0,             // offset
        numVertices,   // 每个实例的顶点数量
    );
  });

  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</code></pre>
<p>注意到这个数学矩阵库里所有关于矩阵函数的最后一个参数都是一个可选的
目标矩阵。在其它大多数文章里我们并没有用到这个参数，而是让它自行创建一个
新的矩阵，但这一次我们想让结果存放在已经创建好的矩阵上。</p>
<p>于是乎我们得到了5个不同颜色而且还在自转的加号。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-instanced-drawing-not-instanced.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-instanced-drawing-not-instanced.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>对于每个实例来说，每绘制一次要调用一次<code>gl.uniform4v</code>，<code>gl.uniformMatrix4fv</code>
还有<code>gl.drawArrays</code>，一共是15个WebGL的函数调用。如果我们的着色器
更加复杂，像是<a href="webgl-3d-lighting-spot.html">聚光灯那篇文章</a>一样的话，
每个物体至少要有7次函数调用，分别是6次调用<code>gl.uniformXXX</code>，
最后一次调用<code>gl.drawArrays</code>。如果我们要绘制400个物体的话
那将会是2800个WebGL函数调用。</p>
<p>实例化就是一个帮助我们减少函数调用的好路子。
它的工作原理是让你告诉WebGL你想绘制多少次相同的物体（实例的数量）。
对于每个attribute，你可以让它每次调用顶点着色器时迭代到缓冲区的
<em>下一个值</em>（默认行为），或者是每绘制N（N通常为1）个实例时才迭代到
<em>下一个值</em>。</p>
<p>举个栗子，我们不妨使用attribute来提供<code>matrix</code>和<code>color</code>的值以取代uniform。
我们会在缓冲区里为每个实例提供矩阵和颜色，设置好从缓冲区里读取数据的
attribute，然后告诉WebGL只有在绘制下一个实例的时候才迭代到下一个值。</p>
<p>Let&#39;s do it!</p>
<p>第一件要做的事是启用这项可选的WebGL拓展。它叫做
<a href="https://developer.mozilla.org/en-US/docs/Web/API/ANGLE_instanced_arrays"><code>ANGLE_instanced_arrays</code></a>。</p>
<pre class="prettyprint"><code class="lang-js">const canvas = document.querySelector(&#39;#canvas&#39;);
const gl = canvas.getContext(&#39;webgl&#39;);
if (!gl) {
  return;
}

+const ext = gl.getExtension(&#39;ANGLE_instanced_arrays&#39;);
+if (!ext) {
+  return alert(&#39;need ANGLE_instanced_arrays&#39;);
+}
</code></pre>
<p>接下来我们改一下这些着色器，用attribute给<code>matrix</code>和<code>color</code>提供数据。</p>
<pre class="prettyprint"><code class="lang-html">&lt;!-- 顶点着色器 --&gt;
&lt;script id=&quot;vertex-shader-3d&quot; type=&quot;x-shader/x-vertex&quot;&gt;
attribute vec4 a_position;
-uniform mat4 matrix;
+attribute vec4 color;
+attribute mat4 matrix;
+
+varying vec4 v_color;

void main() {
  // 顶点位置与矩阵相乘
  gl_Position = matrix * a_position;

+  // 传递颜色到片元着色器
+  v_color = color;
}
&lt;/script&gt;
</code></pre>
<p>and </p>
<pre class="prettyprint"><code class="lang-html">&lt;!-- 片元着色器 --&gt;
&lt;script id=&quot;fragment-shader-3d&quot; type=&quot;x-shader/x-fragment&quot;&gt;
precision mediump float;

-uniform vec4 color;
+// Passed in from the vertex shader.
+varying vec4 v_color;

void main() {
-  gl_FragColor = color;
+  gl_FragColor = v_color;
}
&lt;/script&gt;
</code></pre>
<p>因为attribute只能在顶点着色器中声明所以我们需要用varying
把颜色传递到片元着色器。</p>
<p>然后我们需要找到所有attribute的位置。</p>
<pre class="prettyprint"><code class="lang-js">const program = webglUtils.createProgramFromScripts(
    gl, [&#39;vertex-shader-3d&#39;, &#39;fragment-shader-3d&#39;]);

const positionLoc = gl.getAttribLocation(program, &#39;a_position&#39;);
-const colorLoc = gl.getUniformLocation(program, &#39;color&#39;);
-const matrixLoc = gl.getUniformLocation(program, &#39;matrix&#39;);
+const colorLoc = gl.getAttribLocation(program, &#39;color&#39;);
+const matrixLoc = gl.getAttribLocation(program, &#39;matrix&#39;);
</code></pre>
<p>现在，我们需要一个缓冲区来储存所有一会我们要提供给attribute的矩阵。
因为缓冲区最好在一个<em>chuck</em>中更新，所以我们把所有的矩阵放在一个
<code>Float32Array</code>当中。</p>
<pre class="prettyprint"><code class="lang-js">// 为每一个实例设置矩阵
const numInstances = 5;
+// make a typed array with one view per matrix
+const matrixData = new Float32Array(numInstances * 16);
</code></pre>
<p>然后我们再为每一个矩阵创建一个更小的<code>Float32Array</code>的观察视图。</p>
<pre class="prettyprint"><code class="lang-js">-const matrices = [
-  m4.identity(),
-  m4.identity(),
-  m4.identity(),
-  m4.identity(),
-  m4.identity(),
-];
const matrices = [];
for (let i = 0; i &lt; numInstances; ++i) {
  const byteOffsetToMatrix = i * 16 * 4;
  const numFloatsForView = 16;
  matrices.push(new Float32Array(
      matrixData.buffer,
      byteOffsetToMatrix,
      numFloatsForView));
}
</code></pre>
<p>这样做的话我们可以用<code>matrixData</code>来取得所有矩阵的数据，
当需要取得某一个矩阵的数据的时候只要用<code>matrices[ndx]</code>即可。</p>
<p>同时我们也需要在GPU上创建缓冲区来储存这些数据。
目前只需要申请一段合适大小的缓冲区就好了，我们暂时不需要提供数据给它，
所以<code>gl.bufferData</code>第二个参数设置为要为缓冲区申请的字节数。</p>
<pre class="prettyprint"><code class="lang-js">const matrixBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, matrixBuffer);
// 只为缓冲区申请特定大小的空间
gl.bufferData(gl.ARRAY_BUFFER, matrixData.byteLength, gl.DYNAMIC_DRAW);
</code></pre>
<p>注意到最后一个参数是<code>gl.DYNAMIC_DRAW</code>。这是一个给WebGL的<em>指示</em>，
告诉它我们要经常刷新这里的数据。</p>
<p>接下来颜色值也需要储存在缓冲区当中。因为在这个例子当中颜色不会改变，
所以我们直接上传数据即可。</p>
<pre class="prettyprint"><code class="lang-js">-const colors = [
-  [ 1, 0, 0, 1, ],  // red
-  [ 0, 1, 0, 1, ],  // green
-  [ 0, 0, 1, 1, ],  // blue
-  [ 1, 0, 1, 1, ],  // magenta
-  [ 0, 1, 1, 1, ],  // cyan
-];
+// 为每一个实例设置颜色
+const colorBuffer = gl.createBuffer();
+gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
+gl.bufferData(gl.ARRAY_BUFFER,
+    new Float32Array([
+        1, 0, 0, 1,  // red
+        0, 1, 0, 1,  // green
+        0, 0, 1, 1,  // blue
+        1, 0, 1, 1,  // magenta
+        0, 1, 1, 1,  // cyan
+      ]),
+    gl.STATIC_DRAW);
</code></pre>
<p>在绘制的时候，我们再也不用在循环中设置矩阵和颜色的uniform，
而是先来计算一下每个实例的矩阵。</p>
<pre class="prettyprint"><code class="lang-js">// 更新所有矩阵
matrices.forEach((mat, ndx) =&gt; {
  m4.translation(-0.5 + ndx * 0.25, 0, 0, mat);
  m4.zRotate(mat, time * (0.1 + 0.1 * ndx), mat);

-  const color = colors[ndx];
-
-  gl.uniform4fv(colorLoc, color);
-  gl.uniformMatrix4fv(matrixLoc, false, mat);
-
-  gl.drawArrays(
-      gl.TRIANGLES,
-      0,             // offset
-      numVertices,   // num vertices per instance
-  );
});
</code></pre>
<p>因为我们的矩阵已经作为了目标矩阵参数来传递，同时它还是一个
<code>Float32Array</code>的数组，所以在计算完以后我们就可以把数据直接上传给GPU了。</p>
<pre class="prettyprint"><code class="lang-js">// 上传新的矩阵数据
gl.bindBuffer(gl.ARRAY_BUFFER, matrixBuffer);
gl.bufferSubData(gl.ARRAY_BUFFER, 0, matrixData);
</code></pre>
<p>现在我们需要为矩阵和颜色设置attribute。
注意矩阵的类型为<code>mat4</code>，一个<code>mat4</code>实际上占用了4个attribute槽位。</p>
<pre class="prettyprint"><code class="lang-js">const bytesPerMatrix = 4 * 16;
for (let i = 0; i &lt; 4; ++i) {
  const loc = matrixLoc + i;
  gl.enableVertexAttribArray(loc);
  // 注意stride和offset
  const offset = i * 16;  // 一行有4个单精度浮点数，1个就占用4字节
  gl.vertexAttribPointer(
      loc,              // location
      4,                // size (num values to pull from buffer per iteration)
      gl.FLOAT,         // type of data in buffer
      false,            // normalize
      bytesPerMatrix,   // stride, num bytes to advance to get to next set of values
      offset,           // offset in buffer
  );
  // 这行说的是attribute只对下一个实例才进行迭代
  ext.vertexAttribDivisorANGLE(loc, 1);
}
</code></pre>
<p>要进行实例化绘制最重要的其实是调用<code>ext.vertexAttribDivisorANGLE</code>，
它告诉attribute只有在绘制下一个实例的时候才迭代到下一个值。
意思是说，<code>matrix</code> attribute会对于第一个实例的所有顶点使用
第一个矩阵，第二个实例使用第二个矩阵以此类推。</p>
<p>接下来我们还需要去设置颜色的attribute。</p>
<pre class="prettyprint"><code class="lang-js">// 为颜色设置attribute
gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
gl.enableVertexAttribArray(colorLoc);
gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0);
// this line says this attribute only changes for each 1 instance
ext.vertexAttribDivisorANGLE(colorLoc, 1);
</code></pre>
<p>还有一点你要牢记，我们已经在这两个attribute上设置了divisor，
如果我们想要绘制其它东西的话我们需要把divisor重新设置为0（默认）。
<strong>或者，我们有更好的选择——</strong><a href="webgl-attributes.html#vaos">vertex array objects</a>。</p>
<p>最后我们总算是可以在一个draw call当中绘制所有的实例了。</p>
<pre class="prettyprint"><code class="lang-js">ext.drawArraysInstancedANGLE(
  gl.TRIANGLES,
  0,             // offset
  numVertices,   // 每个实例的顶点数
  numInstances,  // 实例的数量
);
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-instanced-drawing.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-instanced-drawing.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>在之前的例子当中每个实例需要三次函数调用，所以一共是15次的调用。
但是现在我们只需要总共两次函数调用即可，第一次上传所有的矩阵数据，
第二次就是请求绘制了。对于这个例子来说，只要稍微设置一下矩阵和颜色
就可以请求绘制了，我们还可以用<a href="webgl-attributes.html#vaos">vertex array object</a>
把这些设置从渲染的时候移动到初始化的时候。</p>
<p>我不知道我是不是显得有点啰嗦了，还有一点我想说的是，上面的代码我们并没有
考虑到关于canvas方面的东西。我是说，我们并没有使用任何的
<a href="webgl-3d-orthographic.html">投影矩阵</a>或是<a href="webgl-3d-camera.html">视图矩阵</a>。
因为我们只是为了去演示如何实例化绘制罢了。如果你想往里加点投影或是视图矩阵的话，
那将意味着更多的计算会放到JavaScript当中，
这可能会引起一些性能问题。有个更好的办法是给顶点着色器添加一到两个
uniform来储存这些矩阵。</p>
<pre class="prettyprint"><code class="lang-html">&lt;!-- 顶点着色器 --&gt;
&lt;script id=&quot;vertex-shader-3d&quot; type=&quot;x-shader/x-vertex&quot;&gt;
attribute vec4 a_position;
attribute vec4 color;
attribute mat4 matrix;
+uniform mat4 projection;
+uniform mat4 view;

varying vec4 v_color;

void main() {
  // Multiply the position by the matrix.
-  gl_Position = matrix * a_position;
+  gl_Position = projection * view * matrix * a_position;

  // Pass the vertex color to the fragment shader.
  v_color = color;
}
&lt;/script&gt;
</code></pre>
<p>然后在初始化的时候找到他们的位置</p>
<pre class="prettyprint"><code class="lang-js">const positionLoc = gl.getAttribLocation(program, &#39;a_position&#39;);
const colorLoc = gl.getAttribLocation(program, &#39;color&#39;);
const matrixLoc = gl.getAttribLocation(program, &#39;matrix&#39;);
+const projectionLoc = gl.getUniformLocation(program, &#39;projection&#39;);
+const viewLoc = gl.getUniformLocation(program, &#39;view&#39;);
</code></pre>
<p>然后再渲染的时候设置它们。</p>
<pre class="prettyprint"><code class="lang-js">gl.useProgram(program);

+// 设置视图和投影矩阵
+// 因为对于所有实例来说它们是一样的
+const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
+gl.uniformMatrix4fv(projectionLoc, false,
+    m4.orthographic(-aspect, aspect, -1, 1, -1, 1));
+gl.uniformMatrix4fv(viewLoc, false, m4.zRotation(time * .1));
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-instanced-drawing-projection-view.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-instanced-drawing-projection-view.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-instanced-drawing.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-instanced-drawing.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-instanced-drawing.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-instanced-drawing.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-instanced-drawing.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-instanced-drawing.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-instanced-drawing.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-instanced-drawing.html" selected>简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>基础概念</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-fundamentals.html">WebGL 基础概念</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-how-it-works.html">WebGL 工作原理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html">WebGL 着色器和GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL State Diagram</a></li>
        </ul>
  <li>图像处理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-image-processing.html">WebGL 图像处理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-image-processing-continued.html">WebGL 进一步处理图像</a></li>
        </ul>
  <li>二维平移，旋转，缩放和矩阵运算</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-translation.html">WebGL 二维平移</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-rotation.html">WebGL 二维旋转</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-scale.html">WebGL 二维缩放</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrices.html">WebGL 二维矩阵</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-orthographic.html">WebGL 三维正射投影</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective.html">WebGL 三维透视投影</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-camera.html">WebGL 三维相机</a></li>
        </ul>
  <li>光照</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-directional.html">WebGL 三维方向光源</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-point.html">WebGL 三维点光源</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-spot.html">WebGL 三维聚光灯</a></li>
        </ul>
  <li>组织和重构</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-less-code-more-fun.html">WebGL 码少趣多</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-multiple-things.html">WebGL 绘制多个物体</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-scene-graph.html">WebGL 场景图</a></li>
        </ul>
  <li>几何</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-geometry-lathe.html">WebGL 三维几何加工</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-load-obj.html">Loading .obj files</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-textures.html">WebGL 三维纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-data-textures.html">WebGL 数据纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2-textures.html">WebGL 使用多个纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-cors-permission.html">WebGL 跨域图像</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective-correct-texturemapping.html">WebGL 纹理映射的透视纠正</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>渲染到纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-render-to-texture.html">WebGL 渲染到纹理</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>技术</li>
        <ul>
            <li>二维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-drawimage.html">WebGL 二维DrawImage</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrix-stack.html">WebGL 二维矩阵栈</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-sprites.html">Sprites</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-cube-maps.html">WebGL 立方体贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-environment-maps.html">WebGL 环境贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skybox.html">WebGL 天空盒</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skinning.html">WebGL 蒙皮</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-fog.html">WebGL 雾</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>文字</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-text-html.html">WebGL 文字 - HTML</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-canvas2d.html">WebGL 文字 - 二维Canvas</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-texture.html">WebGL 文字 - 使用纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-glyphs.html">WebGL 文字 - 使用字形纹理</a></li>
        </ul>
  <li>纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-ramp-textures.html">Ramp Textures (Toon Shading)</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>杂项</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-setup-and-installation.html">WebGL 设置和安装</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-boilerplate.html">WebGL 样板</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html">WebGL 重置画布尺寸</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-animation.html">WebGL 动画</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-instanced-drawing.html">实例化绘制</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-and-alpha.html">WebGL 和阿尔法通道</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-vs-3d-library.html">WebGL 2D vs 3D 库</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-anti-patterns.html">WebGL 错误模式</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#html-background">Use WebGL as Background in HTML</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API 帮助文档</a></li>
  <li><a href="https://twgljs.org">TWGL, 一个轻量级WebGL辅助库</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>有关于WebGL的疑问? <a href="https://stackoverflow.com/questions/tagged/webgl">在Stackoverflow提问</a>。</div>
        <div>有意见或建议? <a href="https://github.com/vinci-mz/webgl-fundamentals/issues">在GitHub上提issue</a>。</div>

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL性能优化 - 实例化绘制';
            var disqus_title = 'WebGL性能优化 - 实例化绘制';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
      return;
  }

  function addScript(src, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  addScript('//cdn.webglstats.com/stat.js');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>



