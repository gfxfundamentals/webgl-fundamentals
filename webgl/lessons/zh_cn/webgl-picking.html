<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/zh_cn/webgl-picking.md. Do not edited directly -->
<!--
Copyright 2021 GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="如何在 WebGL 中抓取物体">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-picking_zh-cn.jpg">

<meta property="og:title" content="WebGL 抓取">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-picking_zh-cn.jpg">
<meta property="og:description" content="如何在 WebGL 中抓取物体">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-picking.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGL 抓取">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-picking.html">
<meta name="twitter:description" content="如何在 WebGL 中抓取物体">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-picking_zh-cn.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-picking.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-picking_zh-cn.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-picking.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-picking.html",
      "inLanguage":"zh-cn",
      "name":"WebGL 抓取",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-picking.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL 抓取</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-picking.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-picking.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-picking.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-picking.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-picking.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-picking.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-picking.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-picking.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-picking.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-picking.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-picking.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-picking.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-picking.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-picking.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-picking.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-picking.html" selected>简体中文</a>
</select>


    <a href="#toc">目录</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/zh_cn/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL 抓取</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>这篇文章是关于如何使用 WebGL 来让用户抓取或选择对象。</p>
<p>如果你读过本网站的其他文章，你可能已经意识到 WebGL 本身只是一个栅格化库。它在画布上绘制三角形、直线和点。
它在画布上绘制三角形、线和点，所以它没有&quot;选择对象&quot;的概念，它只是通过你提供的着色器输出像素。
这意味着任何&quot;抓取&quot;对象的概念都必须来自你的代码，你需要自行定义你让用户选择对象的形式。
这也意味着虽然这篇文章可以覆盖(WebGL抓取的)常用概念，但你需要自己决定如何将你在这里看到的东西转化为你自己应用中可用的程序。</p>
<h2 id="-">点击一个物体</h2>
<p>关于找到用户点击的物体，一个最简单的方法是：为每一个对象赋予一个数字id，我们可以在关闭光照和纹理的情况下将数字id当作颜色绘制所有对象。
随后我们将得到一帧图片，上面绘制了所有物体的剪影，而深度缓冲会自动帮我们排序。
我们可以读取鼠标坐标下的像素颜色为数字id，就能得到这个位置上渲染的对应物体。</p>
<p>为了实现这一技术，我们需要结合以前的几篇文章。
第一篇是关于<a href="webgl-drawing-multiple-things.html">绘制多个物体</a>,
参考它的内容，我们可以绘制多个物体并尝试抓取。</p>
<p>此外，我们需要在屏幕外渲染这些id，<a href="webgl-render-to-texture.html">渲染到纹理</a> 中的代码也将添加进来。</p>
<p>那么，让我们参考上个案例，在<a href="webgl-drawing-multiple-things.html">多物体绘制</a>中绘制了200个物体。</p>
<p>同时，让我们为它添加一个带有纹理和深度缓冲器的帧缓冲器，参考<a href="webgl-render-to-texture.html">渲染到纹理</a>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 创建一个纹理对象作为渲染目标
const targetTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, targetTexture);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

// 创建一个深度缓冲
const depthBuffer = gl.createRenderbuffer();
gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);

function setFramebufferAttachmentSizes(width, height) {
  gl.bindTexture(gl.TEXTURE_2D, targetTexture);
  // 定义 0 级贴图的尺寸和格式
  const level = 0;
  const internalFormat = gl.RGBA;
  const border = 0;
  const format = gl.RGBA;
  const type = gl.UNSIGNED_BYTE;
  const data = null;
  gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                width, height, border,
                format, type, data);

  gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
}

// 创建并绑定帧缓冲
const fb = gl.createFramebuffer();
gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

// 绑定纹理作为一个颜色附件
const attachmentPoint = gl.COLOR_ATTACHMENT0;
const level = 0;
gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, targetTexture, level);

// 创建一个和渲染目标储存相同的深度缓冲
gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);
</code></pre>
<p>我们将纹理和深度渲染缓冲区配置代码放到一个函数中，通过调用它来调整它们的尺寸，使之与画布的大小一致。</p>
<p>在我们的代码里，如果Canvas改变尺寸，我们将调整纹理和渲染缓冲区以匹配它。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function drawScene(time) {
  time *= 0.0005;

-  webglUtils.resizeCanvasToDisplaySize(gl.canvas);
+  if (webglUtils.resizeCanvasToDisplaySize(gl.canvas)) {
+    // 当canvas改变尺寸后，同步帧缓冲的尺寸
+    setFramebufferAttachmentSizes(gl.canvas.width, gl.canvas.height);
+  }

...
</code></pre>
<p>接下来我们需要第二个着色器。例子中的着色器使用顶点颜色，但这个案例中我们的着色器要可以通过id设置固定颜色。
所以以下是我们的第二个着色器。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;!-- vertex shader --&gt;
&lt;script id=&quot;pick-vertex-shader&quot; type=&quot;x-shader/x-vertex&quot;&gt;
  attribute vec4 a_position;

  uniform mat4 u_matrix;

  void main() {
    // 顶点坐标与矩阵相乘
    gl_Position = u_matrix * a_position;
  }
&lt;/script&gt;
&lt;!-- fragment shader --&gt;
&lt;script id=&quot;pick-fragment-shader&quot; type=&quot;x-shader/x-fragment&quot;&gt;
  precision mediump float;

  uniform vec4 u_id;

  void main() {
     gl_FragColor = u_id;
  }
&lt;/script&gt;
</code></pre>
<p>然后我们需要编译, 链接和查找着色器指向，参考<a href="webgl-less-code-more-fun.html">建议</a>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 设置 GLSL 程序
const programInfo = webglUtils.createProgramInfo(
    gl, [&quot;3d-vertex-shader&quot;, &quot;3d-fragment-shader&quot;]);
+const pickingProgramInfo = webglUtils.createProgramInfo(
+    gl, [&quot;pick-vertex-shader&quot;, &quot;pick-fragment-shader&quot;]);
</code></pre>
<p>我们需要实现渲染所有的对象两次。一次是用我们分配给它们的着色器，第二次用我们上面写的着色器渲染。
所以我们把目前渲染所有物体的代码提取到一个函数中。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function drawObjects(objectsToDraw, overrideProgramInfo) {
  objectsToDraw.forEach(function(object) {
    const programInfo = overrideProgramInfo || object.programInfo;
    const bufferInfo = object.bufferInfo;

    gl.useProgram(programInfo.program);

    // 设置所有需要的 attributes
    webglUtils.setBuffersAndAttributes(gl, programInfo, bufferInfo);

    // 设置 uniforms.
    webglUtils.setUniforms(programInfo, object.uniforms);

    // 绘制图形
    gl.drawArrays(gl.TRIANGLES, 0, bufferInfo.numElements);
  });
}
</code></pre>
<p><code class="notranslate" translate="no">drawObjects</code> 中的可选参数 <code class="notranslate" translate="no">overrideProgramInfo</code> 让我们得以传入指定的着色器而不是对象自带的着色器。</p>
<p>我们要调用它两次，一次通过物体id绘制到纹理上，第二次绘制场景到画布上。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 绘制场景.
function drawScene(time) {
  time *= 0.0005;

  ...

  // 计算所有对象的矩阵.
  objects.forEach(function(object) {
    object.uniforms.u_matrix = computeMatrix(
        viewProjectionMatrix,
        object.translation,
        object.xRotationSpeed * time,
        object.yRotationSpeed * time);
  });

+  // ------ 将对象绘制到纹理 --------
+
+  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
+  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
+
+  gl.enable(gl.CULL_FACE);
+  gl.enable(gl.DEPTH_TEST);
+
+  // 清空画布和深度缓冲.
+  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
+
+  drawObjects(objectsToDraw, pickingProgramInfo);
+
+  // ------ 将对象绘制到画布
+
+  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
+  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
+
+  drawObjects(objectsToDraw);

  requestAnimationFrame(drawScene);
}
</code></pre>
<p>我们指定的着色器需要使用 <code class="notranslate" translate="no">u_id</code> 来设置物体 id ，我们在设置物体时将它添加到uniforms数据中.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 配置每个对象的信息
const baseHue = rand(0, 360);
const numObjects = 200;
for (let ii = 0; ii &lt; numObjects; ++ii) {
+  const id = ii + 1;
  const object = {
    uniforms: {
      u_colorMult: chroma.hsv(eMod(baseHue + rand(0, 120), 360), rand(0.5, 1), rand(0.5, 1)).gl(),
      u_matrix: m4.identity(),
+      u_id: [
+        ((id &gt;&gt;  0) &amp; 0xFF) / 0xFF,
+        ((id &gt;&gt;  8) &amp; 0xFF) / 0xFF,
+        ((id &gt;&gt; 16) &amp; 0xFF) / 0xFF,
+        ((id &gt;&gt; 24) &amp; 0xFF) / 0xFF,
+      ],
    },
    translation: [rand(-100, 100), rand(-100, 100), rand(-150, -50)],
    xRotationSpeed: rand(0.8, 1.2),
    yRotationSpeed: rand(0.8, 1.2),
  };
  objects.push(object);
  objectsToDraw.push({
    programInfo: programInfo,
    bufferInfo: shapes[ii % shapes.length],
    uniforms: object.uniforms,
  });
}
</code></pre>
<p>以上代码通过我们的<a href="webgl-less-code-more-fun.html">实用工具</a>来处理uniforms调用。</p>
<p>由于我们的目标纹理类型是 <code class="notranslate" translate="no">gl.RGBA</code>, <code class="notranslate" translate="no">gl.UNSIGNED_BYTE</code>，这里必须把id分解为 R, G, B, A 四个通道，每个通道容量为8bit。
8bit意味着只能容纳256个值，但是当我们将id分解为4通道，就拥有了32bit总容量，这对应着40亿以上个值。</p>
<p>我们把id + 1是因为在这里我们使用0代表“指针下没有东西”。</p>
<p>现在让我们高亮指针下的物体。</p>
<p>首先我们需要获取画布下的指针坐标。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// mouseX 和 mouseY 是CSS显示空间下画布中指针的相对位置
let mouseX = -1;
let mouseY = -1;

...

gl.canvas.addEventListener(&#39;mousemove&#39;, (e) =&gt; {
   const rect = canvas.getBoundingClientRect();
   mouseX = e.clientX - rect.left;
   mouseY = e.clientY - rect.top;
});
</code></pre>
<p>需要注意的是，上面代码中的 <code class="notranslate" translate="no">mouseX</code> 和 <code class="notranslate" translate="no">mouseY</code> 将返回CSS显示空间的像素位置。
这意味着他们在画布显示空间中，而不是画布渲染的像素空间。
换句话说，如果你有这样一个画布</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;canvas width=&quot;11&quot; height=&quot;22&quot; style=&quot;width:33px; height:44px;&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p>指针穿过画布时 <code class="notranslate" translate="no">mouseX</code> 将从0变化到33，而 <code class="notranslate" translate="no">mouseY</code> 将从0变化到44。<br>查看<a href="webgl-resizing-the-canvas.html">这个</a>以获得更多信息。</p>
<p>现在我们有了指针坐标，编写代码来找到指针下方的像素。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;
const data = new Uint8Array(4);
gl.readPixels(
    pixelX,            // x
    pixelY,            // y
    1,                 // width
    1,                 // height
    gl.RGBA,           // format
    gl.UNSIGNED_BYTE,  // type
    data);             // typed array to hold result
const id = data[0] + (data[1] &lt;&lt; 8) + (data[2] &lt;&lt; 16) + (data[3] &lt;&lt; 24);
</code></pre>
<p>后面的代码将 <code class="notranslate" translate="no">mouseX</code> 和 <code class="notranslate" translate="no">mouseY</code> 计算为 <code class="notranslate" translate="no">pixelX</code> 和 <code class="notranslate" translate="no">pixelY</code>，这表示从显示空间转换到了渲染空间。
换句话说，在上面的例子中，<code class="notranslate" translate="no">mouseX</code> 的范围是0到33， <code class="notranslate" translate="no">mouseY</code> 的范围是0到44，而转换后 <code class="notranslate" translate="no">pixelX</code> 的范围是0到11，<code class="notranslate" translate="no">pixelY</code> 的范围是0到22。</p>
<p>在实际代码中，使用我们的工具函数<code class="notranslate" translate="no">resizeCanvasToDisplaySize</code>来保持渲染纹理与画布的尺寸相同，所以显示尺寸和画布尺寸是一致的，至少我们为它们可能不一致的情况做了准备。</p>
<p>现在我们得到了一个id，为了确实突出被选中的物体，我们来改变渲染它到画布上的颜色。 我们使用的着色器有一个名为<code class="notranslate" translate="no">u_colorMult</code>的uniform可用。如果一个物体在鼠标下，我们会查找并保存它的<code class="notranslate" translate="no">u_colorMult</code>值，用被选中的颜色替换它，然后恢复它。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// mouseX 和 mouseY 是CSS显示空间下画布中指针的相对位置
let mouseX = -1;
let mouseY = -1;
+let oldPickNdx = -1;
+let oldPickColor;
+let frameCount = 0;

// 绘制场景
function drawScene(time) {
  time *= 0.0005;
+  ++frameCount;

  // ------ 把物体绘制到纹理上 --------

  ...

  // ------ 找到指针下的像素颜色并读取

  const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
  const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;
  const data = new Uint8Array(4);
  gl.readPixels(
      pixelX,            // x
      pixelY,            // y
      1,                 // width
      1,                 // height
      gl.RGBA,           // format
      gl.UNSIGNED_BYTE,  // type
      data);             // typed array to hold result
  const id = data[0] + (data[1] &lt;&lt; 8) + (data[2] &lt;&lt; 16) + (data[3] &lt;&lt; 24);

  // 恢复对象的颜色
  if (oldPickNdx &gt;= 0) {
    const object = objects[oldPickNdx];
    object.uniforms.u_colorMult = oldPickColor;
    oldPickNdx = -1;
  }

  // 高亮指针下的颜色
  if (id &gt; 0) {
    const pickNdx = id - 1;
    oldPickNdx = pickNdx;
    const object = objects[pickNdx];
    oldPickColor = object.uniforms.u_colorMult;
    object.uniforms.u_colorMult = (frameCount &amp; 0x8) ? [1, 0, 0, 1] : [1, 1, 0, 1];
  }

  // ------ 绘制对象到画布上
</code></pre>
<p>有了以上工作，我们在场景上移动鼠标时，鼠标下的物体就会闪烁。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-picking-w-gpu.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-picking-w-gpu.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>这里我们可以做一个优化，我们要把物品通过id渲染到与画布相同大小的纹理上。在概念上这是最容易做到的。</p>
<p>但是，我们可以只渲染鼠标下面的像素。为了做到这一点，我们使用一个只覆盖这个像素空间的视锥体。</p>
<p>到目前为止，对于3D处理，我们一直在使用一个叫做 <code class="notranslate" translate="no">perspective</code>(透视投影) 的函数，该函数将视场、长宽和近远平面的z值作为输入，并制作一个透视投影矩阵，将这些值所定义的视锥体转换为裁剪空间。</p>
<p>大多数三维数学库都有另一个叫做 <code class="notranslate" translate="no">frustum</code>(正交投影) 的函数，它需要6个值，近Z面的左、右、上、下值，然后是Z面的Z-近和Z-远值，并生成一个由这些值定义的投影矩阵。</p>
<p>利用上述方法，我们可以为鼠标下方的一个像素生成一个投影矩阵</p>
<p>首先，让我们计算近平面的边缘和大小，看看如果我们使用 <code class="notranslate" translate="no">perspective</code>功能，<em>会是</em>什么样子的</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 计算覆盖视锥体前方的近平面矩形尺寸
const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
const top = Math.tan(fieldOfViewRadians * 0.5) * near;
const bottom = -top;
const left = aspect * bottom;
const right = aspect * top;
const width = Math.abs(right - left);
const height = Math.abs(top - bottom);
</code></pre>
<p>所以 <code class="notranslate" translate="no">左</code>、<code class="notranslate" translate="no">右</code>、<code class="notranslate" translate="no">宽</code>、<code class="notranslate" translate="no">高</code> 是近平面的大小和位置。现在在这个平面上，我们可以计算出鼠标下此像素需要的视锥体大小和位置，并将其传递给<code class="notranslate" translate="no">frustum</code>函数，以生成一个只覆盖这一个像素的投影矩阵</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 计算近平面覆盖鼠标下1像素的部分
const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;

const subLeft = left + pixelX * width / gl.canvas.width;
const subBottom = bottom + pixelY * height / gl.canvas.height;
const subWidth = 1 / gl.canvas.width;
const subHeight = 1 / gl.canvas.height;

// 为此像素创建视锥体
const projectionMatrix = m4.frustum(
    subLeft,
    subLeft + subWidth,
    subBottom,
    subBottom + subHeight,
    near,
    far);
</code></pre>
<p>为了使用它，我们需要做一些改变。现在我们的着色器只接受 <code class="notranslate" translate="no">u_matrix</code>，这意味着为了用不同的投影矩阵绘图，我们需要在每一帧为每个物体重新计算矩阵两次，一次是用我们的正常投影矩阵绘制到画布上，另一次是用这个1像素的投影矩阵。</p>
<p>我们可以把这个乘法运算负担从 Javascript 转移到顶点着色器上。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;!-- vertex shader --&gt;
&lt;script id=&quot;3d-vertex-shader&quot; type=&quot;x-shader/x-vertex&quot;&gt;
attribute vec4 a_position;
attribute vec4 a_color;

-uniform mat4 u_matrix;
+uniform mat4 u_viewProjection;
+uniform mat4 u_world;

varying vec4 v_color;

void main() {
-  // 将位置坐标和矩阵相乘
-  gl_Position = u_matrix * a_position;
+  // 
+  gl_Position = u_viewProjection * u_world * a_position;

  // 将颜色传到片段着色器
  v_color = a_color;
}
&lt;/script&gt;

...

&lt;!-- vertex shader --&gt;
&lt;script id=&quot;pick-vertex-shader&quot; type=&quot;x-shader/x-vertex&quot;&gt;
attribute vec4 a_position;

-uniform mat4 u_matrix;
+uniform mat4 u_viewProjection;
+uniform mat4 u_world;

void main() {
-  // 将位置坐标和矩阵相乘
-  gl_Position = u_matrix * a_position;
+  // 将位置坐标和多个矩阵相乘
+  gl_Position = u_viewProjection * u_world * a_position;
}
&lt;/script&gt;
</code></pre>
<p>然后我们可以让我们的JavaScript计算出的<code class="notranslate" translate="no">viewProjectionMatrix</code>在所有对象之间共享。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const objectsToDraw = [];
const objects = [];
+const viewProjectionMatrix = m4.identity();

// 配置每个对象的信息
const baseHue = rand(0, 360);
const numObjects = 200;
for (let ii = 0; ii &lt; numObjects; ++ii) {
  const id = ii + 1;
  const object = {
    uniforms: {
      u_colorMult: chroma.hsv(eMod(baseHue + rand(0, 120), 360), rand(0.5, 1), rand(0.5, 1)).gl(),
-      u_matrix: m4.identity(),
+      u_world: m4.identity(),
+      u_viewProjection: viewProjectionMatrix,
      u_id: [
        ((id &gt;&gt;  0) &amp; 0xFF) / 0xFF,
        ((id &gt;&gt;  8) &amp; 0xFF) / 0xFF,
        ((id &gt;&gt; 16) &amp; 0xFF) / 0xFF,
        ((id &gt;&gt; 24) &amp; 0xFF) / 0xFF,
      ],
    },
    translation: [rand(-100, 100), rand(-100, 100), rand(-150, -50)],
    xRotationSpeed: rand(0.8, 1.2),
    yRotationSpeed: rand(0.8, 1.2),
  };
</code></pre>
<p>而在我们为每个物体计算矩阵的地方，我们不再纳入视图投影矩阵。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-function computeMatrix(viewProjectionMatrix, translation, xRotation, yRotation) {
-  let matrix = m4.translate(viewProjectionMatrix,
+function computeMatrix(translation, xRotation, yRotation) {
+  let matrix = m4.translation(
      translation[0],
      translation[1],
      translation[2]);
  matrix = m4.xRotate(matrix, xRotation);
  return m4.yRotate(matrix, yRotation);
}
...

// 为每一个物体计算矩阵
objects.forEach(function(object) {
  object.uniforms.u_world = computeMatrix(
-      viewProjectionMatrix,
      object.translation,
      object.xRotationSpeed * time,
      object.yRotationSpeed * time);
});
</code></pre>
<p>我们将创建一个只有1x1像素的纹理和深度缓冲。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">setFramebufferAttachmentSizes(1, 1);

...

// 绘制场景
function drawScene(time) {
  time *= 0.0005;
  ++frameCount;

-  if (webglUtils.resizeCanvasToDisplaySize(gl.canvas)) {
-    // 当canvas改变尺寸后，同步帧缓冲的尺寸
-    setFramebufferAttachmentSizes(gl.canvas.width, gl.canvas.height);
-  }
+  webglUtils.resizeCanvasToDisplaySize(gl.canvas);
</code></pre>
<p>然后在离屏渲染物体id之前，我们将使用我们的1像素投影矩阵，然后在画布上绘图时，我们将使用原始投影矩阵。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-// 计算投影矩阵
-const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
-const projectionMatrix =
-    m4.perspective(fieldOfViewRadians, aspect, 1, 2000);

// 使用 lookAt 函数计算相机的矩阵
const cameraPosition = [0, 0, 100];
const target = [0, 0, 0];
const up = [0, 1, 0];
const cameraMatrix = m4.lookAt(cameraPosition, target, up);

// 通过相机矩阵计算视图矩阵
const viewMatrix = m4.inverse(cameraMatrix);

-const viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);

// 为每个物体计算矩阵
objects.forEach(function(object) {
  object.uniforms.u_world = computeMatrix(
      object.translation,
      object.xRotationSpeed * time,
      object.yRotationSpeed * time);
});

// ------ 把物体渲染到纹理 --------

// 找到指针下的像素
// 并设置渲染此像素的视锥体

{
  // 计算覆盖视锥体前方的近平面矩形尺寸
  const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
  const top = Math.tan(fieldOfViewRadians * 0.5) * near;
  const bottom = -top;
  const left = aspect * bottom;
  const right = aspect * top;
  const width = Math.abs(right - left);
  const height = Math.abs(top - bottom);

  // 计算近平面覆盖鼠标下1像素的部分
  const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
  const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;

  const subLeft = left + pixelX * width / gl.canvas.width;
  const subBottom = bottom + pixelY * height / gl.canvas.height;
  const subWidth = 1 / gl.canvas.width;
  const subHeight = 1 / gl.canvas.height;

  // 为这个像素创建视锥体
  const projectionMatrix = m4.frustum(
      subLeft,
      subLeft + subWidth,
      subBottom,
      subBottom + subHeight,
      near,
      far);
+  m4.multiply(projectionMatrix, viewMatrix, viewProjectionMatrix);
}

gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
gl.viewport(0, 0, 1, 1);

gl.enable(gl.CULL_FACE);
gl.enable(gl.DEPTH_TEST);

// 清除画布和深度缓冲
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

drawObjects(objectsToDraw, pickingProgramInfo);

// 读取这1个像素
-const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
-const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;
const data = new Uint8Array(4);
gl.readPixels(
-    pixelX,            // x
-    pixelY,            // y
+    0,                 // x
+    0,                 // y
    1,                 // width
    1,                 // height
    gl.RGBA,           // format
    gl.UNSIGNED_BYTE,  // type
    data);             // typed array to hold result
const id = data[0] + (data[1] &lt;&lt; 8) + (data[2] &lt;&lt; 16) + (data[3] &lt;&lt; 24);

// 恢复物体的颜色
if (oldPickNdx &gt;= 0) {
  const object = objects[oldPickNdx];
  object.uniforms.u_colorMult = oldPickColor;
  oldPickNdx = -1;
}

// 高亮指针下的物体
if (id &gt; 0) {
  const pickNdx = id - 1;
  oldPickNdx = pickNdx;
  const object = objects[pickNdx];
  oldPickColor = object.uniforms.u_colorMult;
  object.uniforms.u_colorMult = (frameCount &amp; 0x8) ? [1, 0, 0, 1] : [1, 1, 0, 1];
}

// ------ 将物体绘制到画布上

+{
+  // 计算投影矩阵
+  const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
+  const projectionMatrix =
+      m4.perspective(fieldOfViewRadians, aspect, near, far);
+
+  m4.multiply(projectionMatrix, viewMatrix, viewProjectionMatrix);
+}

gl.bindFramebuffer(gl.FRAMEBUFFER, null);
gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

drawObjects(objectsToDraw);
</code></pre>
<p>现在你可以看到计算生效了，即使我们只渲染了一个像素，也依然能找到指针下的物体</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-picking-w-gpu-1pixel.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-picking-w-gpu-1pixel.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-picking.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-picking.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-picking.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-picking.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-picking.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-picking.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-picking.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-picking.html" selected>简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>基础概念</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-fundamentals.html">WebGL 基础概念</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-how-it-works.html">WebGL 工作原理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html">WebGL 着色器和GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL State Diagram</a></li>
        </ul>
  <li>图像处理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-image-processing.html">WebGL 图像处理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-image-processing-continued.html">WebGL 进一步处理图像</a></li>
        </ul>
  <li>二维平移，旋转，缩放和矩阵运算</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-translation.html">WebGL 二维平移</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-rotation.html">WebGL 二维旋转</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-scale.html">WebGL 二维缩放</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrices.html">WebGL 二维矩阵</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-orthographic.html">WebGL 三维正射投影</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective.html">WebGL 三维透视投影</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-camera.html">WebGL 三维相机</a></li>
        </ul>
  <li>光照</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-directional.html">WebGL 三维方向光源</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-point.html">WebGL 三维点光源</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-spot.html">WebGL 三维聚光灯</a></li>
        </ul>
  <li>组织和重构</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-less-code-more-fun.html">WebGL 码少趣多</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-multiple-things.html">WebGL 绘制多个物体</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-scene-graph.html">WebGL 场景图</a></li>
        </ul>
  <li>几何</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-geometry-lathe.html">WebGL 三维几何加工</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-load-obj.html">WebGL 加载 .obj 文件</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-load-obj-w-mtl.html">WebGL 加载带 .mtl 的 .obj 文件</a></li>
        </ul>
  <li>纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-textures.html">WebGL 三维纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-data-textures.html">WebGL 数据纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2-textures.html">WebGL 使用多个纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-cors-permission.html">WebGL 跨域图像</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective-correct-texturemapping.html">WebGL 纹理映射的透视纠正</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-planar-projection-mapping.html">平面的和透视的投影映射</a></li>
        </ul>
  <li>渲染到纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-render-to-texture.html">WebGL 渲染到纹理</a></li>
        </ul>
  <li>阴影</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-shadows.html">阴影</a></li>
        </ul>
  <li>技术</li>
        <ul>
            <li>二维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-drawimage.html">WebGL 二维DrawImage</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrix-stack.html">WebGL 二维矩阵栈</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-sprites.html">精灵</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-cube-maps.html">WebGL 立方体贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-environment-maps.html">WebGL 环境贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skybox.html">WebGL 天空盒</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skinning.html">WebGL 蒙皮</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-fog.html">WebGL 雾</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-picking.html">抓取 (点击的东西)</a></li>
        </ul>
  <li>文字</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-text-html.html">WebGL 文字 - HTML</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-canvas2d.html">WebGL 文字 - 二维Canvas</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-texture.html">WebGL 文字 - 使用纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-glyphs.html">WebGL 文字 - 使用字形纹理</a></li>
        </ul>
  <li>纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-ramp-textures.html">Ramp Textures (Toon Shading)</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>建议</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-smallest-programs.html">WebGL 最小的程序</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-without-data.html">无数据绘图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>优化</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-indexed-vertices.html">顶点索引 （gl.drawElements)</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-instanced-drawing.html">实例化绘制</a></li>
        </ul>
  <li>杂项</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-setup-and-installation.html">WebGL 设置和安装</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-boilerplate.html">WebGL 样板</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html">WebGL 重置画布尺寸</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-animation.html">WebGL 动画</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-points-lines-triangles.html">WebGL 点、线和三角</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-visualizing-the-camera.html">可视化相机</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-and-alpha.html">WebGL 和阿尔法通道</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-vs-3d-library.html">WebGL 2D vs 3D 库</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-anti-patterns.html">WebGL 错误模式</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-matrix-vs-math.html">WebGL 矩阵 vs 数学中的矩阵</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#screenshot">截屏</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#preservedrawingbuffer">防止画布被清空</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#tabindex">在画布中获取键盘输入</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#html-background">将 WebGL 作为 HTML 的背景</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-cross-platform-issues.html">WebGL 跨平台相关问题</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>参考</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-attributes.html">WebGL 属性</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-texture-units.html">WebGL 纹理单元</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-framebuffers.html">WebGL 帧缓冲</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-readpixels.html">WebGL readPixels</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-references.html">WebGL 参考</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API 帮助文档</a></li>
  <li><a href="https://twgljs.org">TWGL, 一个轻量级WebGL辅助库</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
    <div>有疑问? <a href="https://stackoverflow.com/questions/tagged/webgl">在stackoverflow上提问</a>.</div>
    <div>Issue/Bug? <a href="https://github.com/gfxfundamentals/webgl-fundamentals/issues">在GitHub上提issue</a>.</div>
    <div class="lesson-comment-notes">
       使用 <b>&lt;pre&gt;&lt;code&gt;</b> 代码 <b>&lt;/code&gt;&lt;/pre&gt;</b> 的格式编写代码块
    </div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL 抓取';
            var disqus_title = 'WebGL 抓取';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "感谢 <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>的 <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} 次贡献</a>",
  owner: "gfxfundamentals",
  repo: "webgl-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>



