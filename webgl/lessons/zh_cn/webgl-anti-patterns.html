<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/zh_cn/webgl-anti-patterns.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="WebGL中不应该这么做，为什么，应该这么做。">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-anti-patterns_zh-cn.jpg">

<meta property="og:title" content="WebGL 反面模式">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-anti-patterns_zh-cn.jpg">
<meta property="og:description" content="WebGL中不应该这么做，为什么，应该这么做。">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-anti-patterns.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGL 反面模式">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-anti-patterns.html">
<meta name="twitter:description" content="WebGL中不应该这么做，为什么，应该这么做。">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-anti-patterns_zh-cn.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-anti-patterns.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-anti-patterns_zh-cn.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-anti-patterns.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-anti-patterns.html",
      "inLanguage":"zh-cn",
      "name":"WebGL 反面模式",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-anti-patterns.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL 反面模式</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-anti-patterns.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-anti-patterns.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-anti-patterns.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-anti-patterns.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-anti-patterns.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-anti-patterns.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-anti-patterns.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-anti-patterns.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-anti-patterns.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-anti-patterns.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-anti-patterns.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-anti-patterns.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-anti-patterns.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-anti-patterns.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-anti-patterns.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-anti-patterns.html" selected>简体中文</a>
</select>


    <a href="#toc">目录</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/zh_cn/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL 反面模式</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>这里是一些WebGL的反面模式，反面模式就是一些你应该避免的做法</p>
<ol>
<li><p>将 <code class="notranslate" translate="no">viewportWidth</code> 和 <code class="notranslate" translate="no">viewportHeight</code> 属性放在 <code class="notranslate" translate="no">WebGLRenderingContext</code> 对象上。</p>
<p>有些代码添加了视图宽度和高度属性，并将它附加在 <code class="notranslate" translate="no">WebGLRenderingContext</code> 上，像这样</p>
<pre class="prettyprint">
gl = canvas.getContext("webgl");
gl.viewportWidth = canvas.width;    // 不好!!!
gl.viewportHeight = canvas.height;  // 不好!!!
</pre>

<p>然后可以做这样的操作</p>
<pre class="prettyprint">
gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
</pre>

<p><strong>为什么这样不好:</strong></p>
<p>主要的错误就是多了两个属性，并且需要在画布尺寸改变的时候更新这些属性。
假如你将画布的宽高设置为某值，但当用户改变窗口大小时 <code class="notranslate" translate="no">gl.viewportWidth</code> &amp; <code class="notranslate" translate="no">gl.viewportHeight</code>
就不是正确的值，你就需要重新设置它们。</p>
<p>其次是假如一些WebGL新手看到你的代码，会把 <code class="notranslate" translate="no">gl.viewportWidth</code> 和 <code class="notranslate" translate="no">gl.viewportHeight</code>
当作WebGL规范的一部分，会给他们带来长时间影响或困惑。</p>
<p><strong>应该怎么做:</strong></p>
<p>为什么自己给自己找麻烦？WebGL上下文有它的宽和高，直接使用就行。</p>
<pre class="prettyprint">
// 当你需要保持视图和画布的 drawingBuffer 大小一致，
// 这样做永远都是对的
gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
</pre>

<p>甚至能解决使用 <code class="notranslate" translate="no">gl.canvas.width</code> 和 <code class="notranslate" translate="no">gl.canvas.height</code> 时无法解决的情况。
<a href="#drawingbuffer">具体原因看这里</a>。</p>
</li>
<li><p>使用 <code class="notranslate" translate="no">canvas.width</code> 和 <code class="notranslate" translate="no">canvas.height</code> 计算长宽比</p>
<p>经常有代码使用 <code class="notranslate" translate="no">canvas.width</code> 和 <code class="notranslate" translate="no">canvas.height</code> 计算长宽比，像这样 </p>
<pre class="prettyprint">
var aspect = canvas.width / canvas.height;
perspective(fieldOfView, aspect, zNear, zFar);
</pre>

<p><strong>为什么这样不好:</strong></p>
<p>画布的宽和高属性与画布的显示尺寸无关，CSS控制画布的显示尺寸。</p>
<p><strong>应该怎么做:</strong></p>
<p>使用 <code class="notranslate" translate="no">canvas.clientWidth</code> 和 <code class="notranslate" translate="no">canvas.clientHeight</code>，这些值可以告诉你画布显示在屏幕上的实际尺寸。
这样就可以不用关心CSS设置，得到正确的长宽比。</p>
<pre class="prettyprint">
var aspect = canvas.clientWidth / canvas.clientHeight;
perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);
</pre>

<p>这有一些示例，使用大小相同(<code class="notranslate" translate="no">width=&quot;400&quot; height=&quot;300&quot;</code>)的画布，
但是用CSS告诉浏览器显示不同的尺寸，注意示例中的所有 &#39;F&#39; 都有正确的长宽比。</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 150px; height: 200px;" src="/webgl/lessons/../webgl-canvas-clientwidth-clientheight.html"></iframe>
</div>


<p></p>
<div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 400px; height: 150px;" src="/webgl/lessons/../webgl-canvas-clientwidth-clientheight.html"></iframe>
</div>

</p>
<p>如果我们使用 <code class="notranslate" translate="no">canvas.width</code> 和 <code class="notranslate" translate="no">canvas.height</code>，结果就不是正确的了。</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 150px; height: 200px;" src="/webgl/lessons/../webgl-canvas-width-height.html"></iframe>
</div>


<p></p>
<div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 400px; height: 150px;" src="/webgl/lessons/../webgl-canvas-width-height.html"></iframe>
</div>

</p>
</li>
<li><p>使用 <code class="notranslate" translate="no">window.innerWidth</code> 和 <code class="notranslate" translate="no">window.innerHeight</code>计算任何东西</p>
<p>大多数WebGL应用在任何地方都使用 <code class="notranslate" translate="no">window.innerWidth</code> 和 <code class="notranslate" translate="no">window.innerHeight</code>。
例如：</p>
<pre class="prettyprint">
canvas.width = window.innerWidth;                    // 不好!!
canvas.height = window.hinnerHeight;                 // 不好!!
</pre>

<p><strong>为什么这样不好:</strong></p>
<p>这样不灵活。是的，它可以在需要的时候将画布填满窗口，问题是如果你不想这么做了，
也许你想在一个文章像这篇教程一样，加入一个画布当作图表展示。或者你可能需要一个侧边的编辑器，计分板之类的布局。
当然你可以修改代码解决应对这些情况，但是为什么不在一开始就让它适应这些情况？
这样就不需要在新项目中修改所有的相关代码。</p>
<p><strong>应该怎么做:</strong></p>
<p>使用Web平台而不是对抗Web平台，它有自己的设计模式。
使用CSS和 <code class="notranslate" translate="no">clientWidth</code> 和 <code class="notranslate" translate="no">clientHeight</code>。</p>
<pre class="prettyprint">
var width = gl.canvas.clientWidth;
var height = gl.canvas.clientHeight;

gl.canvas.width = width;
gl.canvas.height = height;
</pre>

<p>这有 9 个例子，都使用相同的代码，注意它们中没有一个使用了 <code class="notranslate" translate="no">window.innerWidth</code> 或 <code class="notranslate" translate="no">window.innerHeight</code>。</p>
<p><a href="../../webgl-same-code-canvas-fullscreen.html" target="_blank">使用CSS让一个画布全屏</a></p>
<p><a href="../../webgl-same-code-canvas-partscreen.html" target="_blank">使画布宽度为 70%，给编辑器留下空间</a></p>
<p><a href="../../webgl-same-code-canvas-embedded.html" target="_blank">将画布嵌入到段落中</a></p>
<p><a href="../../webgl-same-code-canvas-embedded-border-box.html" target="_blank">使用<code class="notranslate" translate="no">box-sizing: border-box;</code>将画布嵌入到段落中</a></p>
<p><code class="notranslate" translate="no">box-sizing: border-box;</code>将边框和内边距算入元素，而不是算在外面。换句话说，普通的盒模型定义一个 400x300 像素的元素，
边框为 15 像素，实际内容部分为 400x300 像素，并且外边有一个 15 像素宽的边框，这样总共就是 430x330 像素。在 box-sizing: border-box 模式下，
边框算在内部，所以内容部分就为 370x270 像素，这也是使用 <code class="notranslate" translate="no">clientWidth</code> 和 <code class="notranslate" translate="no">clientHeight</code> 的另一个重要原因。如果设置边框为 <code class="notranslate" translate="no">1em</code>，
你就没办法知道画布的最终尺寸，它在不同的浏览器和字体下都不同。</p>
<p><a href="../../webgl-same-code-container-fullscreen.html" target="_blank">使用CSS控制容器全屏，并使用代码插入一个画布到容器中</a></p>
<p><a href="../../webgl-same-code-container-partscreen.html" target="_blank">使用一个宽度为 70% 的容器，并使用代码插入一个画布到容器中</a></p>
<p><a href="../../webgl-same-code-container-embedded.html" target="_blank">在段落中嵌入一个容器，并使用代码插入一个画布到容器中</a></p>
<p><a href="../../webgl-same-code-container-embedded-border-box.html" target="_blank">使用 <code class="notranslate" translate="no">box-sizing: border-box;</code>在段落中嵌入一个容器，并使用代码插入一个画布到容器中</a></p>
<p><a href="../../webgl-same-code-body-only-fullscreen.html" target="_blank">一个页面使用CSS设置为全屏，并使用代码插入一个画布到页面中</a></p>
<p>重点是，如果你拥抱Web技术并使用上面的技巧，就可以在多种情况中不需要改变代码。</p>
</li>
<li><p>使用 <code class="notranslate" translate="no">&#39;resize&#39;</code> 事件改变画布的大小</p>
<p>有些应用监听窗口的 <code class="notranslate" translate="no">&#39;resize&#39;</code> 事件，像这样去重置画布大小。</p>
<pre class="prettyprint">
window.addEventListener('resize', resizeTheCanvas);
</pre>

<p>或这样</p>
<pre class="prettyprint">
window.onresize = resizeTheCanvas;
</pre>

<p><strong>为什么这样不好:</strong></p>
<p>这样本身没什么问题，然而，对于<strong>大多数</strong>WebGL应用，它适用的情况比较少。
尤其是 <code class="notranslate" translate="no">&#39;resize&#39;</code> 只有在窗口重置大小的时候才能触发。在其他情况下画布改变大小就不管用了，
例如假设要制作一个三维编辑器，画布在左侧设置在右侧，你使用了一个拖动条可以改变两个部分的大小，
在这种情况下你不会得到任何 <code class="notranslate" translate="no">&#39;resize&#39;</code> 事件，相似的，如果一个页面中添加和移除一些内容，
你也不会得到重置大小事件。</p>
<p><strong>应该怎么做:</strong></p>
<p>像大多数其他反面模式一样，可以用一种更通用的方式应多多种情况。
对于WebGL应用则需要在绘制每一帧之前检查是否需要重置画布大小，
像这样</p>
<pre class="prettyprint">
function resize() {
  var width = gl.canvas.clientWidth;
  var height = gl.canvas.clientHeight;
  if (gl.canvas.width != width ||
      gl.canvas.height != height) {
     gl.canvas.width = width;
     gl.canvas.height = height;
  }
}

function render() {
   resize();
   drawStuff();
   requestAnimationFrame(render);
}
render();
</pre>

<p>现在在这些情况下你都可以得到正确地尺寸，不需要修改任何代码。
例如使用上方 #3 的方法，制作一个可修改大小的编辑区。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-same-code-resize.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-same-code-resize.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>这里没有重置大小事件或者其他画布重置大小触发的事件，只需要基于页面元素的大小动态改变尺寸。</p>
<p>对于不需要持续绘制的WebGL应用，只需要在画布可能改变大小的地方触发重绘。
一种简单的方式是使用 requestAnimationFrame 循环，像这样</p>
<pre class="prettyprint">
function resize() {
  var width = gl.canvas.clientWidth;
  var height = gl.canvas.clientHeight;
  if (gl.canvas.width != width ||
      gl.canvas.height != height) {
     gl.canvas.width = width;
     gl.canvas.height = height;
     return true;
  }
  return false;
}

var needToRender = true;  // 至少绘制一次
function checkRender() {
   if (resize() || needToRender) {
     needToRender = false;
     drawStuff();
   }
   requestAnimationFrame(checkRender);
}
checkRender();
</pre>

<p>这样每当 <code class="notranslate" translate="no">needToRender</code> 为true时就会重置画布大小。
这样在不需要持续绘制的应用中，就能处理画布问题。只需要在场景需要重新绘制时设置 <code class="notranslate" translate="no">needToRender</code> 为true。</p>
</li>
<li><p>给 <code class="notranslate" translate="no">WebGLObject</code> 添加属性</p>
<p><code class="notranslate" translate="no">WebGLObject</code> 是WebGL资源中的多种类型，比如 <code class="notranslate" translate="no">WebGLBuffer</code> 或 <code class="notranslate" translate="no">WebGLTexture</code>。
一些应用为这些属性对象添加属性，例如像这样：</p>
<pre class="prettyprint">
var buffer = gl.createBuffer();
buffer.itemSize = 3;        // 不好!!
buffer.numComponents = 75;  // 不好!!

var program = gl.createProgram();
...
program.u_matrixLoc = gl.getUniformLocation(program, "u_matrix");  // 不好!!
</pre>

<p><strong>为什么这样不好:</strong></p>
<p>原因是WebGL可能“丢失上下文”，这样在大多数情况下没问题，但假如浏览器发现太多GPU资源被使用时，
可能会故意丢失<code class="notranslate" translate="no">WebGLRenderingContext</code>的上下文用来释放一些空间，
WebGL应用需要处理这样情况，比如 Google 地图。</p>
<p>上方代码的问题是当上下文丢失，WebGL创建方法比如 <code class="notranslate" translate="no">gl.createBuffer()</code> 会返回 <code class="notranslate" translate="no">null</code>。
等于让代码变成这样</p>
<pre class="prettyprint">
var buffer = null;
buffer.itemSize = 3;        // 错误!
buffer.numComponents = 75;  // 错误!
</pre>

<p>这样错误就会终止你的应用，像这样</p>
<pre class="prettyprint">
TypeError: Cannot set property 'itemSize' of null
</pre>

<p>尽管很多应用不关心丢失上下文后是否会中断，但在后续更新中才想到解决这个问题似乎就不是那么好了。</p>
<p><strong>应该怎么做:</strong></p>
<p>如果你想让 <code class="notranslate" translate="no">WebGLObjects</code> 和一些相关信息关联，应该使用 JavaScript 对象，例如：</p>
<pre class="prettyprint">
var bufferInfo = {
  id: gl.createBuffer(),
  itemSize: 3,
  numComponents: 75,
};

var programInfo = {
  id: program,
  u_matrixLoc: gl.getUniformLocation(program, "u_matrix"),
};
</pre>

<p>个人建议<a href="webgl-less-code-more-fun.html">使用一些简单的辅助方法让编写WebGL更简单</a>。</p>
</li>
</ol>
<p>这些是我想到的一些WebGL的反面模式，希望我的例子能够解释清楚为什么要避免以及如何解决。</p>
<div class="webgl_bottombar"><a id="drawingbuffer"></a><h3>drawingBufferWidth 和 drawingBufferHeight 是什么？</h3>
<p>
GPU对矩形像素值(纹理, renderbuffer)的支持有限制。通常这个大小是GPU生产时常用显示器分辨率的下一个2的整数次幂。
假如一个GPU设计用于 1280x1024 的屏幕，那么它的限制可能就是 2048 像素。
如果设计用于 2560x1600 的屏幕，限制可能是 4096 像素。
</p><p>
这样似乎很合理，但是如果你有多个显示器怎么办？假设我们有一个限制为 2048 的GPU，但是有两个 1920x1080 的显示器。
你的代码想要设置<code class="notranslate" translate="no">canvas.width</code>为<code class="notranslate" translate="no">canvas.width</code>也就是 3840，会发生什么？</p>
<p>我想到的只有三种情况</p>
<ol>
<li>
 <p>抛出异常</p>
 <p>这似乎很不好，大多数网页应用不会检查这个并且会崩溃。如果应用中有用户数据，用户就会丢失他们的数据。</p>
</li>
<li>
 <p>限制画布大小为GPU的限制大小</p>
 <p>这种情况可能也会导致崩溃或者把网页搞得混乱，因为代码期望画布大小为请求的大小，并且对其他UI元素做了对应调整。
</p>
</li>
<li>
 <p>让画布的大小成为用户请求的大小但drawingbuffer为限制大小</p>
 <p>
 这就是WebGL使用的方式，如果你的代码编写正确，用户只会注意到画布中的图像被明显缩放。
 不然就是不崩溃，只有用户将它放在一个窗口后才会显示正确的内容。</p>
</li>
</ol>
<p>
大多数用户不使用多个显示器，所以这个问题很少出现。至少在Chrome和Safari上，2015年一月之后，
将画布尺寸硬编码限制为 4096。苹果的 5K iMac 受到了这个限制。大多数WebGL应用因为这个原因出现奇怪的显示结果。
同样的很多开始学习WebGL的人，在使用多个显示器时会触发这个限制。</p>
<p>
所以，如果你想处理这些情况就像 #1 一样使用<code class="notranslate" translate="no">gl.drawingBufferWidth</code> 和 <code class="notranslate" translate="no">gl.drawingBufferHeight</code>。
对于大多数应用使用上方的设置就没什么问题。要注意的是如果你需要计算一些东西的话，就要通过这个知道drawingbuffer的实际尺寸，
并将它带入计算。例如选择物体，换句话说从鼠标坐标转换到画布像素坐标。另一种就是任何一种需要知道drawingbuffer实际大小的后处理效果。
</p>
</div>







    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-anti-patterns.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-anti-patterns.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-anti-patterns.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-anti-patterns.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-anti-patterns.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-anti-patterns.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-anti-patterns.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-anti-patterns.html" selected>简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>基础概念</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-fundamentals.html">WebGL 基础概念</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-how-it-works.html">WebGL 工作原理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html">WebGL 着色器和GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL State Diagram</a></li>
        </ul>
  <li>图像处理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-image-processing.html">WebGL 图像处理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-image-processing-continued.html">WebGL 进一步处理图像</a></li>
        </ul>
  <li>二维平移，旋转，缩放和矩阵运算</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-translation.html">WebGL 二维平移</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-rotation.html">WebGL 二维旋转</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-scale.html">WebGL 二维缩放</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrices.html">WebGL 二维矩阵</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-orthographic.html">WebGL 三维正射投影</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective.html">WebGL 三维透视投影</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-camera.html">WebGL 三维相机</a></li>
        </ul>
  <li>光照</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-directional.html">WebGL 三维方向光源</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-point.html">WebGL 三维点光源</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-spot.html">WebGL 三维聚光灯</a></li>
        </ul>
  <li>组织和重构</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-less-code-more-fun.html">WebGL 码少趣多</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-multiple-things.html">WebGL 绘制多个物体</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-scene-graph.html">WebGL 场景图</a></li>
        </ul>
  <li>几何</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-geometry-lathe.html">WebGL 三维几何加工</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-load-obj.html">WebGL 加载 .obj 文件</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-load-obj-w-mtl.html">WebGL 加载带 .mtl 的 .obj 文件</a></li>
        </ul>
  <li>纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-textures.html">WebGL 三维纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-data-textures.html">WebGL 数据纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2-textures.html">WebGL 使用多个纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-cors-permission.html">WebGL 跨域图像</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective-correct-texturemapping.html">WebGL 纹理映射的透视纠正</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-planar-projection-mapping.html">平面的和透视的投影映射</a></li>
        </ul>
  <li>渲染到纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-render-to-texture.html">WebGL 渲染到纹理</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>技术</li>
        <ul>
            <li>二维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-drawimage.html">WebGL 二维DrawImage</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrix-stack.html">WebGL 二维矩阵栈</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-sprites.html">精灵</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-cube-maps.html">WebGL 立方体贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-environment-maps.html">WebGL 环境贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skybox.html">WebGL 天空盒</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skinning.html">WebGL 蒙皮</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-fog.html">WebGL 雾</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>文字</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-text-html.html">WebGL 文字 - HTML</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-canvas2d.html">WebGL 文字 - 二维Canvas</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-texture.html">WebGL 文字 - 使用纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-glyphs.html">WebGL 文字 - 使用字形纹理</a></li>
        </ul>
  <li>纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-ramp-textures.html">Ramp Textures (Toon Shading)</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-smallest-programs.html">WebGL 最小的程序</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-indexed-vertices.html">顶点索引 （gl.drawElements)</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-instanced-drawing.html">实例化绘制</a></li>
        </ul>
  <li>杂项</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-setup-and-installation.html">WebGL 设置和安装</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-boilerplate.html">WebGL 样板</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html">WebGL 重置画布尺寸</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-animation.html">WebGL 动画</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-points-lines-triangles.html">WebGL 点、线和三角</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-visualizing-the-camera.html">可视化相机</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-and-alpha.html">WebGL 和阿尔法通道</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-vs-3d-library.html">WebGL 2D vs 3D 库</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-anti-patterns.html">WebGL 错误模式</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-matrix-vs-math.html">WebGL 矩阵 vs 数学中的矩阵</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#screenshot">截屏</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#preservedrawingbuffer">防止画布被清空</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#tabindex">在画布中获取键盘输入</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#html-background">将 WebGL 作为 HTML 的背景</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-cross-platform-issues.html">WebGL 跨平台相关问题</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-attributes.html">WebGL 属性</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-texture-units.html">WebGL 纹理单元</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-framebuffers.html">WebGL 帧缓冲</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-readpixels.html">WebGL readPixels</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-references.html">WebGL 参考</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API 帮助文档</a></li>
  <li><a href="https://twgljs.org">TWGL, 一个轻量级WebGL辅助库</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>有关于WebGL的疑问? <a href="https://stackoverflow.com/questions/tagged/webgl">在Stackoverflow提问</a>。</div>
        <div>有意见或建议? <a href="https://github.com/vinci-mz/webgl-fundamentals/issues">在GitHub上提issue</a>。</div>

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL 反面模式';
            var disqus_title = 'WebGL 反面模式';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
      return;
  }

  function addScript(src, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  addScript('//cdn.webglstats.com/stat.js');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>



