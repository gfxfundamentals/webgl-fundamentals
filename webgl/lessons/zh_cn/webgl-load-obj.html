<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/zh_cn/webgl-load-obj.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="如何解析并显示 .obj 文件">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-load-obj_zh-cn.jpg">

<meta property="og:title" content="WebGL 加载 .obj 文件">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-load-obj_zh-cn.jpg">
<meta property="og:description" content="如何解析并显示 .obj 文件">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-load-obj.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGL 加载 .obj 文件">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-load-obj.html">
<meta name="twitter:description" content="如何解析并显示 .obj 文件">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-load-obj_zh-cn.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-load-obj.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-load-obj_zh-cn.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-load-obj.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-load-obj.html",
      "inLanguage":"zh-cn",
      "name":"WebGL 加载 .obj 文件",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-load-obj.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL 加载 .obj 文件</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-load-obj.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-load-obj.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-load-obj.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-load-obj.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-load-obj.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-load-obj.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-load-obj.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-load-obj.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-load-obj.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-load-obj.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-load-obj.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-load-obj.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-load-obj.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-load-obj.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-load-obj.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-load-obj.html" selected>简体中文</a>
</select>


    <a href="#toc">目录</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/zh_cn/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub a {
    background: #000;
    color: #fff;
    text-decoration: none;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 2rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 300px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(150px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a:hover {
    background: #c11;
    color: #fff;
}
#forkongithub a::before,#forkongithub a::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub a::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
@media (max-width: 900px) {
    #forkongithub a{
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub a{
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL 加载 .obj 文件</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Wavefront 的 .obj 文件是网上最常用的 3D 文件格式。
它们并不是难以解析的格式，所以让我们试试。这能够提供一个解析 3D 文件的有用例子。</p>
<p><strong>免责申明</strong> 该 .obj 解析器不会面面俱到或者完美，也不保证能够处理所有 .obj 文件。
这只是一个练习。如果你使用该程序并遇到问题，下面的链接可能会对你有帮助。</p>
<p>我找到的有关 .obj 文件的文档 <a href="http://paulbourke.net/dataformats/obj/">这里</a>。
不过 <a href="https://www.loc.gov/preservation/digital/formats/fdd/fdd000507.shtml">这里</a>
链接了很多其它相关文档，包括 <a href="http://www.cs.utah.edu/~/boulos/cs3505/obj_spec.pdf">原始文档</a>。</p>
<p>让我们看一个简单的例子。下面是从 blender 默认场景中导出的 cube.obj：</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-txt"># Blender v2.80 (sub 75) OBJ File: &#39;&#39;
# www.blender.org
mtllib cube.mtl
o Cube
v 1.000000 1.000000 -1.000000
v 1.000000 -1.000000 -1.000000
v 1.000000 1.000000 1.000000
v 1.000000 -1.000000 1.000000
v -1.000000 1.000000 -1.000000
v -1.000000 -1.000000 -1.000000
v -1.000000 1.000000 1.000000
v -1.000000 -1.000000 1.000000
vt 0.375000 0.000000
vt 0.625000 0.000000
vt 0.625000 0.250000
vt 0.375000 0.250000
vt 0.375000 0.250000
vt 0.625000 0.250000
vt 0.625000 0.500000
vt 0.375000 0.500000
vt 0.625000 0.750000
vt 0.375000 0.750000
vt 0.625000 0.750000
vt 0.625000 1.000000
vt 0.375000 1.000000
vt 0.125000 0.500000
vt 0.375000 0.500000
vt 0.375000 0.750000
vt 0.125000 0.750000
vt 0.625000 0.500000
vt 0.875000 0.500000
vt 0.875000 0.750000
vn 0.0000 1.0000 0.0000
vn 0.0000 0.0000 1.0000
vn -1.0000 0.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 0.0000 -1.0000
usemtl Material
s off
f 1/1/1 5/2/1 7/3/1 3/4/1
f 4/5/2 3/6/2 7/7/2 8/8/2
f 8/8/3 7/7/3 5/9/3 6/10/3
f 6/10/4 2/11/4 4/12/4 8/13/4
f 2/14/5 1/15/5 3/16/5 4/17/5
f 6/18/6 5/19/6 1/20/6 2/11/6
</code></pre>
<p>即使不看文档我们也能发现 <code class="notranslate" translate="no">v</code> 开始的行表示顶点，<code class="notranslate" translate="no">vt</code> 开始的行表示纹理座标，
<code class="notranslate" translate="no">vn</code> 开始的行表示法线。接下来就是理解剩下的代表什么。</p>
<p>看起来 .obj 文件是文本文件，所以我们要做的第一件事就是加载文本文件。
幸运的是，如果使用 <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await">async/await</a> 这将是一件很简单的事。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">async function main() {
  ...

  const response = await fetch(&#39;resources/models/cube/cube.obj&#39;);
  const text = await response.text();
}
</code></pre>
<p>接着，我们可以一行一行地解析，每行都是下面的形式:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">keyword data data data ...
</code></pre><p>每行的开头是 keyword，data 由空格隔开。以 <code class="notranslate" translate="no">#</code> 开头的行是注释。</p>
<p>接着，用代码来解析每一行，跳过空白行和注释，然后根据 keyword 调用对应的函数。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function parseOBJ(text) {

  const keywords = {
  };

  const keywordRE = /(\w*)(?: )*(.*)/;
  const lines = text.split(&#39;\n&#39;);
  for (let lineNo = 0; lineNo &lt; lines.length; ++lineNo) {
    const line = lines[lineNo].trim();
    if (line === &#39;&#39; || line.startsWith(&#39;#&#39;)){
      continue;
    }
    const m = keywordRE.exec(line);
    if (!m) {
      continue;
    }
    const [, keyword, unparsedArgs] = m;
    const parts = line.split(/\s+/).slice(1);
    const handler = keywords[keyword];
    if (!handler) {
      console.warn(&#39;unhandled keyword:&#39;, keyword, &#39; at line&#39;, lineNo + 1);
      continue;
    }
    handler(parts, unparsedArgs);
  }
}
</code></pre>
<p>注意：我们去除了每行开头和结尾的空格。
我不知道这是否有必要，但是我觉得没有坏处。
我们用 <code class="notranslate" translate="no">/\s+/</code> 将每行以空格分割。
同样地我不知道这是否有必要，data 之间会有多于一个空格吗？是否可以是制表符？
不知道，但是这样看起来更安全。</p>
<p>另外，我们将每行的第一部分作为 keyword，然后找到对应的函数调用，
并将 keyword 后面的 data 传给该函数。所以接下来我们只要完成这些函数。</p>
<p>之前，我们猜测了 <code class="notranslate" translate="no">v</code>，<code class="notranslate" translate="no">vt</code> 和 <code class="notranslate" translate="no">vn</code> 的含义。
文档表明 <code class="notranslate" translate="no">f</code> 代表“面”或多边形，每部分数据代表了顶点、纹理座标以及法线。</p>
<p>如果一个索引是正数，表示从序列 1 开始的偏移。
如果索引是负数，表示从序列结尾开始的偏移。
索引的顺序是：顶点/纹理座标/法线，只有顶点是必要的。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-txt">f 1 2 3             # 只包含顶点索引
f 1/1 2/2 3/3       # 包含顶点索引和纹理座标索引
f 1/1/1 2/2/2 3/3/3 # 包含顶点索引、纹理座标索引和法线索引
f 1//1 2//2 3//3    # 包含顶点索引和法线索引
</code></pre>
<p><code class="notranslate" translate="no">f</code> 可以有多于 3 个顶点，比如 4 个顶点代表四边形。
WebGL 只能绘制三角形，所以需要将数据转换成三角形。
标准并没有规定说一个面可以有多于 4 个顶点，也没有说面必须是凹的或凸的。
但暂时让我们假设面是凹的。</p>
<p>通常在 WebGL 中，我们不单独说明顶点、纹理座标和法线，“webgl 顶点”代表了包含了代表该顶点的顶点座标、纹理座标、法线的数据集合。
例如，要绘制一个立方体，WebGL 需要 36 个顶点，每个面是两个三角形，每个三角形是 3 个顶点。
6 个面 <em> 每个面 2 个三角形 </em> 每个三角形 3 个顶点 = 36 个顶点。
尽管一个立方体只有 8 个不重复的顶点和 6 条不重复的法线。
所以，我们需要读取面的顶点索引来生成包含了顶点位置、纹理座标、法线的“webgl 顶点”。
<a href="webgl-pulling-vertices.html">*</a></p>
<p>所以，根据上面的描述，我们可以像下面这样解析：</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function parseOBJ(text) {
+  // 因为索引是从 1 开始的，所以填充索引为 0 的位置
+  const objPositions = [[0, 0, 0]];
+  const objTexcoords = [[0, 0]];
+  const objNormals = [[0, 0, 0]];
+
+  // 和 `f` 一样的索引顺序
+  const objVertexData = [
+    objPositions,
+    objTexcoords,
+    objNormals,
+  ];
+
+  // 和 `f` 一样的索引顺序
+  let webglVertexData = [
+    [],   // 顶点
+    [],   // 纹理座标
+    [],   // 法线
+  ];
+
+  function addVertex(vert) {
+    const ptn = vert.split(&#39;/&#39;);
+    ptn.forEach((objIndexStr, i) =&gt; {
+      if (!objIndexStr) {
+        return;
+      }
+      const objIndex = parseInt(objIndexStr);
+      const index = objIndex + (objIndex &gt;= 0 ? 0 : objVertexData[i].length);
+      webglVertexData[i].push(...objVertexData[i][index]);
+    });
+  }
+
  const keywords = {
+    v(parts) {
+      objPositions.push(parts.map(parseFloat));
+    },
+    vn(parts) {
+      objNormals.push(parts.map(parseFloat));
+    },
+    vt(parts) {
+      objTexcoords.push(parts.map(parseFloat));
+    },
+    f(parts) {
+      const numTriangles = parts.length - 2;
+      for (let tri = 0; tri &lt; numTriangles; ++tri) {
+        addVertex(parts[0]);
+        addVertex(parts[tri + 1]);
+        addVertex(parts[tri + 2]);
+      }
+    },
  };
</code></pre>
<p>上面的代码创建了 3 个数组来保存从 object 文件中解析出来的顶点位置、纹理座标和法线。
同时创建了 3 个数组来保存 WebGL 的顶点。为了方便引用，数组的顺序和 <code class="notranslate" translate="no">f</code> 中索引的顺序是一样的。</p>
<p>例如下面的 <code class="notranslate" translate="no">f</code> 行</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-txt">f 1/2/3/ 4/5/6 7/8/9
</code></pre>
<p>像 <code class="notranslate" translate="no">4/5/6</code> 表示对这个面的一个顶点使用“顶点 4”，“纹理座标 5”，“法线 6”。
我们将顶点、纹理座标、法线数据放进 <code class="notranslate" translate="no">objVertexData</code> 数组，这样就能简单的表示为：
对 webglData 的第 i 项，使用 objData 第 i 个数组中的第 n 个元素。
这样会简化我们的代码。</p>
<p>在函数的结尾返回我们构建的数据</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  ...

  return {
    position: webglVertexData[0],
    texcoord: webglVertexData[1],
    normal: webglVertexData[2],
  };
</code></pre>
<p>接下来要做的就是将数据绘制出来。首先我们使用 <a href="webgl-3d-lighting-directional.html">三维方向光源</a> 中着色器的变体。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vs = `
attribute vec4 a_position;
attribute vec3 a_normal;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;

varying vec3 v_normal;

void main() {
  gl_Position = u_projection * u_view * u_world * a_position;
  v_normal = mat3(u_world) * a_normal;
}
`;

const fs = `
precision mediump float;

varying vec3 v_normal;

uniform vec4 u_diffuse;
uniform vec3 u_lightDirection;

void main () {
  vec3 normal = normalize(v_normal);
  float fakeLight = dot(u_lightDirection, normal) * .5 + .5;
  gl_FragColor = vec4(u_diffuse.rgb * fakeLight, u_diffuse.a);
}
`;
</code></pre>
<p>然后使用来自 <a href="webgl-less-code-more-fun.html">码少趣多</a> 中的代码加载模型</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">async function main() {
  // 获取 WebGL 渲染上下文
  /** @type {HTMLCanvasElement} */
  const canvas = document.querySelector(&quot;#canvas&quot;);
  const gl = canvas.getContext(&quot;webgl&quot;);
  if (!gl) {
    return;
  }

  ... shaders ...

  // 编译、链接着色器，查找属性和全局变量位置
  const meshProgramInfo = webglUtils.createProgramInfo(gl, [vs, fs]);

  const data = await loadOBJ(&#39;resources/models/cube/cube.obj&#39;);

  // 数据是像这样命名的：
  //
  // {
  //   position: [...],
  //   texcoord: [...],
  //   normal: [...],
  // }
  //
  // 因为这些数组的名称和顶点着色器中的属性对应，所以我们可以将数据直接传进
  // 来自“码少趣多”文章中的 `createBufferInfoFromArrays`。

  // 通过调用 gl.createBuffer, gl.bindBuffer, gl.bufferData 为每个数组创建缓冲
  const bufferInfo = webglUtils.createBufferInfoFromArrays(gl, data);
</code></pre>
<p>然后绘制数据</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  const cameraTarget = [0, 0, 0];
  const cameraPosition = [0, 0, 4];
  const zNear = 0.1;
  const zFar = 50;

  function degToRad(deg) {
    return deg * Math.PI / 180;
  }

  function render(time) {
    time *= 0.001;  // 转成秒

    webglUtils.resizeCanvasToDisplaySize(gl.canvas);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.CULL_FACE);

    const fieldOfViewRadians = degToRad(60);
    const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
    const projection = m4.perspective(fieldOfViewRadians, aspect, zNear, zFar);

    const up = [0, 1, 0];
    // 通过 lookAt 计算 camera 矩阵。
    const camera = m4.lookAt(cameraPosition, cameraTarget, up);

    // 通过 camera 矩阵创建 view 矩阵。
    const view = m4.inverse(camera);

    const sharedUniforms = {
      u_lightDirection: m4.normalize([-1, 3, 5]),
      u_view: view,
      u_projection: projection,
    };

    gl.useProgram(meshProgramInfo.program);

    // 调用 gl.uniform
    webglUtils.setUniforms(meshProgramInfo, sharedUniforms);

    // 调用 gl.bindBuffer, gl.enableVertexAttribArray, gl.vertexAttribPointer
    webglUtils.setBuffersAndAttributes(gl, meshProgramInfo, bufferInfo);

    // 调用 gl.uniform
    webglUtils.setUniforms(meshProgramInfo, {
      u_world: m4.yRotation(time),
      u_diffuse: [1, 0.7, 0.5, 1],
    });

    // 调用 gl.drawArrays or gl.drawElements
    webglUtils.drawBufferInfo(gl, bufferInfo);

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
}
</code></pre>
<p>这样，我们就能看到模型被加载和绘制。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-load-obj-cube.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-load-obj-cube.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>我们也看到了关于未处理 keyword 的信息。它们是什么作用呢？</p>
<p><code class="notranslate" translate="no">usemtl</code> 是这之中最重要的。它指明了后面出现的所有几何体都使用指定的材质。
例如，你有一个车辆的模型，你可能会希望车窗是透明的，保险杠是金属反光的。
窗是 <a href="webgl-text-texture.html">透明</a> 的，
保险杠是 <a href="webgl-environment-maps.html">反光</a> 的，
所以它们需要和车体不一样的绘制方法。
<code class="notranslate" translate="no">usemtl</code> 标签标记了这部分信息。</p>
<p>因为我们需要单独绘制这些部分，所以我们需要修改代码，
每次遇到 <code class="notranslate" translate="no">usemtl</code> 我们就创建一个新的 webgl 数据集。</p>
<p>首先，添加代码</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function parseOBJ(text) {
  // 因为索引是从 1 开始的，所以填充索引为 0 的位置
  const objPositions = [[0, 0, 0]];
  const objTexcoords = [[0, 0]];
  const objNormals = [[0, 0, 0]];

  // 和 `f` 一样的索引顺序
  const objVertexData = [
    objPositions,
    objTexcoords,
    objNormals,
  ];

  // 和 `f` 一样的索引顺序
  let webglVertexData = [
    [],   // 顶点
    [],   // 纹理座标
    [],   // 法线
  ];

+  const geometries = [];
+  let geometry;
+  let material = &#39;default&#39;;
+
+  function newGeometry() {
+    // 如果有存在的几何体并且不是空的，销毁
+    if (geometry &amp;&amp; geometry.data.position.length) {
+      geometry = undefined;
+    }
+  }
+
+  function setGeometry() {
+    if (!geometry) {
+      const position = [];
+      const texcoord = [];
+      const normal = [];
+      webglVertexData = [
+        position,
+        texcoord,
+        normal,
+      ];
+      geometry = {
+        material,
+        data: {
+          position,
+          texcoord,
+          normal,
+        },
+      };
+      geometries.push(geometry);
+    }
+  }

...
</code></pre>
<p>接着当我们在处理 keywords 的时候，在合适的地方调用它们，包括添加 <code class="notranslate" translate="no">o</code> keyword 的函数。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  ...

  const keywords = {
    v(parts) {
      objPositions.push(parts.map(parseFloat));
    },
    vn(parts) {
      objNormals.push(parts.map(parseFloat));
    },
    vt(parts) {
      objTexcoords.push(parts.map(parseFloat));
    },
    f(parts) {
+     setGeometry();
      const numTriangles = parts.length - 2;
      for (let tri = 0; tri &lt; numTriangles; ++tri) {
        addVertex(parts[0]);
        addVertex(parts[tri + 1]);
        addVertex(parts[tri + 2]);
      }
    },
+   usemtl(parts, unparsedArgs) {
+     material = unparsedArgs;
+     newGeometry();
+   },
  };

  ...
</code></pre>
<p><code class="notranslate" translate="no">usemtl</code> 不是必要的，如果在文件中没有 <code class="notranslate" translate="no">usemtl</code>，我们想要有默认的几何体。
所以在 <code class="notranslate" translate="no">f</code> 函数中我们调用了 <code class="notranslate" translate="no">setGeometry</code> 来创建。</p>
<p>最后我们返回 <code class="notranslate" translate="no">geometries</code> 对象数组，每个对象包含 <code class="notranslate" translate="no">name</code> 和 <code class="notranslate" translate="no">data</code>。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  ...

-  return {
-    position: webglVertexData[0],
-    texcoord: webglVertexData[1],
-    normal: webglVertexData[2],
-  };
+  return geometries;
}
</code></pre>
<p>同时，我们需要处理纹理座标或法线缺失的情况。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">+  // 移除空数组
+  for (const geometry of geometries) {
+    geometry.data = Object.fromEntries(
+        Object.entries(geometry.data).filter(([, array]) =&gt; array.length &gt; 0));
+  }

  return {
    materialLibs,
    geometries,
  };
}
</code></pre>
<p>让我们继续 keywords，根据 <a href="http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf"><em>官方规范</em></a>，
<code class="notranslate" translate="no">mtllib</code> 指定了包含材质信息的独立的一个或多个文件。
不幸的是，在实际应用中，文件名中可以包含空格，但 .obj 格式中并没有提供逃逸字符来使用空格或引号。
理想情况应该使用能解决这些问题的、良好定义的格式，比如 json、xml 或 yaml 等。
但 .obj 格式诞生的比它们都早。</p>
<p>稍后我们在处理加载文件。先让我们把它加到加载器里以便之后可以使用。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function parseOBJ(text) {
  ...
+  const materialLibs = [];

  ...

  const keywords = {
    ...
+    mtllib(parts, unparsedArgs) {
+      materialLibs.push(unparsedArgs);
+    },
    ...
  };

-  return geometries;
+  return {
+    materialLibs,
+    geometries,
+  };
}
</code></pre>
<p><code class="notranslate" translate="no">o</code> 指定表明了接下来的条目属于命名为 &quot;object&quot; 的对象。但我们并不清楚如何使用它。
文件中能只包含 <code class="notranslate" translate="no">o</code> 而没有 <code class="notranslate" translate="no">usemtl</code> 吗？先假设可以。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function parseOBJ(text) {
  ...
  let material = &#39;default&#39;;
+  let object = &#39;default&#39;;

  ...

  function setGeometry() {
    if (!geometry) {
      const position = [];
      const texcoord = [];
      const normal = [];
      webglVertexData = [
        position,
        texcoord,
        normal,
      ];
      geometry = {
+        object,
        material,
        data: {
          position,
          texcoord,
          normal,
        },
      };
      geometries.push(geometry);
    }
  }

  const keywords = {
    ...
+    o(parts, unparsedArgs) {
+      object = unparsedArgs;
+      newGeometry();
+    },
    ...
  };
</code></pre>
<p><code class="notranslate" translate="no">s</code> 指定了一个 smoothing group。我觉得这是我们可以忽略的。
它们通常在建模程序中用来自动生成顶点法线。
顶点法线的计算，需要先计算每个面的法线，而每个面的法线可以很容易使用 <em>叉乘</em> 得到，
这部分已经在 <a href="webgl-3d-camera.html">三维相机</a> 中提到了。
对于任意顶点，我们可以对该顶点所在的面取均值。
但是有时我们想要一条边时，我们需要能够告诉程序忽略一些面。
Smoothing groups 让我们指定计算顶点法线时哪些面需要被包含。
关于如何计算几何体的顶点法线，你可有看 <a href="webgl-3d-geometry-lathe.html">WebGL 三维几何加工</a> 作为例子。</p>
<p>在我们的例子中，我们先忽略它。假设大部分 .obj 文件内部都包含法线，所以一般不需要 smoothing groups。
一般在模型库中才会有它，以便你想要编辑或重新生成法线。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">+  const noop = () =&gt; {};

  const keywords = {
    ...
+    s: noop,
    ...
  };
</code></pre>
<p>目前为止我们还剩一个 keyword：<code class="notranslate" translate="no">g</code> 代表组 (group)。通常它只是一些元数据。
Objects 可以存在于多个 group 中。
因为它会出现在我们接下来的文件中，所以我们先添加支持代码，尽管现在并不使用。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function parseOBJ(text) {
  ...
+  let groups = [&#39;default&#39;];
  ...
  function setGeometry() {
    if (!geometry) {
      const position = [];
      const texcoord = [];
      const normal = [];
      webglVertexData = [
        position,
        texcoord,
        normal,
      ];
      geometry = {
        object,
+        groups,
        material,
        data: {
          position,
          texcoord,
          normal,
        },
      };
      geometries.push(geometry);
    }
  }

  ...

  const keywords = {
    ...
+    g(parts) {
+      groups = parts;
+      newGeometry()
+    },
    ...
  };
</code></pre>
<p>现在我们创建了多个几何体的集合，我们需要改变我们的初始化代码来为每一个几何体创建 <code class="notranslate" translate="no">WebGLBuffers</code>。
同时我们也会创建一个随机的颜色，这样就能方便地分辨不同的部分。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-  const response = await fetch(&#39;resources/models/cube/cube.obj&#39;);
+  const response = await fetch(&#39;resources/models/chair/chair.obj&#39;);
  const text = await response.text();
-  const data = parseOBJ(text);
+  const obj = parseOBJ(text);

+  const parts = obj.geometries.map(({data}) =&gt; {
    // 数据是像这样命名的：
    //
    // {
    //   position: [...],
    //   texcoord: [...],
    //   normal: [...],
    // }
    //
    // 因为这些数组的名称和顶点着色器中的属性对应，所以我们可以将数据直接传进
    // 来自“码少趣多”文章中的 `createBufferInfoFromArrays`。

    // 通过调用 gl.createBuffer, gl.bindBuffer, gl.bufferData 为每个数组创建缓冲
    const bufferInfo = webglUtils.createBufferInfoFromArrays(gl, data);
+    return {
+      material: {
+        u_diffuse: [Math.random(), Math.random(), Math.random(), 1],
+      },
+      bufferInfo,
+    };
+  });
</code></pre>
<p>我们从加载一个立方体换成了我在 <a href="https://sketchfab.com">Sketchfab</a> 发现的，
由 <a href="https://sketchfab.com/haytonm">haytonm</a> 创建的 <a href="http://creativecommons.org/licenses/by/4.0/">CC-BY 4.0</a> <a href="https://sketchfab.com/3d-models/chair-aa2acddb218646a59ece132bf95aa558">椅子</a>。</p>
<div class="webgl_center"><img src="../../resources/models/chair/chair.jpg" style="width: 452px;"></div>

<p>要渲染，我们只需要循环绘制每个部分</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function render(time) {
  ...

  gl.useProgram(meshProgramInfo.program);

  // 调用 gl.uniform
  webglUtils.setUniforms(meshProgramInfo, sharedUniforms);

+  // 对整个空间矩阵进行一次计算
+  const u_world = m4.yRotation(time);
+
+  for (const {bufferInfo, material} of parts) {
    // 调用 gl.bindBuffer, gl.enableVertexAttribArray, gl.vertexAttribPointer
    webglUtils.setBuffersAndAttributes(gl, meshProgramInfo, bufferInfo);
    // 调用 gl.uniform
    webglUtils.setUniforms(meshProgramInfo, {
-      u_world: m4.yRotation(time),
-      u_diffuse: [1, 0.7, 0.5, 1],
+      u_world,
+      u_diffuse: material.u_diffuse,
    });
    // 调用 gl.drawArrays or gl.drawElements
    webglUtils.drawBufferInfo(gl, bufferInfo);
+  }

  ...
</code></pre>
<p>成功了！</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-load-obj.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-load-obj.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>如果我们试着把物体放中间是不是更好？</p>
<p>为了把物体放中间我们需要计算物体的范围，即顶点的最小和最大位置。
首先我们需要一个函数，计算给定多个位置中的最小和最大位置</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function getExtents(positions) {
  const min = positions.slice(0, 3);
  const max = positions.slice(0, 3);
  for (let i = 3; i &lt; positions.length; i += 3) {
    for (let j = 0; j &lt; 3; ++j) {
      const v = positions[i + j];
      min[j] = Math.min(v, min[j]);
      max[j] = Math.max(v, max[j]);
    }
  }
  return {min, max};
}
</code></pre>
<p>然后我们遍历几何体的每个部分，并且得到对于的范围</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function getGeometriesExtents(geometries) {
  return geometries.reduce(({min, max}, {data}) =&gt; {
    const minMax = getExtents(data.position);
    return {
      min: min.map((min, ndx) =&gt; Math.min(minMax.min[ndx], min)),
      max: max.map((max, ndx) =&gt; Math.max(minMax.max[ndx], max)),
    };
  }, {
    min: Array(3).fill(Number.POSITIVE_INFINITY),
    max: Array(3).fill(Number.NEGATIVE_INFINITY),
  });
}
</code></pre>
<p>接着，我们需要计算物体的平移距离，以便能将它的中心放在原点，同时计算原点和 camera 的距离，保证能完全看到物体。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-  const cameraTarget = [0, 0, 0];
-  const cameraPosition = [0, 0, 4];
-  const zNear = 0.1;
-  const zFar = 50;
+  const extents = getGeometriesExtents(obj.geometries);
+  const range = m4.subtractVectors(extents.max, extents.min);
+  // 移动物体的距离，使得其中心在原点
+  const objOffset = m4.scaleVector(
+      m4.addVectors(
+        extents.min,
+        m4.scaleVector(range, 0.5)),
+      -1);
+  const cameraTarget = [0, 0, 0];
+  // 计算移动 camera 的距离，以便我们能完全看到物体
+  const radius = m4.length(range) * 1.2;
+  const cameraPosition = m4.addVectors(cameraTarget, [
+    0,
+    0,
+    radius,
+  ]);
+  // 设置合适于物体大小的 zNear 和 zFar 值
+  const zNear = radius / 100;
+  const zFar = radius * 3;
</code></pre>
<p>上面，我们也设置了适合显示物体的 <code class="notranslate" translate="no">zNear</code> 和 <code class="notranslate" translate="no">zFar</code> 值。</p>
<p>只需要使用 <code class="notranslate" translate="no">objOffset</code> 来将物体平移到原点。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 将整个空间矩阵重新计算一次
-const u_world = m4.yRotation(time);
+let u_world = m4.yRotation(time);
+u_world = m4.translate(u_world, ...objOffset);
</code></pre>
<p>这样，对象就居中了。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-load-obj-w-extents.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-load-obj-w-extents.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>在网上查阅了一下，有些非标准的 .obj 文件包含了顶点的颜色值。
它们将额外的值放在了每个顶点位置的后面，</p>
<p>标准</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">v &lt;x&gt; &lt;y&gt; &lt;z&gt;
</code></pre><p>非标准</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">v &lt;x&gt; &lt;y&gt; &lt;z&gt; &lt;red&gt; &lt;green&gt; &lt;blue&gt;
</code></pre><p>不清楚后面是否有可选的 alpha 值。</p>
<p>我查了一下，找到了由 <a href="https://sketchfab.com/homkahom0">Oleaf</a> 创建的 <a href="https://sketchfab.com/3d-models/book-vertex-chameleon-study-51b0b3bdcd844a9e951a9ede6f192da8">Book - Vertex chameleon study</a> by <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC</a> 使用了顶点颜色。</p>
<div class="webgl_center"><img src="../../resources/models/book-vertex-chameleon-study/book.png" style="width: 446px;"></div>

<p>让我们看看能不能添加代码来支持显示顶点颜色。</p>
<p>我们需要在有顶点位置、法线和纹理座标的地方添加一些代码</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function parseOBJ(text) {
  // 因为索引是从 1 开始的，所以填充索引为 0 的位置
  const objPositions = [[0, 0, 0]];
  const objTexcoords = [[0, 0]];
  const objNormals = [[0, 0, 0]];
+  const objColors = [[0, 0, 0]];

  // 和 `f` 一样的索引顺序
  const objVertexData = [
    objPositions,
    objTexcoords,
    objNormals,
+    objColors,
  ];

  // 和 `f` 一样的索引顺序
  let webglVertexData = [
    [],   // 顶点
    [],   // 纹理座标
    [],   // 法线
+    [],   // 颜色
  ];

  ...

  function setGeometry() {
    if (!geometry) {
      const position = [];
      const texcoord = [];
      const normal = [];
+      const color = [];
      webglVertexData = [
        position,
        texcoord,
        normal,
+        color,
      ];
      geometry = {
        object,
        groups,
        material,
        data: {
          position,
          texcoord,
          normal,
+          color,
        },
      };
      geometries.push(geometry);
    }
  }
</code></pre>
<p>这使得我们的代码有一点不通用。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  const keywords = {
    v(parts) {
-      objPositions.push(parts.map(parseFloat));
+      // 如果超过 3 个值，就是顶点颜色
+      if (parts.length &gt; 3) {
+        objPositions.push(parts.slice(0, 3).map(parseFloat));
+        objColors.push(parts.slice(3).map(parseFloat));
+      } else {
+        objPositions.push(parts.map(parseFloat));
+      }
    },
    ...
  };
</code></pre>
<p>然后当我们读取到 <code class="notranslate" translate="no">f</code> 面的时候，调用 <code class="notranslate" translate="no">addVertex</code>，我们需要获取顶点的颜色</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  function addVertex(vert) {
    const ptn = vert.split(&#39;/&#39;);
    ptn.forEach((objIndexStr, i) =&gt; {
      if (!objIndexStr) {
        return;
      }
      const objIndex = parseInt(objIndexStr);
      const index = objIndex + (objIndex &gt;= 0 ? 0 : objVertexData[i].length);
      webglVertexData[i].push(...objVertexData[i][index]);
+      // 如果这是位置索引并且解析到了颜色值，将顶点的颜色值复制到 webgl 顶点的颜色中
+      if (i === 0 &amp;&amp; objColors.length &gt; 1) {
+        geometry.data.color.push(...objColors[index]);
+      }
    });
  }
</code></pre>
<p>接着，我们需要更改我们的着色器来使用顶点颜色</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vs = `
attribute vec4 a_position;
attribute vec3 a_normal;
+attribute vec4 a_color;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;

varying vec3 v_normal;
+varying vec4 v_color;

void main() {
  gl_Position = u_projection * u_view * u_world * a_position;
  v_normal = mat3(u_world) * a_normal;
+  v_color = a_color;
}
`;

const fs = `
precision mediump float;

varying vec3 v_normal;
+varying vec4 v_color;

uniform vec4 u_diffuse;
uniform vec3 u_lightDirection;

void main () {
  vec3 normal = normalize(v_normal);
  float fakeLight = dot(u_lightDirection, normal) * .5 + .5;
-  gl_FragColor = vec4(u_diffuse.rgb * fakeLight, u_diffuse.a);
+  vec4 diffuse = u_diffuse * v_color;
+  gl_FragColor = vec4(diffuse.rgb * fakeLight, diffuse.a);
}
`;
</code></pre>
<p>就如上面提到的，我不确定这个非标准版本的 .obj 文件能否在每个顶点颜色中包含 alpha 值。
我们的 <a href="webgl-less-code-more-fun.html">helper library</a> 根据我们传入的数据自动创建缓冲区。
它假设每个元素有多少个组成部分。
对于名字中包含 <code class="notranslate" translate="no">position</code> 或 <code class="notranslate" translate="no">normal</code> 的，默认每个元素包含 3 个组成部分。
对于名字中包含 <code class="notranslate" translate="no">texcoord</code> 的，默认每个元素 2 个组成部分。
其它的每个元素默认 4 个组成部分。
这样的话，如果我们的颜色仅包含 r、g、b，每个元素三个组成部分，我们需要传参给它。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const parts = obj.geometries.map(({data}) =&gt; {
  // 数据是像这样命名的：
  //
  // {
  //   position: [...],
  //   texcoord: [...],
  //   normal: [...],
  // }
  //
  // 因为这些数组的名称和顶点着色器中的属性对应，所以我们可以将数据直接传进
  // 来自“码少趣多”文章中的 `createBufferInfoFromArrays`。

+   if (data.position.length === data.color.length) {
+     // 是 3， helper library 默认是 4 所以我们需要告诉程序只有 3 个
+     data.color = { numComponents: 3, data: data.color };
+   }

  // 通过调用 gl.createBuffer, gl.bindBuffer, gl.bufferData 为每个数组创建缓冲
  const bufferInfo = webglUtils.createBufferInfoFromArrays(gl, data);
  return {
    material: {
      u_diffuse: [Math.random(), Math.random(), Math.random(), 1],
    },
    bufferInfo,
  };
});
</code></pre>
<p>我们也希望能够处理更常见的没有顶点颜色的情况。
在 <a href="webgl-fundamentals.html">WebGL 基础概念</a> 和 <a href="webgl-attributes.html">WebGL 属性</a> 中我们提到了属性通常从缓冲中获取值。
但我们也可以将属性设置成常量。没有的值使用默认常量。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.disableVertexAttribArray(someAttributeLocation);  // 使用常量
const value = [1, 2, 3, 4];
gl.vertexAttrib4fv(someAttributeLocation, value);    // 使用给定的值
</code></pre>
<p>如果将属性的值设为 <code class="notranslate" translate="no">{value:[1, 2, 3, 4]}</code>，我们的 <a href="webgl-less-code-more-fun.html">helper library</a> 为我们处理了这种情况。当检查到没有顶点颜色时，默认将顶点颜色属性设置成白色。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const parts = obj.geometries.map(({data}) =&gt; {
  // 数据是像这样命名的：
  //
  // {
  //   position: [...],
  //   texcoord: [...],
  //   normal: [...],
  // }
  //
  // 因为这些数组的名称和顶点着色器中的属性对应，所以我们可以将数据直接传进
  // 来自“码少趣多”文章中的 `createBufferInfoFromArrays`。

+  if (data.color) {
      if (data.position.length === data.color.length) {
        // 是 3， helper library 默认是 4 所以我们需要告诉程序只有 3 个
        data.color = { numComponents: 3, data: data.color };
      }
+  } else {
+    // 没有顶点颜色，使用白色
+    data.color = { value: [1, 1, 1, 1] };
+  }

  ...
});
</code></pre>
<p>我们也不能使用随机颜色</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const parts = obj.geometries.map(({data}) =&gt; {
  ...

  // 通过调用 gl.createBuffer, gl.bindBuffer, gl.bufferData 为每个数组创建缓冲
  const bufferInfo = webglUtils.createBufferInfoFromArrays(gl, data);
  return {
    material: {
-      u_diffuse: [Math.random(), Math.random(), Math.random(), 1],
+      u_diffuse: [1, 1, 1, 1],
    },
    bufferInfo,
  };
});
</code></pre>
<p>这样，我们就能带顶点颜色的 .obj 文件了。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-load-obj-w-vertex-colors.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-load-obj-w-vertex-colors.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>至于解析和使用材质，<a href="webgl-load-obj-w-mtl.html">看下一篇</a>。</p>
<h2 id="-">一些注意点</h2>
<h3 id="-">这个加载器是不完整的</h3>
<p>你可以 <a href="http://paulbourke.net/dataformats/obj/">阅读更多关于 .obj 格式</a>。
有大量的功能上面的代码是不支持的。
同时，代码也没有经过大量 .obj 文件的测试，所以可能有很多未知的 bug。
也就是说，我假设了大多数在线的 .obj 文件只使用了上面提到的功能，所以这部分代码说不定是一个有用的例子。</p>
<h3 id="-">这个加载器没有进行错误检查</h3>
<p>例如： <code class="notranslate" translate="no">vt</code> 可以有 3 个值而不仅仅是 2 个。3 个值是给 3D 纹理使用的，不普遍所以我没有处理。
如果你确实想要用它解析 3D 纹理座标，你需要修改着色器来处理 3D 纹理，
修改生成 <code class="notranslate" translate="no">WebGLBuffers</code> (调用 <code class="notranslate" translate="no">createBufferInfoFromArrays</code>)的代码，告诉它每个 UV 座标有 3 个组成部分。</p>
<h3 id="-">假设数据是一致的</h3>
<p>我不知道是否会出现同一个文件中一些 <code class="notranslate" translate="no">f</code> 有 3 个条目而另一些只有 2 个条目会。如果有可能，上面的代码没有处理这种情况。</p>
<p>这段代码同样假设了所有顶点座标都有 x、y、z。如果出现有些顶点座标有 x、y、z，有些顶点座标只有 x、y，而有些则有 x、y、z、r、g、b，我们需要重构代码。</p>
<h3 id="-">可以将所有数据放进一个缓冲里</h3>
<p>上面的代码将顶点位置、纹理座标、法线放进了不同的缓冲。
你也可以将它们交错的放进一个缓冲中：pos, uv, nrm, pos, uv, nrm, ...
这样的话就需要改变设置属性的方式。</p>
<p>更进一步，你甚至可以将所有部分的所有数据放进同一个缓冲里，而不是每个部分、每个类型的数据一个缓冲。</p>
<p>我不考虑这些因为我觉得它们没有那么重要，同时它们也会使得代码变得复杂。</p>
<h3 id="-">可以重建顶点的索引</h3>
<p>上面的代码将顶点展开放进了三个数组中。我们可以重建顶点的索引。
尤其当我们将所有顶点数据放进一个共享的缓冲中，或至少每个类型有一个单独的共享缓冲时，
对于每个 <code class="notranslate" translate="no">f</code> 面，可以将索引转换到一个正数（负数变换到正确的正数），那么对于每个顶点，
数据集就变成了一个或多个 <em>id</em>。所以，只要记下 <em>id 到索引的映射关系</em> 就能查找到对应的索引。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const idToIndexMap = {};
const webglIndices = [];

function addVertex(vert) {
  const ptn = vert.split(&#39;/&#39;);
  // 首先将所有索引转换成正数
  const indices = ptn.forEach((objIndexStr, i) =&gt; {
    if (!objIndexStr) {
      return;
    }
    const objIndex = parseInt(objIndexStr);
    return objIndex + (objIndex &gt;= 0 ? 0 : objVertexData[i].length);
  });
  // 现在检查已存在的顶点位置、纹理座标、法线组合
  const id = indices.join(&#39;,&#39;);
  let vertIndex = idToIndexMap[id];
  if (!vertIndex) {
    vertIndex = webglVertexData[0].length / 3;
    idToIndexMap[id] = vertexIndex;
    indices.forEach((index, i) =&gt; {
      if (index !== undefined) {
        webglVertexData[i].push(...objVertexData[i][index]);
      }
    })
  }
  webglIndices.push(vertexIndex);
}
</code></pre>
<p>或者，如果你觉得重要你可以收到重排索引。</p>
<h3 id="-">这段代码没有处理只有顶点座标，或只有顶点座标和纹理座标的情况</h3>
<p>这段代码假设法线存在。就像我们在 <a href="webgl-3d-geometry-lathe.html">三维几何加工</a> 里做的，
如果法线不存在，我们可以生成它，考虑到如果我们需要 smoothing group。
或者我们也可以不使用也不计算法线的不同着色器。</p>
<h3 id="-obj-">你不应该使用 .obj 文件</h3>
<p>老实说，我认为你不应该使用 .obj 文件。我写这篇文章是作为一个例子。
如果你可以从一个文件中获取顶点数据，你可以为任意格式的文件写导入器。</p>
<p>.obj 文件的问题包括：</p>
<ul>
<li><p>不支持光线或视角</p>
<p>如果你加载大量部件（比如景观中的树、灌木、石头），你不需要视角或光线，这可能没问题。
但文件如果提供选项让你能够原样导入作者创建的整个场景会更好。</p>
</li>
<li><p>没有层级，没有场景图</p>
<p>如果你想要导入一辆车，你会希望车轮能够转向，并能够绕着中心点旋转。
这对 .obj 文件来说是不可能的，因为 .obj 不包含 [场景图][webgl-scene-graph.html]。
更好的文件格式包含这些数据，如果你想要能够旋转的部件、滑动窗户、开门、移动角色的腿等，这会很有用。</p>
</li>
<li><p>不支持动画或蒙皮</p>
<p>相比于其它的，我们更想要 <a href="webgl-skinning.html">蒙皮</a>，但 .obj 并没有蒙皮或者动画相关内容。
如果你不需要这些，可能没什么问题。但我更偏向一种能包含更多内容的格式。</p>
</li>
<li><p>.obj 不支持更多现代的材质</p>
<p>材质一般来说针对于特定的引擎，但至少对于一些基于物理的材质渲染各引擎是共通的。
据我所知，.obj 文件并不支持。</p>
</li>
<li><p>.obj 需要解析</p>
<p>除非你在写一个通用的查看器让用户上传 .obj 文件，通常最佳的做法是使用一个不太需要解析的文件格式。
.gltf 是一种为 WebGL 设计的文件格式。它使用 JSON，你可以轻松地加载。
对于二进制数据，它使用能直接加载进 GPU 的格式，一般不需要将数字解析进数组。</p>
<p>你可以查看加载 .gltf 的例子 <a href="webgl-skinning.html">蒙皮</a>。</p>
<p>如果你想使用 .obj 文件，最佳实践是先将它转换成其它文件格式，然后在你的页面中使用。</p>
</li>
</ul>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-load-obj.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-load-obj.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-load-obj.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-load-obj.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-load-obj.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-load-obj.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-load-obj.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-load-obj.html" selected>简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>基础概念</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-fundamentals.html">WebGL 基础概念</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-how-it-works.html">WebGL 工作原理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html">WebGL 着色器和GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL State Diagram</a></li>
        </ul>
  <li>图像处理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-image-processing.html">WebGL 图像处理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-image-processing-continued.html">WebGL 进一步处理图像</a></li>
        </ul>
  <li>二维平移，旋转，缩放和矩阵运算</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-translation.html">WebGL 二维平移</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-rotation.html">WebGL 二维旋转</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-scale.html">WebGL 二维缩放</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrices.html">WebGL 二维矩阵</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-orthographic.html">WebGL 三维正射投影</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective.html">WebGL 三维透视投影</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-camera.html">WebGL 三维相机</a></li>
        </ul>
  <li>光照</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-directional.html">WebGL 三维方向光源</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-point.html">WebGL 三维点光源</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-spot.html">WebGL 三维聚光灯</a></li>
        </ul>
  <li>组织和重构</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-less-code-more-fun.html">WebGL 码少趣多</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-multiple-things.html">WebGL 绘制多个物体</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-scene-graph.html">WebGL 场景图</a></li>
        </ul>
  <li>几何</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-geometry-lathe.html">WebGL 三维几何加工</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-load-obj.html">WebGL 加载 .obj 文件</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-load-obj-w-mtl.html">WebGL 加载带 .mtl 的 .obj 文件</a></li>
        </ul>
  <li>纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-textures.html">WebGL 三维纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-data-textures.html">WebGL 数据纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2-textures.html">WebGL 使用多个纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-cors-permission.html">WebGL 跨域图像</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective-correct-texturemapping.html">WebGL 纹理映射的透视纠正</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>渲染到纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-render-to-texture.html">WebGL 渲染到纹理</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>技术</li>
        <ul>
            <li>二维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-drawimage.html">WebGL 二维DrawImage</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrix-stack.html">WebGL 二维矩阵栈</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-sprites.html">Sprites</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-cube-maps.html">WebGL 立方体贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-environment-maps.html">WebGL 环境贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skybox.html">WebGL 天空盒</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skinning.html">WebGL 蒙皮</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-fog.html">WebGL 雾</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>文字</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-text-html.html">WebGL 文字 - HTML</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-canvas2d.html">WebGL 文字 - 二维Canvas</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-texture.html">WebGL 文字 - 使用纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-glyphs.html">WebGL 文字 - 使用字形纹理</a></li>
        </ul>
  <li>纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-ramp-textures.html">Ramp Textures (Toon Shading)</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-smallest-programs.html">WebGL 最小的程序</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-instanced-drawing.html">实例化绘制</a></li>
        </ul>
  <li>杂项</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-setup-and-installation.html">WebGL 设置和安装</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-boilerplate.html">WebGL 样板</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html">WebGL 重置画布尺寸</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-animation.html">WebGL 动画</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-points-lines-triangles.html">WebGL 点、线和三角</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-and-alpha.html">WebGL 和阿尔法通道</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-vs-3d-library.html">WebGL 2D vs 3D 库</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-anti-patterns.html">WebGL 错误模式</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#screenshot">截屏</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#preservedrawingbuffer">防止画布被清空</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#tabindex">在画布中获取键盘输入</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#html-background">将 WebGL 作为 HTML 的背景</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-attributes.html">WebGL 属性</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-texture-units.html">WebGL 纹理单元</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-readpixels.html">WebGL readPixels</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-references.html">WebGL 参考</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API 帮助文档</a></li>
  <li><a href="https://twgljs.org">TWGL, 一个轻量级WebGL辅助库</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>有关于WebGL的疑问? <a href="https://stackoverflow.com/questions/tagged/webgl">在Stackoverflow提问</a>。</div>
        <div>有意见或建议? <a href="https://github.com/vinci-mz/webgl-fundamentals/issues">在GitHub上提issue</a>。</div>

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL 加载 .obj 文件';
            var disqus_title = 'WebGL 加载 .obj 文件';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
      return;
  }

  function addScript(src, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  addScript('//cdn.webglstats.com/stat.js');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>



