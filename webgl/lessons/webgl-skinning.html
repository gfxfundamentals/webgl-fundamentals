<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/webgl-skinning.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="How to skin a mesh in WebGL" />
<meta name="keywords" content="webgl graphics" />
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-skinning_en.jpg" />

<meta property="og:title" content="WebGL Skinning" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-skinning_en.jpg" />
<meta property="og:description" content="How to skin a mesh in WebGL" />
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/webgl-skinning.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webglfundamentals.org" />
<meta name="twitter:title" content="WebGL Skinning" />
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/webgl-skinning.html" />
<meta name="twitter:description" content="How to skin a mesh in WebGL" />
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-skinning_en.jpg" />

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/webgl-skinning.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-skinning_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/webgl-skinning.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/webgl-skinning.html",
      "inLanguage":"en",
      "name":"WebGL Skinning",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/webgl-skinning.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL Skinning</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />



</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-skinning.html" selected>English</a>
    <option value="/webgl/lessons/fr/webgl-skinning.html" >Fran√ßais</a>
    <option value="/webgl/lessons/ja/webgl-skinning.html" >Êó•Êú¨Ë™û</a>
    <option value="/webgl/lessons/ko/webgl-skinning.html" >ÌïúÍµ≠Ïñ¥</a>
    <option value="/webgl/lessons/pl/webgl-skinning.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-skinning.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-skinning.html" >–†—É—Å—Å–∫–∏–π</a>
    <option value="/webgl/lessons/zh_cn/webgl-skinning.html" >ÁÆÄ‰Ωì‰∏≠Êñá</a>
</select>


    <a href="#toc">Table of Contents</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub a {
    background: #000;
    color: #fff;
    text-decoration: none;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 2rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 300px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(150px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a:hover {
    background: #c11;
    color: #fff;
}
#forkongithub a::before,#forkongithub a::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub a::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
@media (max-width: 900px) {
    #forkongithub a{
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub a{
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL Skinning</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Skinning in graphics is the name given to moving a set of vertices based
on the weighted influence of multiple matrices. That&#39;s pretty abstract.</p>
<p>It&#39;s called <em>skinning</em> because it&#39;s typically used to make 3D characters
have a &quot;skeleton&quot; made from &quot;bones&quot; where &quot;bone&quot; is another name for matrix
and then <strong>per vertex</strong> setting the influence of each bone to that vertex.</p>
<p>So for example the hand bone would have nearly 100% influence on the vertices
near the hand of a character where as the foot bone would have zero influence
on those same vertices. The vertices in around the wrist would have some influence form the hand bone and also some from the arm bone.</p>
<p>The basic part is that you need bones (which is just a fancy way of saying
a matrix hierarchy) and weights. Weights are per vertex values that go
from 0 to 1 to say how much a particular bone-matrix affects the position
of that vertex. Weights are kind of like vertex colors as far as data.
One set of weights per vertex. In other words the weights are put in a
buffer and provided through attributes.</p>
<p>Typically you limit the number of weights per vertex partly because
otherwise it would be way too much data.  A character can have anywhere
from 15 bones (Virtua Fighter 1) to 150-300 bones (some modern games).
If you had 300 bones you&#39;d need 300 weights PER vertex PER bone.  If your
character had 10000 vertices that would be 3 million weights needed.</p>
<p>So, instead most real time skinning systems limit it ~4 weights per vertex.
Usually this is accomplished in an exporter/converter that takes data from
a 3D packages like blender/maya/3dsmax and for each vertex finds the 4
bones with the highest weights and then normalizes those weights</p>
<p>To give an pseudo example a non-skinned vertex is typically computed like this</p>
<pre class="prettyprint"><code>gl_Position = projection * view * model * position;
</code></pre><p>A skinned vertex is effectively computed like this</p>
<pre class="prettyprint"><code>gl_Position = projection * view *
              (bone1Matrix * position * weight1 +
               bone2Matrix * position * weight2 +
               bone3Matrix * position * weight3 +
               bone4Matrix * position * weight4);
</code></pre><p>As you can see it&#39;s like were computing 4 different positions for each vertex and then blending them back into one by applying the weights.</p>
<p>Assuming you stored the bones matrices in a uniform array, and you
passed in the the weights and which bone each weight applies to as
attributes you might do something like</p>
<pre class="prettyprint"><code>attribute vec4 a_position;
attribute vec4 a_weights;         // 4 weights per vertex
attribute vec4 a_boneNdx;         // 4 bone indices per vertex
uniform mat4 bones[MAX_BONES];    // 1 matrix per bone

gl_Position = projection * view *
              (a_bones[int(a_boneNdx[0])] * a_position * a_weight[0] +
               a_bones[int(a_boneNdx[1])] * a_position * a_weight[1] +
               a_bones[int(a_boneNdx[2])] * a_position * a_weight[2] +
               a_boneS[int(a_boneNdx[3])] * a_position * a_weight[3]);
</code></pre><p>There&#39;s one more issue. Let&#39;s say you have a model of a person with
the origin (0,0,0) on the floor just between their feet.</p>
<div class="webgl_center"><img src="resources/bone-head.svg" style="width: 500px;"></div>

<p>Now imagine you put a matrix/bone/joint at their head and you want to use
that for bone for skinning.  To keep it simple imagine you just set the
weights so the the vertices of the head have a weight of 1.0 for the head
bone and no other joints influence those vertices.</p>
<div class="webgl_center"><img src="resources/bone-head-setup.svg" style="width: 500px;"></div>

<p>There&#39;s a problem.
The head vertices are 2 units above the origin.  The head bone is also 2
units above the origin.  If you actually multiplied those head vertices by
the head bone matrix you&#39;d get vertices 4 units above the origin.  The
original 2 units of the vertices + the 2 units of the head bone matrix.</p>
<div class="webgl_center"><img src="resources/bone-head-problem.svg" style="width: 500px;"></div>

<p>A solution is to store a &quot;bind pose&quot; which is an extra matrix per joint of
where each matrix was before you used it to influence the vertices.  In that
case the bind pose of the head matrix would be 2 units above the origin.
So now you can use the inverse of that matrix to subtract out the extra 2
units.</p>
<p>In other words the bone matrices passed to the shader have each been
multiplied by their inverse bind pose so as to make their influence only
how much they changed from their original positions relative to the origin
of the mesh.</p>
<p>Let&#39;s make a small example. We&#39;ll animate in 2d a grid like this</p>
<div class="webgl_center"><img src="resources/skinned-mesh.svg" style="width: 400px;"></div>

<ul>
<li>Where <code>b0</code>, <code>b1</code>, and <code>b2</code> are the bone matrices.</li>
<li><code>b1</code> is a child of <code>b0</code> and <code>b2</code> is a child of <code>b1</code></li>
<li>Verts <code>0,1</code> will get a weight of 1.0 from bone b0</li>
<li>Verts <code>2,3</code> will get a weight of 0.5 from bones b0 and b1</li>
<li>Verts <code>4,5</code> will get a weight of 1.0 from bone b1</li>
<li>Verts <code>6,7</code> will get a weight of 0.5 from bones b1 and b2</li>
<li>Verts <code>8,9</code> will get a weight of 1.0 from bone b2</li>
</ul>
<p>We&#39;ll use the utils described in <a href="webgl-less-code-more-fun.html">less code more fun</a>.</p>
<p>First we need the vertices and for each vertex the index
of each bone that influences it and a number from 0 to 1
of how much influence that bone has.</p>
<pre class="prettyprint"><code>var arrays = {
  position: {
    numComponents: 2,
    data: [
     0,  1,  // 0
     0, -1,  // 1
     2,  1,  // 2
     2, -1,  // 3
     4,  1,  // 4
     4, -1,  // 5
     6,  1,  // 6
     6, -1,  // 7
     8,  1,  // 8
     8, -1,  // 9
    ],
  },
  boneNdx: {
    numComponents: 4,
    data: [
      0, 0, 0, 0,  // 0
      0, 0, 0, 0,  // 1
      0, 1, 0, 0,  // 2
      0, 1, 0, 0,  // 3
      1, 0, 0, 0,  // 4
      1, 0, 0, 0,  // 5
      1, 2, 0, 0,  // 6
      1, 2, 0, 0,  // 7
      2, 0, 0, 0,  // 8
      2, 0, 0, 0,  // 9
    ],
  },
  weight: {
    numComponents: 4,
    data: [
     1, 0, 0, 0,  // 0
     1, 0, 0, 0,  // 1
    .5,.5, 0, 0,  // 2
    .5,.5, 0, 0,  // 3
     1, 0, 0, 0,  // 4
     1, 0, 0, 0,  // 5
    .5,.5, 0, 0,  // 6
    .5,.5, 0, 0,  // 7
     1, 0, 0, 0,  // 8
     1, 0, 0, 0,  // 9
    ],
  },

  indices: {
    numComponents: 2,
    data: [
      0, 1,
      0, 2,
      1, 3,
      2, 3, //
      2, 4,
      3, 5,
      4, 5,
      4, 6,
      5, 7, //
      6, 7,
      6, 8,
      7, 9,
      8, 9,
    ],
  },
};
// calls gl.createBuffer, gl.bindBuffer, gl.bufferData
var bufferInfo = webglUtils.createBufferInfoFromArrays(gl, arrays);
</code></pre><p>We can define our uniform values including a matrix for each bone</p>
<pre class="prettyprint"><code>// 4 matrices, one for each bone
var numBones = 4;
var boneArray = new Float32Array(numBones * 16);

var uniforms = {
  projection: m4.orthographic(-20, 20, -10, 10, -1, 1),
  view: m4.translation(-6, 0, 0),
  bones: boneArray,
  color: [1, 0, 0, 1],
};
</code></pre><p>We can make views into the boneArray, one for each matrix</p>
<pre class="prettyprint"><code>// make views for each bone. This lets all the bones
// exist in 1 array for uploading but as separate
// arrays for using with the math functions
var boneMatrices = [];  // the uniform data
var bones = [];         // the value before multiplying by inverse bind matrix
var bindPose = [];      // the bind matrix
for (var i = 0; i &lt; numBones; ++i) {
  boneMatrices.push(new Float32Array(boneArray.buffer, i * 4 * 16, 16));
  bindPose.push(m4.identity());  // just allocate storage
  bones.push(m4.identity());     // just allocate storage
}
</code></pre><p>And then some code to manipulate the bone matrixes. We&#39;ll just rotate
them in a hierarchy like the bones of a finger.</p>
<pre class="prettyprint"><code>// rotate each bone by angle and simulate a hierarchy
function computeBoneMatrices(bones, angle) {
  var m = m4.identity();
  m4.zRotate(m, angle, bones[0]);
  m4.translate(bones[0], 4, 0, 0, m);
  m4.zRotate(m, angle, bones[1]);
  m4.translate(bones[1], 4, 0, 0, m);
  m4.zRotate(m, angle, bones[2]);
  // bones[3] is not used
}
</code></pre><p>Now call it once to generate their initial positions and use the result
to compute the inverse bind pose matrices.</p>
<pre class="prettyprint"><code>// compute the initial positions of each matrix
computeBoneMatrices(bindPose, 0);

// compute their inverses
var bindPoseInv = bindPose.map(function(m) {
  return m4.inverse(m);
});
</code></pre><p>Now we&#39;re ready to render</p>
<p>First we animate the bones, computing a new world matrix for each</p>
<pre class="prettyprint"><code>var t = time * 0.001;
var angle = Math.sin(t) * 0.8;
computeBoneMatrices(bones, angle);
</code></pre><p>Then we multiply the result of each by the inverse bind pose to deal with
the issue mentioned above</p>
<pre class="prettyprint"><code>// multiply each by its bindPoseInverse
bones.forEach(function(bone, ndx) {
  m4.multiply(bone, bindPoseInv[ndx], boneMatrices[ndx]);
});
</code></pre><p>Then all the normal stuff, setting up the attributes, setting the uniforms, and drawing.</p>
<pre class="prettyprint"><code>gl.useProgram(programInfo.program);
// calls gl.bindBuffer, gl.enableVertexAttribArray, gl.vertexAttribPointer
webglUtils.setBuffersAndAttributes(gl, programInfo, bufferInfo);

// calls gl.uniformXXX, gl.activeTexture, gl.bindTexture
webglUtils.setUniforms(programInfo, uniforms);

// calls gl.drawArrays or gl.drawIndices
webglUtils.drawBufferInfo(gl, bufferInfo, gl.LINES);
</code></pre><p>And here&#39;s the result</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-skinning.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-skinning.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>The red lines are the <em>skinned</em> mesh.  The green and blue lines represent
the x-axis and y-axis of each bone or &quot;joint&quot;. You can see how the vertices
that are influenced by multiple bones move between the bones that influence
them. We didn&#39;t cover how the bones are drawn as it&#39;s not important to
explaining how skinning works. See the code if you&#39;re curious.</p>
<p>NOTE: bones vs joints is confusing. There&#39;s only 1 thing, <em>matrices</em>.
But, in a 3d modelling package they usually draw a gizmo (a ui widget)
between each matrix. That looks ends up looking like a bone. The joints
are where matrices are and they draw a line or cone from each joint
to the next to make it kind of look like a skeleton.</p>
<div class="webgl_center">
  <img src="resources/bone-display.png" style="width: 351px;">
  <div class="caption"><a href="https://www.blendswap.com/blends/view/66412">LowPoly Man</a> by <a href="https://www.blendswap.com/user/TiZeta">TiZeta</a></div>
</div>

<p>Another minor thing to note, the example above is using floats for the weights
and the bone indices but you could easily use <code>UNSIGNED_BYTE</code> to save a
bunch of space.</p>
<p>Unfortunately there&#39;s a limit to the number of uniforms you can use in a shader.
The lower limit on WebGL is 64 vec4s which is only 8 mat4s and you probably
need some of those uniforms for other things like for example we have <code>color</code>
in the fragment shader and we have <code>projection</code> and <code>view</code> which means if
we were on a device with a limit of 64 vec4s we could only have 5 bones! Checking
<a href="https://webglstats.com/webgl/parameter/MAX_VERTEX_UNIFORM_VECTORS">WebGLStats</a>
most devices support 128 vec4s and 70% of them support 256 vec4s but with
are sample above that&#39;s still only 13 bones and 29 bones respectively. 13 is
not even enough for a early 90s Virtua Fighter 1 style character and 29 is not
close to the number used in most modern games.</p>
<p>A couple ways around that. One is to pre-process the models offline and break them
into multiple parts each one using no more than N bones. That&#39;s pretty complicated
and brings it&#39;s own set of issues.</p>
<p>Another is to store the bone matrices in a texture. This is an important reminder
that textures are not just images, they are effectively 2D arrays of random access
data that you can pass to a shader and you can use them for all kinds of things
that are not just reading images for texturing.</p>
<p>Let&#39;s pass our matrices in a texture to bypass the uniform limit. To make this
easy we&#39;re going to use floating point textures. Floating point textures are
an optional feature of WebGL but fortunately they are supported by most devices.</p>
<p>Here&#39;s the code to get the extension. If it fails we&#39;d probably want to either tell
the user they are out of luck or choose some other solution.</p>
<pre class="prettyprint"><code>var ext = gl.getExtension(&#39;OES_texture_float&#39;);
if (!ext) {
  return;  // the extension doesn&#39;t exist on this device
}
</code></pre><p>Let&#39;s update the shader to get the matrices out of a texture.
We&#39;ll make the texture have one matrix per row. Each texel of the texture
has R, G, B, and A, that&#39;s 4 values so we only need 4 pixels per matrix,
one pixel for each row of the matrix.
Textures can usually be at least 2048 pixels in certain dimension so
this will give us room for at least 2048 bone matrices which is plenty.</p>
<pre class="prettyprint"><code>attribute vec4 a_position;
attribute vec4 a_weight;
attribute vec4 a_boneNdx;

uniform mat4 projection;
uniform mat4 view;
*uniform sampler2D boneMatrixTexture;
*uniform float numBones;

+// these offsets assume the texture is 4 pixels across
+#define ROW0_U ((0.5 + 0.0) / 4.)
+#define ROW1_U ((0.5 + 1.0) / 4.)
+#define ROW2_U ((0.5 + 2.0) / 4.)
+#define ROW3_U ((0.5 + 3.0) / 4.)
+
+mat4 getBoneMatrix(float boneNdx) {
+  float v = (boneNdx + 0.5) / numBones;
+  return mat4(
+    texture2D(boneMatrixTexture, vec2(ROW0_U, v)),
+    texture2D(boneMatrixTexture, vec2(ROW1_U, v)),
+    texture2D(boneMatrixTexture, vec2(ROW2_U, v)),
+    texture2D(boneMatrixTexture, vec2(ROW3_U, v)));
+}

void main() {

  gl_Position = projection * view *
*                (getBoneMatrix(a_boneNdx[0]) * a_position * a_weight[0] +
*                 getBoneMatrix(a_boneNdx[1]) * a_position * a_weight[1] +
*                 getBoneMatrix(a_boneNdx[2]) * a_position * a_weight[2] +
*                 getBoneMatrix(a_boneNdx[3]) * a_position * a_weight[3]);

}
</code></pre><p>One thing to note is the texture coordinates for the pixels in a texture or texels are
computed from their edges. As we went over in <a href="webgl-3d-textures.html">the article on textures</a>
texture coordinates go from 0 to 1 across the texture. It turns out 0 is the left edge of the left most
pixel and 1 is the right edge of the right most pixel. If you had a 3 pixel wide texture then
it would be like this.</p>
<div class="webgl_center"><img src="resources/texel-coords.svg" style="width: 400px;"></div>

<p>If you want to look up a specific pixel then the formula is</p>
<pre class="prettyprint"><code> (x + .5) / width
</code></pre><p>Above you&#39;ll see for each pixel that&#39;s</p>
<pre class="prettyprint"><code> (0 + .5) / 3  = 0.166
 (1 + .5) / 3 =  0.5
 (2 + .5) / 3 =  0.833
</code></pre><p>or</p>
<div class="webgl_center"><img src="resources/texel-coords-middle.svg" style="width: 400px;"></div>

<p>Now we&#39;ll setup a texture we can put the bone matrices in</p>
<pre class="prettyprint"><code>// prepare the texture for bone matrices
var boneMatrixTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, boneMatrixTexture);
// since we want to use the texture for pure data we turn
// off filtering
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
// also turn off wrapping since the texture might not be a power of 2
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
</code></pre><p>And we&#39;ll pass that texture and number of bones in as uniforms</p>
<pre class="prettyprint"><code>var uniforms = {
  projection: m4.orthographic(-20, 20, -10, 10, -1, 1),
  view: m4.translation(-6, 0, 0),
*  boneMatrixTexture,
*  numBones,
  color: [1, 0, 0, 1],
};
</code></pre><p>Then the only thing we need to change is to update the texture with the
latest bone matrices when rendering</p>
<pre class="prettyprint"><code>// update the texture with the current matrices
gl.bindTexture(gl.TEXTURE_2D, boneMatrixTexture);
gl.texImage2D(
    gl.TEXTURE_2D,
    0,         // level
    gl.RGBA,   // internal format
    4,         // width 4 pixels, each pixel has RGBA so 4 pixels is 16 values
    numBones,  // one row per bone
    0,         // border
    gl.RGBA,   // format
    gl.FLOAT,  // type
    boneArray);
</code></pre><p>The result it the same but we&#39;ve solved the issue that there aren&#39;t
enough uniforms to pass in the matrices via uniforms.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-skinning-bone-matrices-in-texture.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-skinning-bone-matrices-in-texture.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>So that&#39;s the basics of skinning. It&#39;s not so hard to write the code to display
a skinned mesh. The harder part is actually getting data. You generally need
some 3D software like blender/maya/3d studio max, and then to either write
your own exporter or find a an exporter and format that will provide all the data needed. You&#39;ll see as we go over it that there is 10x more code in loading a skin than there is in displaying it and that doesn&#39;t include the probably 20-30x more code in the exporter to get the data out of the 3D modeling program. As an aside this is one of the things people writing their own 3D engine often miss. The engine is the easy part üòú</p>
<p>There&#39;s going to be a lot of code so let&#39;s first try to just get the un-skinned model to display.</p>
<p>Let&#39;s try loading a glTF file. <a href="https://www.khronos.org/gltf/">glTF</a> as it&#39;s
kind of designed for WebGL. Searching the net I found
<a href="https://www.blendswap.com/blends/view/65255">this killer whale blender file</a> by
<a href="https://www.blendswap.com/user/pasilan">Junskie Pastilan</a></p>
<div class="webgl_center"><img src="../resources/models/killer_whale/thumbnail.jpg"></div>

<p>There are 2 top level formats for glTF. The <code>.gltf</code> format is a JSON file that
generally references a <code>.bin</code> file which is a binary file that contains usually
just the geometry and possibly animation data. The other format is <code>.glb</code> which
is a binary format. It&#39;s basically just the JSON and any other files
concatenated into one binary file with a short header and a size/type section
between each concatenated piece. For JavaScript I think the <code>.gltf</code> format is
slightly easier to get started with so let&#39;s try to load that.</p>
<p>First <a href="https://www.blendswap.com/blends/view/65255">I downloaded the .blend file</a>, installed
<a href="https://blender.org">blender</a>, installed 
<a href="https://github.com/KhronosGroup/glTF-Blender-IO">the gltf exporter</a>, loaded the file into
blender and exported.</p>
<div class="webgl_center"><img src="resources/blender-killer-whale.png" style="width: 700px;" class="nobg"></div>

<blockquote>
<p>A quick note: 3D software like Blender, Maya, 3DSMax is extremely complex
software with 1000s of options. When I first learned 3DSMax in 1996 I spent
2-3 hrs a day reading through the 1000+ page manual and working though the
tutorials for about 3 weeks. I did something similar when I learned Maya a few
years later. Blender is just as complicated and further it has a very
different interface from pretty much all other software. This is just a short
way of saying that you should expect to spend some significant time learning
whatever 3D package you decide to use.</p>
</blockquote>
<p>After exporting it I loaded the .gltf file into my text editor and took a look
around. I used <a href="https://www.khronos.org/files/gltf20-reference-guide.pdf">this cheat sheet</a>
to figure out the format.</p>
<p>I want to make it clear the code below is not a perfect glTF loader. It&#39;s just
enough code to get the whale to display. I suspect that if we tried different
files we&#39;d run into areas that need to be changed.</p>
<p>The first thing we need to do is load the file. To make it simpler let&#39;s use
JavaScript&#39;s <a href="https://javascript.info/async-await">async/await</a>. First let&#39;s
write some code to load the <code>.gltf</code> file and any files it references.</p>
<pre class="prettyprint"><code>async function loadGLTF(url) {
  const gltf = await loadJSON(url);

  // load all the referenced files relative to the gltf file
  const baseURL = new URL(url, location.href);
  gltf.buffers = await Promise.all(gltf.buffers.map((buffer) =&gt; {
    const url = new URL(buffer.uri, baseURL.href);
    return loadBinary(url.href);
  }));

  ...

async function loadFile(url, typeFunc) {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`could not load: ${url}`);
  }
  return await response[typeFunc]();
}

async function loadBinary(url) {
  return loadFile(url, &#39;arrayBuffer&#39;);
}

async function loadJSON(url) {
  return loadFile(url, &#39;json&#39;);
}
</code></pre><p>Now we need to walk through the data and connect things up.</p>
<p>First let&#39;s handle what glTF considers a mesh. A mesh is collection of
primitives. A primitive is effectively the buffers and attributes needed to
render something. Let&#39;s use our webgl utilities we covered in <a href="webgl-less-code-more-fun.html">less code more
fun</a>. We&#39;ll walk the meshes and for each one
build a <code>BufferInfo</code> we can pass to <code>webglUtils.setBuffersAndAttributes</code>. Recall
a <code>BufferInfo</code> is effectively just the attribute information, the indices if
there are any, and the number of elements to pass to <code>gl.drawXXX</code>. For example a
cube with just positions and normals might have a BufferInfo with this structure</p>
<pre class="prettyprint"><code>const cubeBufferInfo = {
  attribs: {
    &#39;a_POSITION&#39;: { buffer: WebGLBuffer, type: gl.FLOAT, numComponents: 3, },
    &#39;a_NORMAL&#39;: { buffer: WebGLBuffer, type: gl.FLOAT, numComponents: 3, },
  },
  numElements: 24,
  indices: WebGLBuffer,
  elementType: gl.UNSIGNED_SHORT,
}
</code></pre><p>So we will walk each primitive and generate a BufferInfo like that.</p>
<p>Primitives have an array of attributes, each attribute references an accessor. An accessor says what kind of data is there, for example <code>VEC3</code>/<code>gl.FLOAT</code> and references a bufferView. Given an accessor index we can write some code that returns a WebGLBuffer with the data loaded, the accessor, and the stride specified for the bufferView.</p>
<pre class="prettyprint"><code>// Given an accessor index return an accessor, WebGLBuffer and a stride
function getAccessorAndWebGLBuffer(gl, gltf, accessorIndex) {
  const accessor = gltf.accessors[accessorIndex];
  const bufferView = gltf.bufferViews[accessor.bufferView];
  if (!bufferView.webglBuffer) {
    const buffer = gl.createBuffer();
    const target = bufferView.target || gl.ARRAY_BUFFER;
    const arrayBuffer = gltf.buffers[bufferView.buffer];
    const data = new Uint8Array(arrayBuffer, bufferView.byteOffset, bufferView.byteLength);
    gl.bindBuffer(target, buffer);
    gl.bufferData(target, data, gl.STATIC_DRAW);
    bufferView.webglBuffer = buffer;
  }
  return {
    accessor,
    buffer: bufferView.webglBuffer,
    stride: bufferView.stride || 0,
  };
}
</code></pre><p>We also need a way to convert from an glTF accessor type to a number of components</p>
<pre class="prettyprint"><code>function throwNoKey(key) {
  throw new Error(`no key: ${key}`);
}

const accessorTypeToNumComponentsMap = {
  &#39;SCALAR&#39;: 1,
  &#39;VEC2&#39;: 2,
  &#39;VEC3&#39;: 3,
  &#39;VEC4&#39;: 4,
  &#39;MAT2&#39;: 4,
  &#39;MAT3&#39;: 9,
  &#39;MAT4&#39;: 16,
};

function accessorTypeToNumComponents(type) {
  return accessorTypeToNumComponentsMap[type] || throwNoKey(type);
}
</code></pre><p>Now that we&#39;ve made these functions we can use them to setup our meshes</p>
<p>Note: glTF files can supposedly define materials but the exporter didn&#39;t put any materials in the file even though export materials was checked. I can only guess the exporter doesn&#39;t handle every kind of material in blender which is unfortunate. We&#39;ll use a default material if there is no material in the file. Since there are no materials in this file there&#39;s no code here to use glTF materials.</p>
<pre class="prettyprint"><code>const defaultMaterial = {
  uniforms: {
    u_diffuse: [.5, .8, 1, 1],
  },
};

// setup meshes
gltf.meshes.forEach((mesh) =&gt; {
  mesh.primitives.forEach((primitive) =&gt; {
    const attribs = {};
    let numElements;
    for (const [attribName, index] of Object.entries(primitive.attributes)) {
      const {accessor, buffer, stride} = getAccessorAndWebGLBuffer(gl, gltf, index);
      numElements = accessor.count;
      attribs[`a_${attribName}`] = {
        buffer,
        type: accessor.componentType,
        numComponents: accessorTypeToNumComponents(accessor.type),
        stride,
        offset: accessor.byteOffset | 0,
      };
    }

    const bufferInfo = {
      attribs,
      numElements,
    };

    if (primitive.indices !== undefined) {
      const {accessor, buffer} = getAccessorAndWebGLBuffer(gl, gltf, primitive.indices);
      bufferInfo.numElements = accessor.count;
      bufferInfo.indices = buffer;
      bufferInfo.elementType = accessor.componentType;
    }

    primitive.bufferInfo = bufferInfo;

    // save the material info for this primitive
    primitive.material = gltf.materials &amp;&amp; gltf.materials[primitive.material] || defaultMaterial;
  });
});
</code></pre><p>Now each primitive will have a <code>bufferInfo</code> and a <code>material</code> property.</p>
<p>For skinning we almost always need some kind of scene graph. We created a scene graph in <a href="webgl-scene-graph.html">the article about scene graphs</a> so let&#39;s use that one.</p>
<pre class="prettyprint"><code>class TRS {
  constructor(position = [0, 0, 0], rotation = [0, 0, 0, 1], scale = [1, 1, 1]) {
    this.position = position;
    this.rotation = rotation;
    this.scale = scale;
  }
  getMatrix(dst) {
    dst = dst || new Float32Array(16);
    m4.compose(this.position, this.rotation, this.scale, dst);
    return dst;
  }
}

class Node {
  constructor(source, name) {
    this.name = name;
    this.source = source;
    this.parent = null;
    this.children = [];
    this.localMatrix = m4.identity();
    this.worldMatrix = m4.identity();
    this.drawables = [];
  }
  setParent(parent) {
    if (this.parent) {
      this.parent._removeChild(this);
      this.parent = null;
    }
    if (parent) {
      parent._addChild(this);
      this.parent = parent;
    }
  }
  updateWorldMatrix(parentWorldMatrix) {
    const source = this.source;
    if (source) {
      source.getMatrix(this.localMatrix);
    }

    if (parentWorldMatrix) {
      // a matrix was passed in so do the math
      m4.multiply(parentWorldMatrix, this.localMatrix, this.worldMatrix);
    } else {
      // no matrix was passed in so just copy local to world
      m4.copy(this.localMatrix, this.worldMatrix);
    }

    // now process all the children
    const worldMatrix = this.worldMatrix;
    for (const child of this.children) {
      child.updateWorldMatrix(worldMatrix);
    }
  }
  traverse(fn) {
    fn(this);
    for (const child of this.children) {
      child.traverse(fn);
    }
  }
  _addChild(child) {
    this.children.push(child);
  }
  _removeChild(child) {
    const ndx = this.children.indexOf(child);
    this.children.splice(ndx, 1);
  }
}
</code></pre><p>There are a couple of notable changes from the code in <a href="webgl-scene-graph.html">the scene graph article</a>.</p>
<ul>
<li><p>This code is using the <code>class</code> feature of ES6.</p>
<p>It&#39;s much nicer to use the <code>class</code> syntax than the old style of defining a class.</p>
</li>
<li><p>We added an array of drawables to <code>Node</code></p>
<p>This will list the things to draw from this Node. We&#39;ll put
instances of a class on this list that are responsible for doing
the actual drawing. This way we can generically draw different things
by using different classes.</p>
<p>Note: It&#39;s not clear to me that putting an array of drawables on Node
is the best decision. I feel like the scene graph itself should
maybe not contain drawables at all. Things that need to be drawn could instead
just reference the node in the graph where to get their data.
This way with drawables in the graph is common though so lets start with that.</p>
</li>
<li><p>We added a <code>traverse</code> method.</p>
<p>It calls a function passing it the current node and then recursively doing the
same for all child nodes.</p>
</li>
<li><p>The <code>TRS</code> class is using a quaternion for rotation</p>
<p>We have not covered quaternions and to be honest I don&#39;t think I understand
them well enough to explain them. Fortunately we don&#39;t need to know how they
work to use them. We just take the data out of the gltf file and call
a function that builds a matrix from that data and use the matrix.</p>
</li>
</ul>
<p>The nodes in the glTF file are stored as a flat array.
We&#39;ll convert node data in the glTF to <code>Node</code> instances. We save off the old array
of node data as <code>origNodes</code> as we&#39;ll need it later.</p>
<pre class="prettyprint"><code>const origNodes = gltf.nodes;
gltf.nodes = gltf.nodes.map((n) =&gt; {
  const {name, skin, mesh, translation, rotation, scale} = n;
  const trs = new TRS(translation, rotation, scale);
  const node = new Node(trs, name);
  const realMesh =„ÄÄgltf.meshes[mesh];
  if (realMesh) {
    node.drawables.push(new MeshRenderer(realMesh));
  }
  return node;
});
</code></pre><p>Above we created a <code>TRS</code> instance for each node, a <code>Node</code> instance for each
node, and, if there was a <code>mesh</code> property we looked up the mesh data we setup
before and created a <code>MeshRenderer</code> to draw it.</p>
<p>Let&#39;s make the <code>MeshRenderer</code>. It&#39;s just an encapsulation of the code we used in
<a href="webgl-less-code-more-fun.html">less code more fun</a> to render a single model.
All it does is hold a reference to a mesh and then for each primitive sets up
the program, attributes, and uniforms and finally calls <code>gl.drawArrays</code> or
<code>gl.drawElements</code> via <code>webglUtils.drawBufferInfo</code>;</p>
<pre class="prettyprint"><code>class MeshRenderer {
  constructor(mesh) {
    this.mesh = mesh;
  }
  render(node, projection, view, sharedUniforms) {
    const {mesh} = this;
    gl.useProgram(meshProgramInfo.program);
    for (const primitive of mesh.primitives) {
      webglUtils.setBuffersAndAttributes(gl, meshProgramInfo, primitive.bufferInfo);
      webglUtils.setUniforms(meshProgramInfo, {
        u_projection: projection,
        u_view: view,
        u_world: node.worldMatrix,
      });
      webglUtils.setUniforms(skinProgramInfo, primitive.material.uniforms);
      webglUtils.setUniforms(skinProgramInfo, sharedUniforms);
      webglUtils.drawBufferInfo(gl, primitive.bufferInfo);
    }
  }
}
</code></pre><p>We&#39;ve created the nodes, now we need to actually arrange them into a scene graph. This is done at 2 levels in glTF.
First, each node has an optional array of children that are also indices into the array of nodes so we can walk all
the nodes and parent their children</p>
<pre class="prettyprint"><code>function addChildren(nodes, node, childIndices) {
  childIndices.forEach((childNdx) =&gt; {
    const child = nodes[childNdx];
    child.setParent(node);
  });
}

// arrange nodes into graph
gltf.nodes.forEach((node, ndx) =&gt; {
  const children = origNodes[ndx].children;
  if (children) {
    addChildren(gltf.nodes, node, children);
  }
});
</code></pre><p>Then there is an array of scenes. A scene references an
array of nodes by index into the nodes array that are at the bottom of the scene. It&#39;s not clear to me why they didn&#39;t just start with a single root node but whatever, it&#39;s what&#39;s in the glTF file so we create a root node and parent all the scene&#39;s children to that node</p>
<pre class="prettyprint"><code>  // setup scenes
  for (const scene of gltf.scenes) {
    scene.root = new Node(new TRS(), scene.name);
    addChildren(gltf.nodes, scene.root, scene.nodes);
  }

  return gltf;
}
</code></pre><p>and we&#39;re done with loading, at least just the meshes. Let&#39;s
mark the main function as <code>async</code> so we can use the <code>await</code>
keyword.</p>
<pre class="prettyprint"><code>async function main() {
</code></pre><p>and we can load the gltf file like this</p>
<pre class="prettyprint"><code>const gltf = await loadGLTF(&#39;resources/models/killer_whale/whale.CYCLES.gltf&#39;);
</code></pre><p>To render we need a shader that matches the data in the gltf file. Let&#39;s look at the data in the gltf file for the primitive that&#39;s in it</p>
<pre class="prettyprint"><code>{
    &quot;name&quot; : &quot;orca&quot;,
    &quot;primitives&quot; : [
        {
            &quot;attributes&quot; : {
                &quot;JOINTS_0&quot; : 5,
                &quot;NORMAL&quot; : 2,
                &quot;POSITION&quot; : 1,
                &quot;TANGENT&quot; : 3,
                &quot;TEXCOORD_0&quot; : 4,
                &quot;WEIGHTS_0&quot; : 6
            },
            &quot;indices&quot; : 0
        }
    ]
}
</code></pre><p>Looking at that, to render let&#39;s just use <code>NORMAL</code> and <code>POSITION</code>. We prepended
<code>a_</code> to the front of each attribute so a vertex shader like this should work</p>
<pre class="prettyprint"><code>attribute vec4 a_POSITION;
attribute vec3 a_NORMAL;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;

varying vec3 v_normal;

void main() {
  gl_Position = u_projection * u_view * u_world * a_POSITION;
  v_normal = mat3(u_world) * a_NORMAL;
}
</code></pre><p>and for the fragment shader let&#39;s use a simple directional light</p>
<pre class="prettyprint"><code>precision mediump float;

varying vec3 v_normal;

uniform vec4 u_diffuse;
uniform vec3 u_lightDirection;

void main () {
  vec3 normal = normalize(v_normal);
  float light = dot(u_lightDirection, normal) * .5 + .5;
  gl_FragColor = vec4(u_diffuse.rgb * light, u_diffuse.a);
}
</code></pre><p>Notice we take the dot product like we covered in <a href="webgl-3d-lighting-directional.html">the article on directional lights</a>
but unlike that one, here the dot product is multiplied by .5 and we add .5. 
With normal directional lighting the surface is lit 100% when directly facing
the light and trails off to 0% when the surface is perpendicular to the light.
That means the entire 1/2 of the model facing away from the light is black.
By multiplying by .5 and adding .5 we take the dot product from -1 &lt;-&gt; 1 to 0 &lt;-&gt; 
1 which means it will only be black when facing the complete opposite direction.
This gives a cheap but pleasing lighting for simple tests.</p>
<p>So, we need to compile and link the shaders.</p>
<pre class="prettyprint"><code>// compiles and links the shaders, looks up attribute and uniform locations
const meshProgramInfo = webglUtils.createProgramInfo(gl, [&quot;meshVS&quot;, &quot;fs&quot;]);
</code></pre><p>and then to render all that&#39;s different from before is this</p>
<pre class="prettyprint"><code>const sharedUniforms = {
  u_lightDirection: m4.normalize([-1, 3, 5]),
};

function renderDrawables(node) {
  for(const drawable of node.drawables) {
      drawable.render(node, projection, view, sharedUniforms);
  }
}

for (const scene of gltf.scenes) {
  // update all world matrices in the scene.
  scene.root.updateWorldMatrix();
  // walk the scene and render all renderables
  scene.root.traverse(renderDrawables);
}
</code></pre><p>Left over from before (not shown above) is our code for computing a projection matrix, camera matrix, and view matrix. We then just walk each scene, call <code>scene.root.updateWorldMatrix</code> which will update the world
matrix of all the nodes in that graph. Then we call <code>scene.root.traverse</code> with <code>renderDrawables</code>.</p>
<p><code>renderDrawables</code> calls the render method of all the drawables on that node passing in the projection, view, and lighting info via <code>sharedUniforms</code>.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-skinning-3d-gltf.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-skinning-3d-gltf.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>Now that that&#39;s working let&#39;s handle the skins.</p>
<p>First let&#39;s make a class to represent a skin. It will manage the list of joints, which is another word for nodes in the scene graph that apply to the skin. It will also have the inverse bind matrices and it will manage the texture we put the joint matrices in.</p>
<pre class="prettyprint"><code>class Skin {
  constructor(joints, inverseBindMatrixData) {
    this.joints = joints;
    this.inverseBindMatrices = [];
    this.jointMatrices = [];
    // allocate enough space for one matrix per joint
    this.jointData = new Float32Array(joints.length * 16);
    // create views for each joint and inverseBindMatrix
    for (let i = 0; i &lt; joints.length; ++i) {
      this.inverseBindMatrices.push(new Float32Array(
          inverseBindMatrixData.buffer,
          inverseBindMatrixData.byteOffset + Float32Array.BYTES_PER_ELEMENT * 16 * i,
          16));
      this.jointMatrices.push(new Float32Array(
          this.jointData.buffer,
          Float32Array.BYTES_PER_ELEMENT * 16 * i,
          16));
    }
    // create a texture to hold the joint matrices
    this.jointTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this.jointTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  }
  update(node) {
    const globalWorldInverse = m4.inverse(node.worldMatrix);
    // go through each joint and get its current worldMatrix
    // apply the inverse bind matrices and store the
    // entire result in the texture
    for (let j = 0; j &lt; this.joints.length; ++j) {
      const joint = this.joints[j];
      const dst = this.jointMatrices[j];
      m4.multiply(globalWorldInverse, joint.worldMatrix, dst);
      m4.multiply(dst, this.inverseBindMatrices[j], dst);
    }
    gl.bindTexture(gl.TEXTURE_2D, this.jointTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 4, this.joints.length, 0,
                  gl.RGBA, gl.FLOAT, this.jointData);
  }
}
</code></pre><p>And like we had a <code>MeshRenderer</code> let&#39;s make a <code>SkinRenderer</code> that uses the <code>Skin</code> to render a skinned mesh.</p>
<pre class="prettyprint"><code>class SkinRenderer {
  constructor(mesh, skin) {
    this.mesh = mesh;
    this.skin = skin;
  }
  render(node, projection, view, sharedUniforms) {
    const {skin, mesh} = this;
    skin.update(node);
    gl.useProgram(skinProgramInfo.program);
    for (const primitive of mesh.primitives) {
      webglUtils.setBuffersAndAttributes(gl, skinProgramInfo, primitive.bufferInfo);
      webglUtils.setUniforms(skinProgramInfo, {
        u_projection: projection,
        u_view: view,
        u_world: node.worldMatrix,
        u_jointTexture: skin.jointTexture,
        u_numJoints: skin.joints.length,
      });
      webglUtils.setUniforms(skinProgramInfo, primitive.material.uniforms);
      webglUtils.setUniforms(skinProgramInfo, sharedUniforms);
      webglUtils.drawBufferInfo(gl, primitive.bufferInfo);
    }
  }
}
</code></pre><p>You can see it&#39;s very similar to the <code>MeshRenderer</code>. It has a reference to a <code>Skin</code> which it uses to update all the matrices needed to render. Then it follows the standard pattern for rendering, using the program, setting up the attributes, setting all the uniforms using <code>webglUtils.setUniforms</code> which also binds textures, and then rendering.</p>
<p>We also need a vertex shader that supports skinning</p>
<pre class="prettyprint"><code>&lt;script id=&quot;skinVS&quot; type=&quot;notjs&quot;&gt;
attribute vec4 a_POSITION;
attribute vec3 a_NORMAL;
attribute vec4 a_WEIGHTS_0;
attribute vec4 a_JOINTS_0;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;
uniform sampler2D u_jointTexture;
uniform float u_numJoints;

varying vec3 v_normal;

// these offsets assume the texture is 4 pixels across
#define ROW0_U ((0.5 + 0.0) / 4.)
#define ROW1_U ((0.5 + 1.0) / 4.)
#define ROW2_U ((0.5 + 2.0) / 4.)
#define ROW3_U ((0.5 + 3.0) / 4.)

mat4 getBoneMatrix(float jointNdx) {
  float v = (jointNdx + 0.5) / u_numJoints;
  return mat4(
    texture2D(u_jointTexture, vec2(ROW0_U, v)),
    texture2D(u_jointTexture, vec2(ROW1_U, v)),
    texture2D(u_jointTexture, vec2(ROW2_U, v)),
    texture2D(u_jointTexture, vec2(ROW3_U, v)));
}

void main() {
  mat4 skinMatrix = getBoneMatrix(a_JOINTS_0[0]) * a_WEIGHTS_0[0] +
                    getBoneMatrix(a_JOINTS_0[1]) * a_WEIGHTS_0[1] +
                    getBoneMatrix(a_JOINTS_0[2]) * a_WEIGHTS_0[2] +
                    getBoneMatrix(a_JOINTS_0[3]) * a_WEIGHTS_0[3];
  mat4 world = u_world * skinMatrix;
  gl_Position = u_projection * u_view * world * a_POSITION;
  v_normal = mat3(world) * a_NORMAL;
}
&lt;/script&gt;
</code></pre><p>This is pretty much the same as our skinning shader above. We renamed the
attributes to match what&#39;s in the gltf file. The biggest change it making a
<code>skinMatrix</code>. In our previous skinning shader we multiplied the position by each
individual joint/bone matrix and multiplied those by the weight of influence for
each joint. In this case we instead add up the matrices multiplied by the
weights and just multiply by position once. This produces same result but we can
use the <code>skinMatrix</code> to multiply the normal as well which we need to do
otherwise the normals won&#39;t match the skin.</p>
<p>Also notice we multiply in the <code>u_world</code> matrix here. We subtracted it out in <code>Skin.update</code> with these lines</p>
<pre class="prettyprint"><code>*const globalWorldInverse = m4.inverse(node.worldMatrix);
// go through each joint and get its current worldMatrix
// apply the inverse bind matrices and store the
// entire result in the texture
for (let j = 0; j &lt; this.joints.length; ++j) {
  const joint = this.joints[j];
  const dst = this.jointMatrices[j];
*  m4.multiply(globalWorldInverse, joint.worldMatrix, dst);
</code></pre><p>Whether you do that or not is up to you. The reason to do it is it lets you
instance the skin. In other words you can render the skinned mesh in the exact
same pose at more than one place in the same frame. The idea being that if there
are lots of joints then doing all the matrix math for a skinned mesh is slow so
you do that math once and then you can display that skinned mesh in different
places just by re-rendering with a different world matrix.</p>
<p>That&#39;s maybe useful for displaying a crowd of characters. Unfortunately all the
characters will be in the exact same pose so it&#39;s unclear to me if it&#39;s really
that useful or not. How often does that situation actually come up? You can
remove multiplying by the inverse world matrix of the node in <code>Skin</code> and remove
multiplying by <code>u_world</code> in the shader and the result will look the same, you
just can&#39;t <em>instance</em> that skinned mesh. Of course you can render the same
skinned mesh as many times as you want in different poses. You&#39;ll need a
different <code>Skin</code> object pointing to different nodes that are in some other
orientation.</p>
<p>Back in our loading code, when we&#39;re making <code>Node</code> instances, if there&#39;s a
<code>skin</code> property we&#39;ll remember it so we can make a <code>Skin</code> for it.</p>
<pre class="prettyprint"><code>+const skinNodes = [];
const origNodes = gltf.nodes;
gltf.nodes = gltf.nodes.map((n) =&gt; {
  const {name, skin, mesh, translation, rotation, scale} = n;
  const trs = new TRS(translation, rotation, scale);
  const node = new Node(trs, name);
  const realMesh =„ÄÄgltf.meshes[mesh];
+  if (skin !== undefined) {
+    skinNodes.push({node, mesh: realMesh, skinNdx: skin});
+  } else if (realMesh) {
    node.drawables.push(new MeshRenderer(realMesh));
  }
  return node;
});
</code></pre><p>After making <code>Node</code>s we need to make <code>Skin</code>s. Skins reference nodes via a
<code>joints</code> array which is a list of indices of nodes that supply the matrices for
the joints. A skin also references an accessor that references the inverse bind
pose matrices saved in the file.</p>
<pre class="prettyprint"><code>// setup skins
gltf.skins = gltf.skins.map((skin) =&gt; {
  const joints = skin.joints.map(ndx =&gt; gltf.nodes[ndx]);
  const {stride, array} = getAccessorTypedArrayAndStride(gl, gltf, skin.inverseBindMatrices);
  return new Skin(joints, array);
});
</code></pre><p>The code above called <code>getAccessorTypedArrayAndStride</code> given an accessor index.
We need supply that code. For a given accessor we&#39;ll return a
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">TypedArray</a>
view of the correct type to get access to the data in the buffer.</p>
<pre class="prettyprint"><code>const glTypeToTypedArrayMap = {
  &#39;5120&#39;: Int8Array,    // gl.BYTE
  &#39;5121&#39;: Uint8Array,   // gl.UNSIGNED_BYTE
  &#39;5122&#39;: Int16Array,   // gl.SHORT
  &#39;5123&#39;: Uint16Array,  // gl.UNSIGNED_SHORT
  &#39;5124&#39;: Int32Array,   // gl.INT
  &#39;5125&#39;: Uint32Array,  // gl.UNSIGNED_INT
  &#39;5126&#39;: Float32Array, // gl.FLOAT
}

// Given a GL type return the TypedArray needed
function glTypeToTypedArray(type) {
  return glTypeToTypedArrayMap[type] || throwNoKey(type);
}

// given an accessor index return both the accessor and
// a TypedArray for the correct portion of the buffer
function getAccessorTypedArrayAndStride(gl, gltf, accessorIndex) {
  const accessor = gltf.accessors[accessorIndex];
  const bufferView = gltf.bufferViews[accessor.bufferView];
  const TypedArray = glTypeToTypedArray(accessor.componentType);
  const buffer = gltf.buffers[bufferView.buffer];
  return {
    accessor,
    array: new TypedArray(
        buffer,
        bufferView.byteOffset + (accessor.byteOffset || 0),
        accessor.count * accessorTypeToNumComponents(accessor.type)),
    stride: bufferView.byteStride || 0,
  };
}
</code></pre><p>Something to note about the code above is we&#39;ve made a table with hard coded
WebGL constants. This is the first time we&#39;ve done this. The constants won&#39;t
change so this is safe to do.</p>
<p>Now what we have the skins we can go back and add them to the nodes that referenced them.</p>
<pre class="prettyprint"><code>// Add SkinRenderers to nodes with skins
for (const {node, mesh, skinNdx} of skinNodes) {
  node.drawables.push(new SkinRenderer(mesh, gltf.skins[skinNdx]));
}
</code></pre><p>If we rendered like this we might not see any difference. We need to animate
some of the nodes. Let&#39;s just go through each node in the <code>Skin</code>, in other words
each joint, and rotate it plus a minus a little on the local X access.</p>
<p>To do this we&#39;ll save off the original local matrix for each joint. We&#39;ll then
rotate that original matrix some amount each frame, and using a special
function, <code>m4.decompose</code>, will will convert the matrix back into position,
rotation, scale into the joint.</p>
<pre class="prettyprint"><code>const origMatrix = new Map();
function animSkin(skin, a) {
  for(let i = 0; i &lt; skin.joints.length; ++i) {
    const joint = skin.joints[i];
    // if there is no matrix saved for this joint
    if (!origMatrix.has(joint)) {
      // save a matrix for joint
      origMatrix.set(joint, joint.source.getMatrix());
    }
    // get the original matrix
    const origMatrix = origRotations.get(joint);
    // rotate it
    const m = m4.xRotate(origMatrix, a);
    // decompose it back into position, rotation, scale
    // into the joint
    m4.decompose(m, joint.source.position, joint.source.rotation, joint.source.scale);
  }
}
</code></pre><p>and then just before rendering we&#39;ll call that</p>
<pre class="prettyprint"><code>animSkin(gltf.skins[0], Math.sin(time) * .5);
</code></pre><p>Note <code>animSkin</code> is mostly a hack. Ideally we&#39;d load an animation some artist
created OR we&#39;d know the names of specific joints we want to manipulate in code
in some way. In this case we just to see if our skinning is working and this
seemed like the easiest way to do it.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-skinning-3d-gltf-skinned.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-skinning-3d-gltf-skinned.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>A few more notes before we move on</p>
<p>When I first tried to get this working, as with most programs things didn&#39;t appear on the screen.</p>
<p>So, the first thing did was go to the end of the skinning shader and add this line</p>
<pre class="prettyprint"><code>  gl_Position = u_projection * u_view *  a_POSITION;
</code></pre><p>In the fragment shader I changed it to just draw a solid color by adding this at the end</p>
<pre class="prettyprint"><code>gl_FragColor = vec4(1, 0, 0, 1);
</code></pre><p>This removes all the skinning and just draws the mesh at the origin. I adjusted the camera position until I had a good view.</p>
<pre class="prettyprint"><code>const cameraPosition = [5, 0, 5];
const target = [0, 0, 0];
</code></pre><p>This showed a silhouette of the killer whale so I knew at least some of the data was working.</p>
<div class="webgl_center"><img src="resources/skinning-debug-01.png"></div>

<p>Next I made the fragment shader show the normals</p>
<pre class="prettyprint"><code>gl_FragColor = vec4(normalize(v_normal) * .5 + .5, 1);
</code></pre><p>Normals go from -1 to 1 so the <code>* .5 + .5</code> adjusts them to 0 to 1 for viewing as colors.</p>
<p>Back in the vertex shader I just passed the normal through</p>
<pre class="prettyprint"><code>v_normal = a_NORMAL;
</code></pre><p>Which gave me a view like this</p>
<div class="webgl_center"><img src="resources/skinning-debug-02.png"></div>

<p>I didn&#39;t expect the normals to be bad but it was good to start with something I expected to work and confirm that it does indeed work.</p>
<p>Next I thought I&#39;d check the weights. All I needed to do was
pass the weights as normals from the vertex shader</p>
<pre class="prettyprint"><code>v_normal = a_WEIGHTS_0.xyz * 2. - 1.;
</code></pre><p>Weights go from 0 to 1 but since the fragment shader is expecting normals I just made the weights go from -1 to 1</p>
<p>This originally produced a kind of mess of colors. Once I figured out the bug, I got an image like this</p>
<div class="webgl_center"><img src="resources/skinning-debug-03.png"></div>

<p>It&#39;s not entirely obvious it&#39;s correct but does make some sense. You&#39;d expect
the vertices nearest each bone to have a strong color and you&#39;d expect to see
rings of that color in the vertices around the bone since the weights in that
area are likely 1.0 or at least all similar.</p>
<p>Since the original image was so messy I also tried displaying the joint indices with</p>
<pre class="prettyprint"><code>v_normal = a_JOINTS_0.xyz / (u_numJoints - 1.) * 2. - 1.;
</code></pre><p>The indices go from 0 to numJoints - 1 so the code above would give values from -1 to 1.</p>
<p>Once things were working I got an image like this</p>
<div class="webgl_center"><img src="resources/skinning-debug-04.png"></div>

<p>Again it was originally a mess of colors. The image above is what it looked like
after it was fixed. That&#39;s pretty much what you&#39;d expect to see for weights for
the killer whale. Rings of color around each bone.</p>
<p>The bug had to do with how <code>webgl.createBufferInfoFromArrays</code> was figuring out
the number of components. There were cases where it ignored the one specified,
tried to guess, and guessed wrong. Once the bug was fixed then I removed those
changes to the shaders. Note that I left them in the code above commented out if
you want to play with them.</p>
<p>I want to make it clear the code above is meant to help explain skinning. It is
not meant to be a production ready skinning engine. I think if we were to try to
make a production quality engine we&#39;d run into many things we&#39;d probably want to
change but I hope going through this example helps slight demystify skinning.</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-skinning.html" selected>English</a>
    <option value="/webgl/lessons/fr/webgl-skinning.html" >Fran√ßais</a>
    <option value="/webgl/lessons/ja/webgl-skinning.html" >Êó•Êú¨Ë™û</a>
    <option value="/webgl/lessons/ko/webgl-skinning.html" >ÌïúÍµ≠Ïñ¥</a>
    <option value="/webgl/lessons/pl/webgl-skinning.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-skinning.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-skinning.html" >–†—É—Å—Å–∫–∏–π</a>
    <option value="/webgl/lessons/zh_cn/webgl-skinning.html" >ÁÆÄ‰Ωì‰∏≠Êñá</a>
</select>


        <div id="toc">
          <ul>  <li>Fundamentals</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgl/lessons/webgl-how-it-works.html">How It Works</a></li>
<li><a href="/webgl/lessons/webgl-shaders-and-glsl.html">Shaders and GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL State Diagram</a></li>
        </ul>
  <li>Image Processing</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-image-processing.html">Image Processing</a></li>
<li><a href="/webgl/lessons/webgl-image-processing-continued.html">Image Processing Continued</a></li>
        </ul>
  <li>2D translation, rotation, scale, matrix math</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-translation.html">2D Translation</a></li>
<li><a href="/webgl/lessons/webgl-2d-rotation.html">2D Rotation</a></li>
<li><a href="/webgl/lessons/webgl-2d-scale.html">2D Scale</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrices.html">2D Matrices</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-orthographic.html">Orthographic 3D</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective.html">3D Perspective</a></li>
<li><a href="/webgl/lessons/webgl-3d-camera.html">3D Cameras</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Structure and Organization</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/webgl-drawing-multiple-things.html">Drawing Multiple Things</a></li>
<li><a href="/webgl/lessons/webgl-scene-graph.html">Scene Graphs</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-geometry-lathe.html">Geometry - Lathe</a></li>
        </ul>
  <li>Textures</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-textures.html">Textures</a></li>
<li><a href="/webgl/lessons/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/webgl-2-textures.html">Using 2 or More Textures</a></li>
<li><a href="/webgl/lessons/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective-correct-texturemapping.html">Perspective Correct Texture Mapping</a></li>
<li><a href="/webgl/lessons/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>Rendering To A Texture</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-render-to-texture.html">Render to Texture</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrix-stack.html">2D - Matrix Stack</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/webgl-fog.html">Fog</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-text-html.html">Text - HTML</a></li>
<li><a href="/webgl/lessons/webgl-text-canvas2d.html">Text - Canvas 2D</a></li>
<li><a href="/webgl/lessons/webgl-text-texture.html">Text - Using a Texture</a></li>
<li><a href="/webgl/lessons/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
  <li>Textures</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-ramp-textures.html">Ramp Textures (Toon Shading)</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-setup-and-installation.html">Setup And Installation</a></li>
<li><a href="/webgl/lessons/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/webgl-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgl/lessons/webgl-animation.html">Animation</a></li>
<li><a href="/webgl/lessons/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/webgl-instanced-drawing.html">Instanced Drawing</a></li>
<li><a href="/webgl/lessons/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/webgl-and-alpha.html">WebGL and Alpha</a></li>
<li><a href="/webgl/lessons/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#html-background">Use WebGL as Background in HTML</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="http://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
    <div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgl">Ask on stackoverflow</a>.</div>
    <div>Issue/Bug? <a href="http://github.com/gfxfundamentals/webgl-fundamentals/issues">Create an issue on github</a>.</div>
    <div class="lesson-comment-notes">
       Use <b>&lt;pre&gt;&lt;code&gt;</b>code goes here<b>&lt;/code&gt;&lt;/pre&gt;</b> for code blocks
    </div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL Skinning';
            var disqus_title = 'WebGL Skinning';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
      return;
  }

  function addScript(src, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTag('script')[0];
    script.async = true;
    script.defer = true;
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  addScript('//cdn.webglstats.com/stat.js');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>



