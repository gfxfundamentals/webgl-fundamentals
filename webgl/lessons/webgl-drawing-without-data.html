<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/webgl-drawing-without-data.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Creative Coding - Drawing Without Data" />
<meta name="keywords" content="webgl graphics" />
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-drawing-without-data_en.jpg" />

<meta property="og:title" content="WebGL Drawing Without Data" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-drawing-without-data_en.jpg" />
<meta property="og:description" content="Creative Coding - Drawing Without Data" />
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/webgl-drawing-without-data.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webglfundamentals.org" />
<meta name="twitter:title" content="WebGL Drawing Without Data" />
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/webgl-drawing-without-data.html" />
<meta name="twitter:description" content="Creative Coding - Drawing Without Data" />
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-drawing-without-data_en.jpg" />

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/webgl-drawing-without-data.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-drawing-without-data_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/webgl-drawing-without-data.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/webgl-drawing-without-data.html",
      "inLanguage":"en",
      "name":"WebGL Drawing Without Data",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/webgl-drawing-without-data.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL Drawing Without Data</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />



</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-drawing-without-data.html" selected>English</a>
    <option value="/webgl/lessons/fr/webgl-drawing-without-data.html" >Fran√ßais</a>
    <option value="/webgl/lessons/ja/webgl-drawing-without-data.html" >Êó•Êú¨Ë™û</a>
    <option value="/webgl/lessons/ko/webgl-drawing-without-data.html" >ÌïúÍµ≠Ïñ¥</a>
    <option value="/webgl/lessons/pl/webgl-drawing-without-data.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-drawing-without-data.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-drawing-without-data.html" >–†—É—Å—Å–∫–∏–π</a>
    <option value="/webgl/lessons/zh_cn/webgl-drawing-without-data.html" >ÁÆÄ‰Ωì‰∏≠Êñá</a>
</select>


    <a href="#toc">Table of Contents</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub a {
    background: #000;
    color: #fff;
    text-decoration: none;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 2rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 300px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(150px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a:hover {
    background: #c11;
    color: #fff;
}
#forkongithub a::before,#forkongithub a::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub a::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
@media (max-width: 900px) {
    #forkongithub a{
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub a{
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL Drawing Without Data</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>This article assumes you&#39;ve read many of the other articles
starting with <a href="webgl-fundamentals.html">the fundamentals</a>.
If you have not read them please start there first.</p>
<p>In <a href="webgl-smallest-programs.html">the article on the smallest WebGL programs</a>
we covered some examples of drawing with very little code.
In this article will go over drawing with no data.</p>
<p>Traditionally, WebGL apps put geometry data in buffers.
They then use attributes to pull vertex data from those buffers
into shaders and convert them to clip space.</p>
<p>The word <strong>traditionally</strong> is important. It&#39;s only a <strong>tradition</strong>
to do it this way. It is in no way a requirement. WebGL doesn&#39;t
care how we do it, it only cares that our vertex shaders
assign clip space coordinates to <code>gl_Position</code>.</p>
<p>So, let&#39;s provide only a count as an attribute instead of positions</p>
<pre class="prettyprint"><code class="lang-js">const numVerts = 20;
const vertexIds = new Float32Array(numVerts);
vertexIds.forEach((v, i) =&gt; {
  vertexIds[i] = i;
});

const idBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, idBuffer);
gl.bufferData(gl.ARRAY_BUFFER, vertexIds, gl.STATIC_DRAW);
</code></pre>
<p>Now let&#39;s make a vertex shader to draw a circle of points based on that count.</p>
<pre class="prettyprint"><code class="lang-glsl">attribute float vertexId;
uniform float numVerts;

#define PI radians(180.0)

void main() {
  float u = vertexId / numVerts;      // goes from 0 to 1
  float angle = u * PI * 2.0;         // goes from 0 to 2PI
  float radius = 0.8;

  vec2 pos = vec2(cos(angle), sin(angle)) * radius;

  gl_Position = vec4(pos, 0, 1);
  gl_PointSize = 5.0;
}
</code></pre>
<p>The code above should be pretty straight forward.
<code>vertexId</code> is going to count from 0 to <code>numVerts</code>.
Based on that we generate positions for a circle.</p>
<p>If we stopped there the circle would be an ellipse
because clip space is normalized (goes from -1 to 1)
across and down the canvas. If we pass in the resolution
we can take into account that -1 to 1 across might not
represent the same space as -1 to 1 down the canvas.</p>
<pre class="prettyprint"><code class="lang-glsl">attribute float vertexId;
uniform float numVerts;
+uniform vec2 resolution;

#define PI radians(180.0)

void main() {
  float u = vertexId / numVerts;      // goes from 0 to 1
  float angle = u * PI * 2.0;         // goes from 0 to 2PI
  float radius = 0.8;

  vec2 pos = vec2(cos(angle), sin(angle)) * radius;

+  float aspect = resolution.y / resolution.y;
+  vec2 scale = vec2(aspect, 1);

+  gl_Position = vec4(pos * scale, 0, 1);
  gl_PointSize = 5.0;
}
</code></pre>
<p>And our fragment shader can just draw a solid color</p>
<pre class="prettyprint"><code class="lang-glsl">precision mediump float;

void main() {
  gl_FragColor = vec4(1, 0, 0, 1);
}
</code></pre>
<p>In our JavaScript at init time we&#39;ll compile the shader and look up the attributes and uniforms,</p>
<pre class="prettyprint"><code class="lang-js">// setup GLSL program
const program = webglUtils.createProgramFromSources(gl, [vs, fs]);
const vertexIdLoc = gl.getAttribLocation(program, &#39;vertexId&#39;);
const numVertsLoc = gl.getUniformLocation(program, &#39;numVerts&#39;);
const resolutionLoc = gl.getUniformLocation(program, &#39;resolution&#39;);
</code></pre>
<p>And to render we&#39;ll use the program, setup our one attribute with vertex ids,
set the <code>resolution</code> and <code>numVerts</code> uniforms, and finally draw the points.</p>
<pre class="prettyprint"><code class="lang-js">gl.useProgram(program);

{
  // Turn on the attribute
  gl.enableVertexAttribArray(vertexIdLoc);

  // Bind the id buffer.
  gl.bindBuffer(gl.ARRAY_BUFFER, idBuffer);

  // Tell the attribute how to get data out of idBuffer (ARRAY_BUFFER)
  const size = 1;          // 1 components per iteration
  const type = gl.FLOAT;   // the data is 32bit floats
  const normalize = false; // don&#39;t normalize the data
  const stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
  const offset = 0;        // start at the beginning of the buffer
  gl.vertexAttribPointer(
      vertexIdLoc, size, type, normalize, stride, offset);
}

// tell the shader the number of verts
gl.uniform1f(numVertsLoc, numVerts);
// tell the shader the resolution
gl.uniform2f(resolutionLoc, gl.canvas.width, gl.canvas.height);

const offset = 0;
gl.drawArrays(gl.POINTS, offset, numVerts);
</code></pre>
<p>And we get a circle of points.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-no-data-point-circle.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-no-data-point-circle.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>Is this technique useful? Well with some creative code
we could make a starfield or a simple rain effect with
almost no data and a single draw call.</p>
<p>Let&#39;s do the rain just to see it work. First we&#39;ll
change the vertex shader to</p>
<pre class="prettyprint"><code class="lang-glsl">attribute float vertexId;
uniform float numVerts;
uniform float time;

void main() {
  float u = vertexId / numVerts;          // goes from 0 to 1
  float x = u * 2.0 - 1.0;                // -1 to 1
  float y = fract(time + u) * -2.0 + 1.0; // 1.0 -&gt;  -1.0

  gl_Position = vec4(x, y, 0, 1);
  gl_PointSize = 5.0;
}
</code></pre>
<p>For this situation we don&#39;t need the resolution.</p>
<p>We&#39;ve added a <code>time</code> uniform which will be the time
in seconds since the page loaded.</p>
<p>For &#39;x&#39; we&#39;re just going to go from -1 to 1</p>
<p>For &#39;y&#39; we use <code>time + u</code> but <code>fract</code> returns
only the fractional portion so a value from 0.0 to 1.0.
By expanding that to 1.0 to -1.0 we get a y that repeats
over time but one that is offset differently for each
point.</p>
<p>Let&#39;s change the color to blue in the fragment shader.</p>
<pre class="prettyprint"><code class="lang-glsl">precision mediump float;

void main() {
-  gl_FragColor = vec4(1, 0, 0, 1);
+  gl_FragColor = vec4(0, 0, 1, 1);
}
</code></pre>
<p>Then in JavaScript we need to look up the time uniform</p>
<pre class="prettyprint"><code class="lang-js">// setup GLSL program
const program = webglUtils.createProgramFromSources(gl, [vs, fs]);
const vertexIdLoc = gl.getAttribLocation(program, &#39;vertexId&#39;);
const numVertsLoc = gl.getUniformLocation(program, &#39;numVerts&#39;);
-const resolutionLoc = gl.getUniformLocation(program, &#39;resolution&#39;);
+const timeLoc = gl.getUniformLocation(program, &#39;time&#39;);
</code></pre>
<p>And we need to convert to code to <a href="webgl-animation.html">animate</a>
by creating a render loop and setting the <code>time</code> uniform.</p>
<pre class="prettyprint"><code class="lang-js">+function render(time) {
+  time *= 0.001;  // convert to seconds

+  webglUtils.resizeCanvasToDisplaySize(gl.canvas);
+  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  gl.useProgram(program);

  {
    // Turn on the attribute
    gl.enableVertexAttribArray(vertexIdLoc);

    // Bind the id buffer.
    gl.bindBuffer(gl.ARRAY_BUFFER, idBuffer);

    // Tell the attribute how to get data out of idBuffer (ARRAY_BUFFER)
    const size = 1;          // 1 components per iteration
    const type = gl.FLOAT;   // the data is 32bit floats
    const normalize = false; // don&#39;t normalize the data
    const stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
    const offset = 0;        // start at the beginning of the buffer
    gl.vertexAttribPointer(
        vertexIdLoc, size, type, normalize, stride, offset);
  }

  // tell the shader the number of verts
  gl.uniform1f(numVertsLoc, numVerts);
+  // tell the shader the time
+  gl.uniform1f(timeLoc, time);

  const offset = 0;
  gl.drawArrays(gl.POINTS, offset, numVerts);

+  requestAnimationFrame(render);
+}
+requestAnimationFrame(render);
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-no-data-point-rain-linear.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-no-data-point-rain-linear.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>This gives us POINTS going down the screen but they are all
in order. We need to add some randomness. There is no
random number generator in GLSL. Instead we can use a
function that generates something that appears random
enough.</p>
<p>Here&#39;s one</p>
<pre class="prettyprint"><code class="lang-glsl">// hash function from https://www.shadertoy.com/view/4djSRW
// given a value between 0 and 1
// returns a value between 0 and 1 that *appears* kind of random
float hash(float p) {
  vec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));
  p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));
  return fract(p2.x * p2.y * 95.4337);
}
</code></pre>
<p>and we can use that like this</p>
<pre class="prettyprint"><code class="lang-glsl">void main() {
  float u = vertexId / numVerts;          // goes from 0 to 1
-  float x = u * 2.0 - 1.0;                // -1 to 1
+  float x = hash(u) * 2.0 - 1.0;          // random position
  float y = fract(time + u) * -2.0 + 1.0; // 1.0 -&gt;  -1.0

  gl_Position = vec4(x, y, 0, 1);
  gl_PointSize = 5.0;
}
</code></pre>
<p>We pass <code>hash</code> our previous 0 to 1 value and it gives us
back a pseudo random 0 to 1 value.</p>
<p>Let&#39;s also make the points smaller</p>
<pre class="prettyprint"><code class="lang-glsl">  gl_Position = vec4(x, y, 0, 1);
-  gl_PointSize = 5.0;
+  gl_PointSize = 2.0;
</code></pre>
<p>And bump up the number of points we&#39;re drawing</p>
<pre class="prettyprint"><code class="lang-js">-const numVerts = 20;
+const numVerts = 400;
</code></pre>
<p>And with that we get</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-no-data-point-rain.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-no-data-point-rain.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>If you look really closely you can see the rain is repeating.
Look for some clump of points and watch as they fall off
the bottom and pop back on the top.
If there was more going on in the background like if
this cheap rain effect was happening over a 3D game
it&#39;s possible no one would ever notice it&#39;s repeating.</p>
<p>We can fix the repetition by adding in a little more randomness.</p>
<pre class="prettyprint"><code class="lang-glsl">void main() {
  float u = vertexId / numVerts;          // goes from 0 to 1
+  float off = floor(time + u) / 1000.0;   // changes once per second per vertex
-  float x = hash(u) * 2.0 - 1.0;          // random position
+  float x = hash(u + off) * 2.0 - 1.0;    // random position
  float y = fract(time + u) * -2.0 + 1.0; // 1.0 -&gt;  -1.0

  gl_Position = vec4(x, y, 0, 1);
  gl_PointSize = 2.0;
}
</code></pre>
<p>In the code above we added <code>off</code>. Since we&#39;re calling <code>floor</code>
the value of <code>floor(time + u)</code> will effectively give us
a second timer that only changes once per second for each vertex.
This offset is in sync with the code moving the point down the screen
so at the same instance the point jumps back to the top
of the screen some small amount is added to the value
<code>hash</code> is being passed which means this particular point
will get a new random number and therefore a new random horizontal position.</p>
<p>The result is a rain effect that doesn&#39;t appear to repeat</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-no-data-point-rain-less-repeat.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-no-data-point-rain-less-repeat.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>Can we do more than <code>gl.POINTS</code>? Of course! </p>
<p>Let&#39;s make circles. To do this we need triangles around
a center like slices of pie. We can think of each triangle
as 2 points around the edge of the pie followed by 1 point in the center.
We then repeat for each slice of the pie.</p>
<div class="webgl_center"><img src="resources/circle-points.svg" style="width: 400px;"></div>

<p>So first we want some kind of counter that changes once per pie slice</p>
<pre class="prettyprint"><code class="lang-glsl">float sliceId = floor(vertexId / 3.0);
</code></pre>
<p>Then we need a count around the edge of the circle that goes</p>
<pre class="prettyprint"><code>0, 1, ?, 1, 2, ?, 2, 3, ?, ...
</code></pre><p>The ? value doesn&#39;t really matter because looking at the
diagram above the 3rd value is always in the center (0,0)
so we can just multiply by 0 regardless of value.</p>
<p>To get the pattern above this would work</p>
<pre class="prettyprint"><code class="lang-glsl">float triVertexId = mod(vertexId, 3.0);
float edge = triVertexId + sliceId;
</code></pre>
<p>For points on the edge vs points in the center we need
this pattern. 2 on the edge then 1 in the center, repeat.</p>
<pre class="prettyprint"><code>1, 1, 0, 1, 1, 0, 1, 1, 0, ...
</code></pre><p>We can get that pattern with</p>
<pre class="prettyprint"><code class="lang-glsl">float radius = step(1.5, triVertexId);
</code></pre>
<p><code>step(a, b)</code> is 0 if a &lt; b and 1 otherwise. You can think of it as</p>
<pre class="prettyprint"><code class="lang-js">function step(a, b) {
  return a &lt; b ? 0 : 1;
}
</code></pre>
<p><code>step(1.5, triVertexId)</code> will be 1 when 1.5 is less than <code>triVertexId</code>.
That&#39;s true for the first 2 vertices of each triangle and false
for the last one.</p>
<p>We can get triangle vertices for a circle like this</p>
<pre class="prettyprint"><code class="lang-glsl">float numSlices = 8.0;
float sliceId = floor(vertexId / 3.0);
float triVertexId = mod(vertexId, 3.0);
float edge = triVertexId + sliceId;
float angleU = edge / numSlices;  // 0.0 to 1.0
float angle = angleU * PI * 2.0;
float radius = step(triVertexId, 1.5);
vec2 pos = vec2(cos(angle), sin(angle)) * radius;
</code></pre>
<p>Putting all of this together let&#39;s just try to draw 1 circle.</p>
<pre class="prettyprint"><code class="lang-glsl">attribute float vertexId;
uniform float numVerts;
uniform vec2 resolution;

#define PI radians(180.0)

void main() {
  float numSlices = 8.0;
  float sliceId = floor(vertexId / 3.0);
  float triVertexId = mod(vertexId, 3.0);
  float edge = triVertexId + sliceId;
  float angleU = edge / numSlices;  // 0.0 to 1.0
  float angle = angleU * PI * 2.0;
  float radius = step(triVertexId, 1.5);
  vec2 pos = vec2(cos(angle), sin(angle)) * radius;

  float aspect = resolution.y / resolution.x;
  vec2 scale = vec2(aspect, 1);

  gl_Position = vec4(pos * scale, 0, 1);
}
</code></pre>
<p>Notice we put <code>resolution</code> back in so we don&#39;t get an ellipse.</p>
<p>For a 8 slice circle we need 8 * 3 vertices</p>
<pre class="prettyprint"><code class="lang-js">-const numVerts = 400;
+const numVerts = 8 * 3;
</code></pre>
<p>and we need to draw <code>TRIANGLES</code> not <code>POINTS</code></p>
<pre class="prettyprint"><code class="lang-js">const offset = 0;
-gl.drawArrays(gl.POINTS, offset, numVerts);
+gl.drawArrays(gl.TRIANGLES, offset, numVerts);
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-no-data-triangles-circle.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-no-data-triangles-circle.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>And if what if we wanted to draw multiple circles?</p>
<p>All we need to do is come up with a <code>circleId</code> which we
can use to pick some position for each circle that is
the same for all vertices in the circle.</p>
<pre class="prettyprint"><code class="lang-glsl">float numVertsPerCircle = numSlices * 3.0;
float circleId = floor(vertexId / numVertsPerCircle);
</code></pre>
<p>For example let&#39;s draw a circle of circles.</p>
<p>First let&#39;s turn the code above into a function,</p>
<pre class="prettyprint"><code class="lang-glsl">vec2 computeCircleTriangleVertex(float vertexId) {
  float numSlices = 8.0;
  float sliceId = floor(vertexId / 3.0);
  float triVertexId = mod(vertexId, 3.0);
  float edge = triVertexId + sliceId;
  float angleU = edge / numSlices;  // 0.0 to 1.0
  float angle = angleU * PI * 2.0;
  float radius = step(triVertexId, 1.5);
  return vec2(cos(angle), sin(angle)) * radius;
}
</code></pre>
<p>Now here&#39;s the original code we used to draw
a circle of points at the top of this article.</p>
<pre class="prettyprint"><code class="lang-glsl">float u = vertexId / numVerts;      // goes from 0 to 1
float angle = u * PI * 2.0;         // goes from 0 to 2PI
float radius = 0.8;

vec2 pos = vec2(cos(angle), sin(angle)) * radius;

float aspect = resolution.y / resolution.x;
vec2 scale = vec2(aspect, 1);

gl_Position = vec4(pos * scale, 0, 1);
</code></pre>
<p>We just need to change it to use <code>circleId</code> instead
of <code>vertexId</code> and to divide by the number of circles
instead of the number of vertices.</p>
<pre class="prettyprint"><code class="lang-glsl">void main() {
+  float circleId = floor(vertexId / numVertsPerCircle);
+  float numCircles = numVerts / numVertsPerCircle;

-  float u = vertexId / numVerts;      // goes from 0 to 1
+  float u = circleId / numCircles;    // goes from 0 to 1
  float angle = u * PI * 2.0;         // goes from 0 to 2PI
  float radius = 0.8;

  vec2 pos = vec2(cos(angle), sin(angle)) * radius;

+  vec2 triPos = computeCircleTriangleVertex(vertexId) * 0.1;

  float aspect = resolution.y / resolution.x;
  vec2 scale = vec2(aspect, 1);

-  gl_Position = vec4(pos * scale, 0, 1);
+  gl_Position = vec4((pos + triPos) * scale, 0, 1);
}
</code></pre>
<p>Then we just need to increase the number of vertices</p>
<pre class="prettyprint"><code class="lang-js">-const numVerts = 8 * 3;
+const numVerts = 8 * 3 * 20;
</code></pre>
<p>And now we have a circle of 20 circles.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-no-data-triangles-circles.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-no-data-triangles-circles.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>And of course we could apply the the same things we did
above to make a rain of circles. That probably has no
point so I&#39;m not going to go through it but it does show
making triangles in the vertex shader with no data.</p>
<p>The above technique could be used for making rectangles
or squares instead, then generating UV coordinates,
passing those the the fragment shader and texture mapping
our generated geometry. This might be good for 
falling snowflakes or leaves that actually flip around in 3D
by applying the 3D techniques we used in the articles
on <a href="webgl-3d-perspective">3D perspective</a>.</p>
<p>I want to emphasize <strong>these techniques</strong> are not common.
Making a simple particle system might be semi common or
the rain effect above but making extremely complex calculations
will hurt performance. In general you if you want performance
you should ask your computer to do as little work as possible
so if there is a bunch of stuff you can pre-calculate at init
time and pass it into the shader in some form or another you
should do that.</p>
<p>For example here&#39;s an extreme vertex shader
that calculates a bunch of cubes (warning, has sound).</p>
<iframe width="700" height="400" src="https://www.vertexshaderart.com/art/zd2E5vCZduc5JeoFz" frameborder="0" allowfullscreen></iframe>

<p>As an intellectual curiosity of the puzzle &quot;If I had no data
except a vertex id could I draw something interesting?&quot; it&#39;s
kind of neat. In fact <a href="https://www.vertexshaderart.com">that entire website</a> is about
the puzzle of if you only have a vertex id can you make something
interesting. But, for performance it would be much much faster to use
the more traditional techniques of passing in cube vertex data
in buffers and reading that data with attributes or other techniques
we&#39;ll go in other articles.</p>
<p>There is some balance to be struck. For the rain example above if you want that exact
effect then the code above is pretty efficient. Somewhere between
the two lies the boundary where one technique is more performant
than another. Usually the more traditional techniques are far more flexible
as well but you have to decide on a case by case basis when to use one
way or another.</p>
<p>The point of this article is mostly to introduce these ideas 
and to emphasize other ways of thinking about what WebGL
is actually doing. Again it only cares that you set <code>gl_Position</code>
and <code>gl_FragColor</code> in your shaders. It doesn&#39;t care how you do it.</p>
<div class="webgl_bottombar" id="pointsissues">
<h3>A problem with <code>gl.POINTS</code></h3>
<p>
One thing a technique like this can be useful for is to simulate drawing
with <code>gl.POINTS</code>.
</p>

There are 2 problems with <code>gl.POINTS</code>

<ol>
<li>They have a maximum size<br/><br/>Most people using <code>gl.POINTS</code> use small sizes
but if that maximum size is smaller than you need you'll need to choose a different solution.
</li>
<li>How they get clipped when off the screen is inconsistent<br/><br/>
The issue here is imagine you set the center of a point to be 1 pixel off the left edge
of the canvas but you set <code>gl_PointSize</code> to 32.0.
<div class="webgl_center"><img src="resources/point-outside-canvas.svg" style="width: 400px"></div>
According to the OpenGL ES 1.0
spec what is supposed to happen is that because 15 columns of those 32x32 pixels are still on the canvas
they are supposed to be drawn. Unfortunately OpenGL (not ES) says the exact opposite.
If the center of the point is off the canvas nothing is drawn. Even worse, OpenGL until
recently has been notoriously under tested and so some drivers do draw those pixels
and some don't üò≠
</li>
</ol>
<p>
So, if either of those issues is a problem for your needs then as a solution you need to draw your own quads
with <code>gl.TRIANGLES</code> instead of using <code>gl.POINTS</code>.
 If you do that both problems are solved.
The maximum size problem goes away as does the inconsistent clipping problem. There are various
ways to draw lots of quads. One of then is using techniques like the ones in this article.</p>
</div>
    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-drawing-without-data.html" selected>English</a>
    <option value="/webgl/lessons/fr/webgl-drawing-without-data.html" >Fran√ßais</a>
    <option value="/webgl/lessons/ja/webgl-drawing-without-data.html" >Êó•Êú¨Ë™û</a>
    <option value="/webgl/lessons/ko/webgl-drawing-without-data.html" >ÌïúÍµ≠Ïñ¥</a>
    <option value="/webgl/lessons/pl/webgl-drawing-without-data.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-drawing-without-data.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-drawing-without-data.html" >–†—É—Å—Å–∫–∏–π</a>
    <option value="/webgl/lessons/zh_cn/webgl-drawing-without-data.html" >ÁÆÄ‰Ωì‰∏≠Êñá</a>
</select>


        <div id="toc">
          <ul>  <li>Fundamentals</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgl/lessons/webgl-how-it-works.html">How It Works</a></li>
<li><a href="/webgl/lessons/webgl-shaders-and-glsl.html">Shaders and GLSL</a></li>
        </ul>
  <li>Image Processing</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-image-processing.html">Image Processing</a></li>
<li><a href="/webgl/lessons/webgl-image-processing-continued.html">Image Processing Continued</a></li>
        </ul>
  <li>2D translation, rotation, scale, matrix math</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-translation.html">2D Translation</a></li>
<li><a href="/webgl/lessons/webgl-2d-rotation.html">2D Rotation</a></li>
<li><a href="/webgl/lessons/webgl-2d-scale.html">2D Scale</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrices.html">2D Matrices</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-orthographic.html">Orthographic 3D</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective.html">3D Perspective</a></li>
<li><a href="/webgl/lessons/webgl-3d-camera.html">3D Cameras</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Structure and Organization</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/webgl-drawing-multiple-things.html">Drawing Multiple Things</a></li>
<li><a href="/webgl/lessons/webgl-scene-graph.html">Scene Graphs</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-geometry-lathe.html">Geometry - Lathe</a></li>
        </ul>
  <li>Textures</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-textures.html">Textures</a></li>
<li><a href="/webgl/lessons/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/webgl-2-textures.html">Using 2 or More Textures</a></li>
<li><a href="/webgl/lessons/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective-correct-texturemapping.html">Perspective Correct Texture Mapping</a></li>
<li><a href="/webgl/lessons/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>Rendering To A Texture</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-render-to-texture.html">Render to Texture</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrix-stack.html">2D - Matrix Stack</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/webgl-fog.html">Fog</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-text-html.html">Text - HTML</a></li>
<li><a href="/webgl/lessons/webgl-text-canvas2d.html">Text - Canvas 2D</a></li>
<li><a href="/webgl/lessons/webgl-text-texture.html">Text - Using a Texture</a></li>
<li><a href="/webgl/lessons/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
  <li>Textures</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-ramp-textures.html">Ramp Textures (Toon Shading)</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-setup-and-installation.html">Setup And Installation</a></li>
<li><a href="/webgl/lessons/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/webgl-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgl/lessons/webgl-animation.html">Animation</a></li>
<li><a href="/webgl/lessons/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/webgl-instanced-drawing.html">Instanced Drawing</a></li>
<li><a href="/webgl/lessons/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/webgl-and-alpha.html">WebGL and Alpha</a></li>
<li><a href="/webgl/lessons/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#html-background">Use WebGL as Background in HTML</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/webgl-texture-units.html">Texture Units</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="http://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
    <div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgl">Ask on stackoverflow</a>.</div>
    <div>Issue/Bug? <a href="http://github.com/gfxfundamentals/webgl-fundamentals/issues">Create an issue on github</a>.</div>
    <div class="lesson-comment-notes">
       Use <b>&lt;pre&gt;&lt;code&gt;</b>code goes here<b>&lt;/code&gt;&lt;/pre&gt;</b> for code blocks
    </div>
  

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL Drawing Without Data';
            var disqus_title = 'WebGL Drawing Without Data';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script src="//cdn.webglstats.com/stat.js" defer="defer" async="async"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');

</script>


</html>



