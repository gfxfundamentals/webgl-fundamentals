<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/webgl-picking.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="How to pick things in WebGL" />
<meta name="keywords" content="webgl graphics" />
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-picking_en.jpg" />

<meta property="og:title" content="WebGL Picking" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-picking_en.jpg" />
<meta property="og:description" content="How to pick things in WebGL" />
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/webgl-picking.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webglfundamentals.org" />
<meta name="twitter:title" content="WebGL Picking" />
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/webgl-picking.html" />
<meta name="twitter:description" content="How to pick things in WebGL" />
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-picking_en.jpg" />

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/webgl-picking.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-picking_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/webgl-picking.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/webgl-picking.html",
      "inLanguage":"en",
      "name":"WebGL Picking",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/webgl-picking.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL Picking</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />



</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-picking.html" selected>English</a>
    <option value="/webgl/lessons/fr/webgl-picking.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-picking.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-picking.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-picking.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-picking.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-picking.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-picking.html" >简体中文</a>
</select>


    <a href="#toc">Table of Contents</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub a {
    background: #000;
    color: #fff;
    text-decoration: none;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 2rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 300px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(150px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a:hover {
    background: #c11;
    color: #fff;
}
#forkongithub a::before,#forkongithub a::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub a::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
@media (max-width: 900px) {
    #forkongithub a{
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub a{
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL Picking</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>This article is about how to use WebGL to let the user pick or select
things.</p>
<p>If you&#39;ve read the other articles on this site you have hopefully realized
that WebGL itself is just a rasterization library. It draws triangles,
lines, and points into the canvas so it has no concept of &quot;objects to be
selected&quot;. It just outputs pixels via shaders you supply. That means
any concept of &quot;picking&quot; something has to come from your code. You need
to define what these things you&#39;re letting the user select are.
That means while this article can cover general concepts you&#39;ll need to
decide for yourself how to translate what you see here into usable
concepts in your own application.</p>
<h2 id="clicking-on-an-object">Clicking on an Object</h2>
<p>One of the easiest ways figure out which thing a user clicked on is
we come up with a numeric id for each object, we can then draw 
all of the objects using their id as their color with no lighting
and no textures. This will give us an image of the silhouettes of
each object. The depth buffer will handle sorting for us.
We can then read the color of the pixel under the
mouse which will give us the id of the object that was rendered there.</p>
<p>To implement this technique we&#39;ll need to combine several previous
articles. The first is the article on <a href="webgl-drawing-multiple-things.html">drawing multiple objects</a>
which we&#39;ll use because given it draws multiple things we can try to
pick them.</p>
<p>On top of that we generally want to render these ids off screen
by <a href="webgl-render-to-texture.html">rendering to a texture</a> so we&#39;ll
add in that code as well.</p>
<p>So, let&#39;s start with the last example from
<a href="webgl-drawing-multiple-things.html">the article on drawing multiple things</a>
that draws 200 things.</p>
<p>To it let&#39;s add a framebuffer with attached texture and depth buffer from
the last example in <a href="webgl-render-to-texture.html">the article on rendering to a texture</a>.</p>
<pre class="prettyprint"><code class="lang-js">// Create a texture to render to
const targetTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, targetTexture);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

// create a depth renderbuffer
const depthBuffer = gl.createRenderbuffer();
gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);

function setFramebufferAttachmentSizes(width, height) {
  gl.bindTexture(gl.TEXTURE_2D, targetTexture);
  // define size and format of level 0
  const level = 0;
  const internalFormat = gl.RGBA;
  const border = 0;
  const format = gl.RGBA;
  const type = gl.UNSIGNED_BYTE;
  const data = null;
  gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                width, height, border,
                format, type, data);

  gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
}

// Create and bind the framebuffer
const fb = gl.createFramebuffer();
gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

// attach the texture as the first color attachment
const attachmentPoint = gl.COLOR_ATTACHMENT0;
const level = 0;
gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, targetTexture, level);

// make a depth buffer and the same size as the targetTexture
gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);
</code></pre>
<p>We put the code to set the sizes of the texture and
the depth renderbuffer into a function so we can
call it to resize them to match the size of the
canvas.</p>
<p>In our rendering code if the canvas changes size
we&#39;ll adjust the texture and renderbuffer to match.</p>
<pre class="prettyprint"><code class="lang-js">function drawScene(time) {
  time *= 0.0005;

-  webglUtils.resizeCanvasToDisplaySize(gl.canvas);
+  if (webglUtils.resizeCanvasToDisplaySize(gl.canvas)) {
+    // the canvas was resized, make the framebuffer attachments match
+    setFramebufferAttachmentSizes(gl.canvas.width, gl.canvas.height);
+  }

...
</code></pre>
<p>Next we need a second shader. The shader in the
sample renders using vertex colors but we need
one we can set to a solid color to render with ids.
So first here is our second shader</p>
<pre class="prettyprint"><code class="lang-html">&lt;!-- vertex shader --&gt;
&lt;script id=&quot;pick-vertex-shader&quot; type=&quot;x-shader/x-vertex&quot;&gt;
  attribute vec4 a_position;

  uniform mat4 u_matrix;

  void main() {
    // Multiply the position by the matrix.
    gl_Position = u_matrix * a_position;
  }
&lt;/script&gt;
&lt;!-- fragment shader --&gt;
&lt;script id=&quot;pick-fragment-shader&quot; type=&quot;x-shader/x-fragment&quot;&gt;
  precision mediump float;

  uniform vec4 u_id;

  void main() {
     gl_FragColor = u_id;
  }
&lt;/script&gt;
</code></pre>
<p>And we need to compile, link and look up the locations
using our <a href="webgl-less-code-more-fun.html">helpers</a>.</p>
<pre class="prettyprint"><code class="lang-js">// setup GLSL programs
const programInfo = webglUtils.createProgramInfo(
    gl, [&quot;3d-vertex-shader&quot;, &quot;3d-fragment-shader&quot;]);
+const pickingProgramInfo = webglUtils.createProgramInfo(
+    gl, [&quot;pick-vertex-shader&quot;, &quot;pick-fragment-shader&quot;]);
</code></pre>
<p>We need to be able to render all the objects
twice. Once with whatever shader we assigned to
them and again with the shader we just wrote
so let&#39;s extract the code that currently renders
all the objects into a function.</p>
<pre class="prettyprint"><code class="lang-js">function drawObjects(objectsToDraw, overrideProgramInfo) {
  objectsToDraw.forEach(function(object) {
    const programInfo = overrideProgramInfo || object.programInfo;
    const bufferInfo = object.bufferInfo;

    gl.useProgram(programInfo.program);

    // Setup all the needed attributes.
    webglUtils.setBuffersAndAttributes(gl, programInfo, bufferInfo);

    // Set the uniforms.
    webglUtils.setUniforms(programInfo, object.uniforms);

    // Draw
    gl.drawArrays(gl.TRIANGLES, 0, bufferInfo.numElements);
  });
}
</code></pre>
<p><code>drawObjects</code> takes an optional <code>overrideProgramInfo</code>
we can pass in to use our picking shader instead of
the object&#39;s assigned shader.</p>
<p>Let&#39;s call it, once to draw into the texture with
ids and again to draw the scene to the canvas.</p>
<pre class="prettyprint"><code class="lang-js">// Draw the scene.
function drawScene(time) {
  time *= 0.0005;

  ...

  // Compute the matrices for each object.
  objects.forEach(function(object) {
    object.uniforms.u_matrix = computeMatrix(
        viewProjectionMatrix,
        object.translation,
        object.xRotationSpeed * time,
        object.yRotationSpeed * time);
  });

+  // ------ Draw the objects to the texture --------
+
+  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
+  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
+
+  gl.enable(gl.CULL_FACE);
+  gl.enable(gl.DEPTH_TEST);
+
+  // Clear the canvas AND the depth buffer.
+  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
+
+  drawObjects(objectsToDraw, pickingProgramInfo);
+
+  // ------ Draw the objects to the canvas
+
+  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
+  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
+
+  drawObjects(objectsToDraw);

  requestAnimationFrame(drawScene);
}
</code></pre>
<p>Our picking shader needs <code>u_id</code> set to an id so let&#39;s
add that to our uniform data where we setup our objects.</p>
<pre class="prettyprint"><code class="lang-js">// Make infos for each object for each object.
const baseHue = rand(0, 360);
const numObjects = 200;
for (let ii = 0; ii &lt; numObjects; ++ii) {
+  const id = ii + 1;
  const object = {
    uniforms: {
      u_colorMult: chroma.hsv(eMod(baseHue + rand(0, 120), 360), rand(0.5, 1), rand(0.5, 1)).gl(),
      u_matrix: m4.identity(),
+      u_id: [
+        ((id &gt;&gt;  0) &amp; 0xFF) / 0xFF,
+        ((id &gt;&gt;  8) &amp; 0xFF) / 0xFF,
+        ((id &gt;&gt; 16) &amp; 0xFF) / 0xFF,
+        ((id &gt;&gt; 24) &amp; 0xFF) / 0xFF,
+      ],
    },
    translation: [rand(-100, 100), rand(-100, 100), rand(-150, -50)],
    xRotationSpeed: rand(0.8, 1.2),
    yRotationSpeed: rand(0.8, 1.2),
  };
  objects.push(object);
  objectsToDraw.push({
    programInfo: programInfo,
    bufferInfo: shapes[ii % shapes.length],
    uniforms: object.uniforms,
  });
}
</code></pre>
<p>This will work because our <a href="webgl-less-code-more-fun.html">helper library</a>
handles applying uniforms for us.</p>
<p>We had to split ids across R, G, B, and A. Because our
texture&#39;s format/type is <code>gl.RGBA</code>, <code>gl.UNSIGNED_BYTE</code>
we get 8 bits per channel. 8 bits only represent 256 values
but by splitting the id across 4 channels we get 32bits total
which is &gt; 4 billion values.</p>
<p>We add 1 to the id because we&#39;ll use 0 for meaning
&quot;nothing under the mouse&quot;.</p>
<p>Now let&#39;s highlight the object under the mouse.</p>
<p>First we need some code to get a canvas relative
mouse position.</p>
<pre class="prettyprint"><code class="lang-js">// mouseX and mouseY are in CSS display space relative to canvas
let mouseX = -1;
let mouseY = -1;

...

gl.canvas.addEventListener(&#39;mousemove&#39;, (e) =&gt; {
   const rect = canvas.getBoundingClientRect();
   mouseX = e.clientX - rect.left;
   mouseY = e.clientY - rect.top;
});
</code></pre>
<p>Note that with the code above <code>mouseX</code> and <code>mouseY</code>
are in CSS pixels in display space. That means
they are in the space the canvas is displayed,
not the space of how many pixels are in the canvas.
In other words if you had a canvas like this</p>
<pre class="prettyprint"><code class="lang-html">&lt;canvas width=&quot;11&quot; height=&quot;22&quot; style=&quot;width:33px; height:44px;&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p>then <code>mouseX</code> will go from 0 to 33 across the canvas and
<code>mouseY</code> will go from 0 to 44 across the canvas. See <a href="webgl-resizing-the-canvas.html">this</a>
for more info.</p>
<p>Now that we have a mouse position let&#39;s add some code
look up the pixel under the mouse</p>
<pre class="prettyprint"><code class="lang-js">const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;
const data = new Uint8Array(4);
gl.readPixels(
    pixelX,            // x
    pixelY,            // y
    1,                 // width
    1,                 // height
    gl.RGBA,           // format
    gl.UNSIGNED_BYTE,  // type
    data);             // typed array to hold result
const id = data[0] + (data[1] &lt;&lt; 8) + (data[2] &lt;&lt; 16) + (data[3] &lt;&lt; 24);
</code></pre>
<p>The code above that is computing <code>pixelX</code> and <code>pixelY</code> is converting
from <code>mouseX</code> and <code>mouseY</code> in display space to pixel in the the canvas
space. In other words, given the example above where <code>mouseX</code> went from
0 to 33 and <code>mouseY</code> went from 0 to 44. <code>pixelX</code> will go from 0 to 11
and <code>pixelY</code> will go from 0 to 22.</p>
<p>In our actual code we&#39;re using our utility function <code>resizeCanvasToDisplaySize</code>
and we&#39;re making our texture the same size as the canvas so the display
size and the canvas size match but at least we&#39;re prepared for the case
where they do not match.</p>
<p>Now that we have an id, to actually highlight the selected object
let&#39;s change the color we&#39;re using to render it to the canvas.
The shader we were using has a <code>u_colorMult</code>
uniform we can use so if an object is under the mouse we&#39;ll look it up,
save off its <code>u_colorMult</code> value, replace it with a selection color,
and restore it.</p>
<pre class="prettyprint"><code class="lang-js">// mouseX and mouseY are in CSS display space relative to canvas
let mouseX = -1;
let mouseY = -1;
+let oldPickNdx = -1;
+let oldPickColor;
+let frameCount = 0;

// Draw the scene.
function drawScene(time) {
  time *= 0.0005;
+  ++frameCount;

  // ------ Draw the objects to the texture --------

  ...

  // ------ Figure out what pixel is under the mouse and read it

  const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
  const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;
  const data = new Uint8Array(4);
  gl.readPixels(
      pixelX,            // x
      pixelY,            // y
      1,                 // width
      1,                 // height
      gl.RGBA,           // format
      gl.UNSIGNED_BYTE,  // type
      data);             // typed array to hold result
  const id = data[0] + (data[1] &lt;&lt; 8) + (data[2] &lt;&lt; 16) + (data[3] &lt;&lt; 24);

  // restore the object&#39;s color
  if (oldPickNdx &gt;= 0) {
    const object = objects[oldPickNdx];
    object.uniforms.u_colorMult = oldPickColor;
    oldPickNdx = -1;
  }

  // highlight object under mouse
  if (id &gt; 0) {
    const pickNdx = id - 1;
    oldPickNdx = pickNdx;
    const object = objects[pickNdx];
    oldPickColor = object.uniforms.u_colorMult;
    object.uniforms.u_colorMult = (frameCount &amp; 0x8) ? [1, 0, 0, 1] : [1, 1, 0, 1];
  }

  // ------ Draw the objects to the canvas
</code></pre>
<p>And with that we should be able to move the mouse over
the scene and the object under the mouse will flash</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-picking-w-gpu.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-picking-w-gpu.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>One optimization we can make, we&#39;re rendering
the ids to a texture that&#39;s the same size
as the canvas. This is conceptually the easiest
thing to do.</p>
<p>But, we could instead just render the pixel
under the mouse. To do this we use a frustum
who&#39;s math will cover just the space for that
1 pixel.</p>
<p>Until now, for 3D we&#39;ve been using a function called
<code>perspective</code> that takes as input a field of view, an aspect, and a
near and far value for the z-planes and makes a
perspective projection matrix that converts from the
frustum defined by those values to clip space.</p>
<p>Most 3D math libraries have another function called
<code>frustum</code> that takes 6 values, the left, right, top,
and bottom values for the near z-plane and then the
z-near and z-far values for the z-planes and generates
a perspective matrix defined by those values.</p>
<p>Using that we can generate a perspective matrix for
the one pixel under the mouse</p>
<p>First we compute the edges and size of what our near plane <em>would be</em>
if we were to use the <code>perspective</code> function</p>
<pre class="prettyprint"><code class="lang-js">// compute the rectangle the near plane of our frustum covers
const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
const top = Math.tan(fieldOfViewRadians * 0.5) * near;
const bottom = -top;
const left = aspect * bottom;
const right = aspect * top;
const width = Math.abs(right - left);
const height = Math.abs(top - bottom);
</code></pre>
<p>So <code>left</code>, <code>right</code>, <code>width</code>, and <code>height</code> are the
size and position of the near plane. Now on that
plane we can compute the size and position of the
one pixel under the mouse and pass that to the
<code>frustum</code> function to generate a projection matrix
that covers just that 1 pixel</p>
<pre class="prettyprint"><code class="lang-js">// compute the portion of the near plane covers the 1 pixel
// under the mouse.
const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;

const subLeft = left + pixelX * width / gl.canvas.width;
const subBottom = bottom + pixelY * height / gl.canvas.height;
const subWidth = 1 / gl.canvas.width;
const subHeight = 1 / gl.canvas.height;

// make a frustum for that 1 pixel
const projectionMatrix = m4.frustum(
    subLeft,
    subLeft + subWidth,
    subBottom,
    subBottom + subHeight,
    near,
    far);
</code></pre>
<p>To use this we need to make some changes. As it now our shader
just takes <code>u_matrix</code> which means in order to draw with a different
projection matrix we&#39;d need to recompute the matrices for every object
twice each frame, once with our normal projection matrix for drawing
to the canvas and again for this 1 pixel projection matrix.</p>
<p>We can remove that responsibility from JavaScript by moving that
multiplication to the vertex shaders.</p>
<pre class="prettyprint"><code class="lang-html">&lt;!-- vertex shader --&gt;
&lt;script id=&quot;3d-vertex-shader&quot; type=&quot;x-shader/x-vertex&quot;&gt;
attribute vec4 a_position;
attribute vec4 a_color;

-uniform mat4 u_matrix;
+uniform mat4 u_viewProjection;
+uniform mat4 u_world;

varying vec4 v_color;

void main() {
-  // Multiply the position by the matrix.
-  gl_Position = u_matrix * a_position;
+  // Multiply the position by the matrices
+  gl_Position = u_viewProjection * u_world * a_position;

  // Pass the color to the fragment shader.
  v_color = a_color;
}
&lt;/script&gt;

...

&lt;!-- vertex shader --&gt;
&lt;script id=&quot;pick-vertex-shader&quot; type=&quot;x-shader/x-vertex&quot;&gt;
attribute vec4 a_position;

-uniform mat4 u_matrix;
+uniform mat4 u_viewProjection;
+uniform mat4 u_world;

void main() {
-  // Multiply the position by the matrix.
-  gl_Position = u_matrix * a_position;
+  // Multiply the position by the matrices
+  gl_Position = u_viewProjection * u_world * a_position;
}
&lt;/script&gt;
</code></pre>
<p>Then we can make our JavaScript <code>viewProjectionMatrix</code> shared
among all the objects.</p>
<pre class="prettyprint"><code class="lang-js">const objectsToDraw = [];
const objects = [];
+const viewProjectionMatrix = m4.identity();

// Make infos for each object for each object.
const baseHue = rand(0, 360);
const numObjects = 200;
for (let ii = 0; ii &lt; numObjects; ++ii) {
  const id = ii + 1;
  const object = {
    uniforms: {
      u_colorMult: chroma.hsv(eMod(baseHue + rand(0, 120), 360), rand(0.5, 1), rand(0.5, 1)).gl(),
-      u_matrix: m4.identity(),
+      u_world: m4.identity(),
+      u_viewProjection: viewProjectionMatrix,
      u_id: [
        ((id &gt;&gt;  0) &amp; 0xFF) / 0xFF,
        ((id &gt;&gt;  8) &amp; 0xFF) / 0xFF,
        ((id &gt;&gt; 16) &amp; 0xFF) / 0xFF,
        ((id &gt;&gt; 24) &amp; 0xFF) / 0xFF,
      ],
    },
    translation: [rand(-100, 100), rand(-100, 100), rand(-150, -50)],
    xRotationSpeed: rand(0.8, 1.2),
    yRotationSpeed: rand(0.8, 1.2),
  };
</code></pre>
<p>And where we compute the matrices for each object we no longer need
to include the view projection matrix</p>
<pre class="prettyprint"><code class="lang-js">-function computeMatrix(viewProjectionMatrix, translation, xRotation, yRotation) {
-  let matrix = m4.translate(viewProjectionMatrix,
+function computeMatrix(translation, xRotation, yRotation) {
+  let matrix = m4.translation(
      translation[0],
      translation[1],
      translation[2]);
  matrix = m4.xRotate(matrix, xRotation);
  return m4.yRotate(matrix, yRotation);
}
...

// Compute the matrices for each object.
objects.forEach(function(object) {
  object.uniforms.u_world = computeMatrix(
-      viewProjectionMatrix,
      object.translation,
      object.xRotationSpeed * time,
      object.yRotationSpeed * time);
});
</code></pre>
<p>We&#39;ll create just a 1x1 pixel texture and depth buffer</p>
<pre class="prettyprint"><code class="lang-js">setFramebufferAttachmentSizes(1, 1);

...

// Draw the scene.
function drawScene(time) {
  time *= 0.0005;
  ++frameCount;

-  if (webglUtils.resizeCanvasToDisplaySize(gl.canvas)) {
-    // the canvas was resized, make the framebuffer attachments match
-    setFramebufferAttachmentSizes(gl.canvas.width, gl.canvas.height);
-  }
+  webglUtils.resizeCanvasToDisplaySize(gl.canvas);
</code></pre>
<p>Then before rendering the off screen ids we&#39;ll set the view projection
using our 1 pixel projection matrix and then when drawing to the canvas
we&#39;ll use the original projection matrix</p>
<pre class="prettyprint"><code class="lang-js">-// Compute the projection matrix
-const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
-const projectionMatrix =
-    m4.perspective(fieldOfViewRadians, aspect, 1, 2000);

// Compute the camera&#39;s matrix using look at.
const cameraPosition = [0, 0, 100];
const target = [0, 0, 0];
const up = [0, 1, 0];
const cameraMatrix = m4.lookAt(cameraPosition, target, up);

// Make a view matrix from the camera matrix.
const viewMatrix = m4.inverse(cameraMatrix);

-const viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);

// Compute the matrices for each object.
objects.forEach(function(object) {
  object.uniforms.u_world = computeMatrix(
      object.translation,
      object.xRotationSpeed * time,
      object.yRotationSpeed * time);
});

// ------ Draw the objects to the texture --------

// Figure out what pixel is under the mouse and setup
// a frustum to render just that pixel

{
  // compute the rectangle the near plane of our frustum covers
  const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
  const top = Math.tan(fieldOfViewRadians * 0.5) * near;
  const bottom = -top;
  const left = aspect * bottom;
  const right = aspect * top;
  const width = Math.abs(right - left);
  const height = Math.abs(top - bottom);

  // compute the portion of the near plane covers the 1 pixel
  // under the mouse.
  const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
  const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;

  const subLeft = left + pixelX * width / gl.canvas.width;
  const subBottom = bottom + pixelY * height / gl.canvas.height;
  const subWidth = 1 / gl.canvas.width;
  const subHeight = 1 / gl.canvas.height;

  // make a frustum for that 1 pixel
  const projectionMatrix = m4.frustum(
      subLeft,
      subLeft + subWidth,
      subBottom,
      subBottom + subHeight,
      near,
      far);
+  m4.multiply(projectionMatrix, viewMatrix, viewProjectionMatrix);
}

gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
gl.viewport(0, 0, 1, 1);

gl.enable(gl.CULL_FACE);
gl.enable(gl.DEPTH_TEST);

// Clear the canvas AND the depth buffer.
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

drawObjects(objectsToDraw, pickingProgramInfo);

// read the 1 pixel
-const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
-const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;
const data = new Uint8Array(4);
gl.readPixels(
-    pixelX,            // x
-    pixelY,            // y
+    0,                 // x
+    0,                 // y
    1,                 // width
    1,                 // height
    gl.RGBA,           // format
    gl.UNSIGNED_BYTE,  // type
    data);             // typed array to hold result
const id = data[0] + (data[1] &lt;&lt; 8) + (data[2] &lt;&lt; 16) + (data[3] &lt;&lt; 24);

// restore the object&#39;s color
if (oldPickNdx &gt;= 0) {
  const object = objects[oldPickNdx];
  object.uniforms.u_colorMult = oldPickColor;
  oldPickNdx = -1;
}

// highlight object under mouse
if (id &gt; 0) {
  const pickNdx = id - 1;
  oldPickNdx = pickNdx;
  const object = objects[pickNdx];
  oldPickColor = object.uniforms.u_colorMult;
  object.uniforms.u_colorMult = (frameCount &amp; 0x8) ? [1, 0, 0, 1] : [1, 1, 0, 1];
}

// ------ Draw the objects to the canvas

+{
+  // Compute the projection matrix
+  const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
+  const projectionMatrix =
+      m4.perspective(fieldOfViewRadians, aspect, near, far);
+
+  m4.multiply(projectionMatrix, viewMatrix, viewProjectionMatrix);
+}

gl.bindFramebuffer(gl.FRAMEBUFFER, null);
gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

drawObjects(objectsToDraw);
</code></pre>
<p>And you can see the math works, we&#39;re only drawing a single pixel
and we&#39;re still figuring out what is under the mouse</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-picking-w-gpu-1pixel.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-picking-w-gpu-1pixel.html" target="_blank">click here to open in a separate window</a>
</div>

</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-picking.html" selected>English</a>
    <option value="/webgl/lessons/fr/webgl-picking.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-picking.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-picking.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-picking.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-picking.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-picking.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-picking.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Fundamentals</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgl/lessons/webgl-how-it-works.html">How It Works</a></li>
<li><a href="/webgl/lessons/webgl-shaders-and-glsl.html">Shaders and GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL State Diagram</a></li>
        </ul>
  <li>Image Processing</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-image-processing.html">Image Processing</a></li>
<li><a href="/webgl/lessons/webgl-image-processing-continued.html">Image Processing Continued</a></li>
        </ul>
  <li>2D translation, rotation, scale, matrix math</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-translation.html">2D Translation</a></li>
<li><a href="/webgl/lessons/webgl-2d-rotation.html">2D Rotation</a></li>
<li><a href="/webgl/lessons/webgl-2d-scale.html">2D Scale</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrices.html">2D Matrices</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-orthographic.html">Orthographic 3D</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective.html">3D Perspective</a></li>
<li><a href="/webgl/lessons/webgl-3d-camera.html">3D Cameras</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Structure and Organization</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/webgl-drawing-multiple-things.html">Drawing Multiple Things</a></li>
<li><a href="/webgl/lessons/webgl-scene-graph.html">Scene Graphs</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-geometry-lathe.html">Geometry - Lathe</a></li>
<li><a href="/webgl/lessons/webgl-load-obj.html">Loading .obj files</a></li>
<li><a href="/webgl/lessons/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>Textures</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-textures.html">Textures</a></li>
<li><a href="/webgl/lessons/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/webgl-2-textures.html">Using 2 or More Textures</a></li>
<li><a href="/webgl/lessons/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective-correct-texturemapping.html">Perspective Correct Texture Mapping</a></li>
<li><a href="/webgl/lessons/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>Rendering To A Texture</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-render-to-texture.html">Render to Texture</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrix-stack.html">2D - Matrix Stack</a></li>
<li><a href="/webgl/lessons/webgl-sprites.html">Sprites</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-text-html.html">Text - HTML</a></li>
<li><a href="/webgl/lessons/webgl-text-canvas2d.html">Text - Canvas 2D</a></li>
<li><a href="/webgl/lessons/webgl-text-texture.html">Text - Using a Texture</a></li>
<li><a href="/webgl/lessons/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
  <li>Textures</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-ramp-textures.html">Ramp Textures (Toon Shading)</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/webgl-instanced-drawing.html">Instanced Drawing</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-setup-and-installation.html">Setup And Installation</a></li>
<li><a href="/webgl/lessons/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/webgl-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgl/lessons/webgl-animation.html">Animation</a></li>
<li><a href="/webgl/lessons/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/webgl-and-alpha.html">WebGL and Alpha</a></li>
<li><a href="/webgl/lessons/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#html-background">Use WebGL as Background in HTML</a></li>
<li><a href="/webgl/lessons/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="https://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
    <div>Questions? <a href="https://stackoverflow.com/questions/tagged/webgl">Ask on stackoverflow</a>.</div>
    <div>Issue/Bug? <a href="https://github.com/gfxfundamentals/webgl-fundamentals/issues">Create an issue on github</a>.</div>
    <div class="lesson-comment-notes">
       Use <b>&lt;pre&gt;&lt;code&gt;</b>code goes here<b>&lt;/code&gt;&lt;/pre&gt;</b> for code blocks
    </div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL Picking';
            var disqus_title = 'WebGL Picking';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
      return;
  }

  function addScript(src, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  addScript('//cdn.webglstats.com/stat.js');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>



