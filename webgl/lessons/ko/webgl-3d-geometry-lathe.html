<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ko/webgl-3d-geometry-lathe.md. Do not edited directly -->
<!--
Copyright 2021 GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="베지에 곡선을 선반 처리하는 방법">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-3d-geometry-lathe_ko.jpg">

<meta property="og:title" content="WebGL 3D Geometry - Lathe">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-3d-geometry-lathe_ko.jpg">
<meta property="og:description" content="베지에 곡선을 선반 처리하는 방법">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/ko/webgl-3d-geometry-lathe.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGL 3D Geometry - Lathe">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/ko/webgl-3d-geometry-lathe.html">
<meta name="twitter:description" content="베지에 곡선을 선반 처리하는 방법">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-3d-geometry-lathe_ko.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-3d-geometry-lathe.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-3d-geometry-lathe_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-3d-geometry-lathe.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/ko/webgl-3d-geometry-lathe.html",
      "inLanguage":"ko",
      "name":"WebGL 3D Geometry - Lathe",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-3d-geometry-lathe.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL 3D Geometry - Lathe</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/ko/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-3d-geometry-lathe.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-3d-geometry-lathe.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-3d-geometry-lathe.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-3d-geometry-lathe.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-3d-geometry-lathe.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-3d-geometry-lathe.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-3d-geometry-lathe.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-3d-geometry-lathe.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-3d-geometry-lathe.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-3d-geometry-lathe.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-3d-geometry-lathe.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-3d-geometry-lathe.html" selected>한국어</a>
    <option value="/webgl/lessons/pl/webgl-3d-geometry-lathe.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-3d-geometry-lathe.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-3d-geometry-lathe.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-3d-geometry-lathe.html" >简体中文</a>
</select>


    <a href="#toc">목차</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ko/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL 3D Geometry - Lathe</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>애매한 종류의 주제일 수 있지만 저는 흥미롭게 봐서 이 글을 작성하고 있습니다.
실제로 하라고 추천하는 것은 아닙니다.
그보다는 이 주제를 이용해 작업하는 게 WebGL용 3D 모델을 만드는 방법을 설명하는 데 도움이 될 것이라 생각합니다.</p>
<p>어떤 사람이 WebGL에서 볼링핀 모양을 만드는 방법을 물어봤습니다.
<em>똑똑한</em> 대답은 &quot;<a href="https://blender.org">Blender</a>, <a href="https://www.autodesk.com/products/maya/overview">Maya</a>, <a href="https://www.autodesk.com/products/3ds-max/overview">3D Studio Max</a>, <a href="https://www.maxon.net/en/products/cinema-4d/overview/">Cinema 4D</a>처럼 3D 모델링 패키지를 사용하세요&quot; 입니다.
이를 사용하여 볼링핀을 모델링하고, 추출한 다음, 데이터를 읽습니다.
<a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file">OBJ 포맷</a>은 비교적 간단합니다.</p>
<p>하지만 모델링 패키지를 만들고 싶다면 어떻게 해야 할까요?</p>
<p>몇 가지 아이디어가 있습니다.
하나는 실린더를 만들고 특정 위치에 사인파를 사용하여 적당한 위치로 집어넣는 겁니다.
해당 아이디어의 문제는 매끄러운 상단을 얻을 수 없다는 것인데요.
표준 실린더는 동일한 크기의 연속된 링으로 생성되지만 굴곡이 많을수록 더 많은 링이 필요합니다.</p>
<p>모델링 패키지에서 2D 실루엣을 혹은 2D 실루엣의 가장자리와 일치하는 곡선을 만들어 볼링핀을 만들 겁니다.
그런 다음 3D 모양으로 선반 처리할 겁니다.
<em>선반</em>이란 어떤 축을 중심으로 회전하고 원하는 대로 돌출부를 생성한다는 의미입니다.
이렇게 하면 그릇, 유리잔, 야구 방망이, 병, 전구처럼 둥근 물체를 쉽게 만들 수 있습니다.</p>
<p>그래서 어떻게 해야 할까요?
먼저 곡선을 만드는 방법이 필요합니다.
그리고 해당 곡선의 점들을 계산해야 합니다.
그런 다음 <a href="webgl-2d-matrices.html">행렬 수학</a>을 사용하여 어떤 축을 중심으로 해당 점들을 회전시키고 이를 기준으로 삼각형을 만듭니다.</p>
<p>컴퓨터 그래픽에서 가장 흔한 곡선의 종류는 베지에 곡선인 것 같습니다.
<a href="https://www.adobe.com/products/illustrator.html">Adobe Illustrator</a>나 <a href="https://inkscape.org/en/">Inkscape</a>나 <a href="https://affinity.serif.com/en-us/designer/">Affinity Designer</a> 혹은 비슷한 프로그램에서 곡선을 편집해본 적이 있다면 그게 베지에 곡선입니다.</p>
<p>베지에 곡선이나 큐빅 베지에 곡선은 4개의 점으로 구성됩니다.
점 2개는 끝점이고 나머지 2개는 &quot;제어점&quot;입니다.</p>
<p>여기 4개의 점이 있습니다.</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 400px; height: 300px;" src="/webgl/lessons/resources/bezier-curve-diagram.html?maxDepth=0"></iframe>
</div>

</p>
<p>0이 시작이고 1이 끝일 때 0과 1사이의 숫자(이하 <code class="notranslate" translate="no">t</code>)를 선택합니다.
그런 다음 두 점(<code class="notranslate" translate="no">P1 P2</code>, <code class="notranslate" translate="no">P2 P3</code>, <code class="notranslate" translate="no">P3 P4</code>) 사이에 있는 점 <code class="notranslate" translate="no">t</code>를 계산합니다.</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 400px; height: 300px;" src="/webgl/lessons/resources/bezier-curve-diagram.html?maxDepth=1"></iframe>
</div>

</p>
<p>즉 <code class="notranslate" translate="no">t = .25</code>이면 <code class="notranslate" translate="no">P1</code>에서 <code class="notranslate" translate="no">P2</code>로 가는 경로의 25%, <code class="notranslate" translate="no">P2</code>에서 <code class="notranslate" translate="no">P3</code>로 가는 경로의 25%, <code class="notranslate" translate="no">P3</code>에서 <code class="notranslate" translate="no">P4</code>로 가는 경로의 25% 지점을 계산합니다.</p>
<p>슬라이더를 드래그하여 <code class="notranslate" translate="no">t</code>를 조정할 수 있고 점 <code class="notranslate" translate="no">P1</code>, <code class="notranslate" translate="no">P2</code>, <code class="notranslate" translate="no">P3</code>, <code class="notranslate" translate="no">P4</code>를 이동할 수도 있습니다.</p>
<p>결과 지점에 대해서도 동일한 작업을 수행합니다.
<code class="notranslate" translate="no">Q1 Q2</code>과 <code class="notranslate" translate="no">Q2 Q3</code> 사이에 있는 점 <code class="notranslate" translate="no">t</code>를 계산합니다.</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 400px; height: 300px;" src="/webgl/lessons/resources/bezier-curve-diagram.html?maxDepth=2"></iframe>
</div>

</p>
<p>마지막으로 2개의 점에 대해서도 동일한 작업을 수행하고 <code class="notranslate" translate="no">R1 R2</code> 사이의 점 <code class="notranslate" translate="no">t</code>를 계산합니다.</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 400px; height: 300px;" src="/webgl/lessons/resources/bezier-curve-diagram.html?maxDepth=3"></iframe>
</div>

</p>
<p><span style="color: red;">빨간 점</span>의 위치가 곡선을 만듭니다.</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 400px; height: 300px;" src="/webgl/lessons/resources/bezier-curve-diagram.html?maxDepth=4"></iframe>
</div>

</p>
<p>이게 큐빅 베지에 곡선입니다.</p>
<p>참고로 위 점들 사이의 보간과 4개를 3개로, 3개를 2개로, 마지막으로 2개를 1개의 점으로 만드는 과정은 정상적인 방법이 아닌데요.
이를 대신하기 위해 누군가가 모든 수식을 연결하여 이렇게 공식을 단순화했습니다.</p>
<div class="webgl_center">
<pre class="webgl_math">
invT = (1 - t)
P = P1 * invT^3 +
    P2 * 3 * t * invT^2 +
    P3 * 3 * invT * t^2 +
    P4 * t^3
</pre>
</div>

<p>여기서 <code class="notranslate" translate="no">P1</code>, <code class="notranslate" translate="no">P2</code>, <code class="notranslate" translate="no">P3</code>, <code class="notranslate" translate="no">P4</code>는 위 예제와 같은 점이고 <code class="notranslate" translate="no">P</code>는 <span style="color: red;">빨간 점</span>입니다.</p>
<p>어도비 일러스트레이터처럼 2D 벡터 미술 프로그램에서 긴 곡선을 만들면 실제로 이렇게 다수의 작은 점 4개로 만들어집니다.
기본적으로 대부분의 앱은 공유된 시작/끝점을 중심으로 제어점을 고정하고 공유된 지점을 기준으로 항상 반대 방향에 있도록 합니다.</p>
<p>이 예제를 보면 <code class="notranslate" translate="no">P3</code>나 <code class="notranslate" translate="no">P5</code>를 움직일 때 코드가 다른 쪽을 움직일 겁니다.</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 400px; height: 300px;" src="/webgl/lessons/resources/bezier-curve-edit.html"></iframe>
</div>

</p>
<p><code class="notranslate" translate="no">P1,P2,P3,P4</code>로 만들어진 곡선은 <code class="notranslate" translate="no">P4,P5,P6,P7</code>로 만들어진 곡선과는 별개의 곡선입니다.
<code class="notranslate" translate="no">P3</code>와 <code class="notranslate" translate="no">P5</code>가 <code class="notranslate" translate="no">P4</code>의 정확히 반대편에 함께 있을 때 연속된 하나의 곡선처럼 보입니다.
대부분의 앱은 함께 고정시키는 것을 중단하여 가파른 곡선을 얻을 수 있는 옵션을 제공합니다.
Lock 체크 박스를 해제한 다음 <code class="notranslate" translate="no">P3</code>나 <code class="notranslate" translate="no">P5</code>를 드래그해보면 별개의 곡선이라는 게 더욱 명확해집니다.</p>
<p>다음으로 곡선의 점들을 생성하는 방법이 필요한데요.
위 공식을 사용하여 다음과 같이 주어진 값 <code class="notranslate" translate="no">t</code>에 대한 점을 생성할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function getPointOnBezierCurve(points, offset, t) {
  const invT = (1 - t);
  return v2.add(v2.mult(points[offset + 0], invT * invT * invT),
                v2.mult(points[offset + 1], 3 * t * invT * invT),
                v2.mult(points[offset + 2], 3 * invT * t * t),
                v2.mult(points[offset + 3], t * t  *t));
}
</code></pre><p>그리고 이렇게 곡선에 대한 점 세트를 생성할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function getPointsOnBezierCurve(points, offset, numPoints) {
  const cpoints = [];
  for (let i = 0; i &lt; numPoints; ++i) {
    const t = i / (numPoints - 1);
    cpoints.push(getPointOnBezierCurve(points, offset, t));
  }
  return cpoints;
}
</code></pre><p>참고: <code class="notranslate" translate="no">v2.mult</code>와 <code class="notranslate" translate="no">v2.add</code>는 점으로 수식을 수행하는 데 유용하여 포함시킨 JavaScript 함수입니다.</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 400px; height: 300px;" src="/webgl/lessons/resources/bezier-curve-diagram.html?maxDepth=0&showCurve=true&showPoints=true"></iframe>
</div>

</p>
<p>위 다이어그램에서 점의 개수를 선택할 수 있습니다.
곡선이 뾰족하면 점이 더 많아지도록 하고 싶을 겁니다.
곡선이 거의 직선이라면 점을 줄이고 싶을 겁니다.
한 가지 해결책은 곡선이 얼마나 휘었는지 확인하는 것인데요.
너무 휘었다면 2개의 곡선으로 나누면 됩니다.</p>
<p>나누는 부분은 간단합니다.
보간의 다양한 레벨을 다시 봐보면, 값 <code class="notranslate" translate="no">t</code>에 대해 <code class="notranslate" translate="no">P1</code>, <code class="notranslate" translate="no">Q1</code>, <code class="notranslate" translate="no">R1</code>, 빨간점은 곡선 하나를 만들고, 빨간점, <code class="notranslate" translate="no">R2</code>, <code class="notranslate" translate="no">Q3</code>, <code class="notranslate" translate="no">P4</code>는 또 다른 곡선을 만듭니다.
즉 어디서든 곡선을 나눌 수 있고 원본과 일치하는 곡선 2개를 얻게 됩니다.</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 400px; height: 300px;" src="/webgl/lessons/resources/bezier-curve-diagram.html?maxDepth=4&show2Curves=true"></iframe>
</div>

</p>
<p>두 번째로 중요한 부분은 곡선을 분할해야 하는지 여부를 결정하는 겁니다.
인터넷을 둘러보다가 <a href="https://seant23.wordpress.com/2010/11/12/offset-bezier-curves/">주어진 곡선이 얼마나 평평한지 결정하는 함수</a>를 찾았습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function flatness(points, offset) {
  const p1 = points[offset + 0];
  const p2 = points[offset + 1];
  const p3 = points[offset + 2];
  const p4 = points[offset + 3];

  let ux = 3 * p2[0] - 2 * p1[0] - p4[0]; ux *= ux;
  let uy = 3 * p2[1] - 2 * p1[1] - p4[1]; uy *= uy;
  let vx = 3 * p3[0] - 2 * p4[0] - p1[0]; vx *= vx;
  let vy = 3 * p3[1] - 2 * p4[1] - p1[1]; vy *= vy;

  if(ux &lt; vx) {
    ux = vx;
  }

  if(uy &lt; vy) {
    uy = vy;
  }

  return ux + uy;
}
</code></pre><p>이를 곡선의 점을 만드는 함수에 사용할 수 있습니다.
먼저 곡선이 너무 가파른지 확인합니다.
그렇다면 세분화하고, 아니라면 점을 추가할 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints) {
  const outPoints = newPoints || [];
  if (flatness(points, offset) &lt; tolerance) {

    // 이 곡선의 끝점을 추가
    outPoints.push(points[offset + 0]);
    outPoints.push(points[offset + 3]);

  } else {

    // 세분화
    const t = .5;
    const p1 = points[offset + 0];
    const p2 = points[offset + 1];
    const p3 = points[offset + 2];
    const p4 = points[offset + 3];

    const q1 = v2.lerp(p1, p2, t);
    const q2 = v2.lerp(p2, p3, t);
    const q3 = v2.lerp(p3, p4, t);

    const r1 = v2.lerp(q1, q2, t);
    const r2 = v2.lerp(q2, q3, t);

    const red = v2.lerp(r1, r2, t);

    // 첫 번째 절반 수행
    getPointsOnBezierCurveWithSplitting([p1, q1, r1, red], 0, tolerance, outPoints);
    // 두 번째 절반 수행
    getPointsOnBezierCurveWithSplitting([red, r2, q3, p4], 0, tolerance, outPoints);

  }
  return outPoints;
}
</code></pre><p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 400px; height: 300px;" src="/webgl/lessons/resources/bezier-curve-diagram.html?maxDepth=0&showCurve=true&showTolerance=true"></iframe>
</div>

</p>
<p>이 알고리즘은 점이 충분한지 확인하는 데는 좋지만 불필요한 점을 제거하는 데는 그다지 좋지 않습니다.</p>
<p>이를 위해 인터넷에서 찾은 <a href="https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm">Ramer Douglas Peucker 알고리즘</a>을 살펴봅시다.</p>
<p>알고리즘은 먼저 점 목록을 가져옵니다.
그리고 두 끝점에 의해 형성된 선에서 가장 먼 점을 찾습니다.
그런 다음 해당 점이 선에서 일정 거리보다 더 멀리 있는지 확인합니다.
그 거리보다 더 가깝다면 두 끝점을 유지하고 나머지를 버립니다.
그렇지 않으면 알고리즘을 시작에서 가장 먼 지점 그리고 가장 먼 지점에서 끝점까지 다시 실행합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function simplifyPoints(points, start, end, epsilon, newPoints) {
  const outPoints = newPoints || [];

  // 끝점에서 가장 먼 거리의 점을 찾습니다.
  const s = points[start];
  const e = points[end - 1];
  let maxDistSq = 0;
  let maxNdx = 1;
  for (let i = start + 1; i &lt; end - 1; ++i) {
    const distSq = v2.distanceToSegmentSq(points[i], s, e);
    if (distSq &gt; maxDistSq) {
      maxDistSq = distSq;
      maxNdx = i;
    }
  }

  // 해당 지점이 너무 멀다면
  if (Math.sqrt(maxDistSq) &gt; epsilon) {

    // 분할
    simplifyPoints(points, start, maxNdx + 1, epsilon, outPoints);
    simplifyPoints(points, maxNdx, end, epsilon, outPoints);

  } else {

    // 2개의 끝점 추가
    outPoints.push(s, e);
  }

  return outPoints;
}
</code></pre><p><code class="notranslate" translate="no">v2.distanceToSegmentSq</code>는 점에서 선분까지의 거리 제곱을 계산하는 함수인데요.
실제 거리보다 계산이 더 빠르기 때문에 거리 제곱을 사용합니다.
우리는 어느 지점이 가장 멀리 있는지만 알면 되기 때문에 거리 제곱은 실제 거리와 마찬가지로 잘 작동합니다.</p>
<p>다음은 실행중인 결과물입니다.
거리를 조절하여 더 많은 점들이 추가되거나 제거되는 걸 확인해보세요.</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 400px; height: 300px;" src="/webgl/lessons/resources/bezier-curve-diagram.html?maxDepth=0&showCurve=true&showDistance=true"></iframe>
</div>

</p>
<p>볼링핀으로 돌아와 봅시다.
우리는 위 코드를 전체 에디터로 확장할 수 있어야 합니다.
점을 추가하거나 제거할 수 있어야 하고, 제어점을 고정하거나 고정 해제할 수 있어야 합니다.
실행 취소 등도 필요하지만... 더 쉬운 방법이 있습니다.
위에서 언급한 주요 에디터를 사용하면 되는데요.
저는 이 <a href="https://svg-edit.github.io/svgedit/">온라인 에디터</a>를 사용했습니다.</p>
<p>다음은 제가 만든 볼링핀 SVG 실루엣입니다.</p>
<p><img class="webgl_center" src="../resources/bowling-pin-silhouette.svg" width="50%" height="50%" /></p>
<p>이건 4개의 베지에 곡선으로 만들어 졌는데요.
해당 경로에 대한 데이터는 다음과 같습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">&lt;path fill=&quot;none&quot; stroke-width=&quot;5&quot; d=&quot;
   m44,434
   c18,-33 19,-66 15,-111
   c-4,-45 -37,-104 -39,-132
   c-2,-28 11,-51 16,-81
   c5,-30 3,-63 -36,-63
&quot;/&gt;
</code></pre><p><a href="https://developer.mozilla.org/en/docs/Web/SVG/Tutorial/Paths">데이터를 해석</a>하면 이런 점들을 얻을 수 있습니다. </p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">        ___
44, 371,   |
62, 338,   | 1st curve
63, 305,___|__
59, 260,___|  |
55, 215,      | 2nd curve
22, 156,______|__
20, 128,______|  |
18, 100,         | 3rd curve
31,  77,_________|__
36,  47,_________|  |
41,  17,            | 4th curve
39, -16,            |
 0, -16,____________|
</code></pre><p>이제 곡선에 대한 데이터가 있으니 곡선 위의 점을 계산해야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 모든 부분에서 점을 가져옵니다.
function getPointsOnBezierCurves(points, tolerance) {
  const newPoints = [];
  const numSegments = (points.length - 1) / 3;
  for (let i = 0; i &lt; numSegments; ++i) {
    const offset = i * 3;
    getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints);
  }
  return newPoints;
}
</code></pre><p>결과에 대해 <code class="notranslate" translate="no">simplifyPoints</code>를 호출합니다.</p>
<p>이제 이것들을 회전시켜야 하는데요.
얼마나 많이 나눌지 결정하고, 각 분할에 대해 <a href="webgl-2d-matrices.html">행렬 수학</a>을 사용하여 Y축을 중심으로 점들을 회전시킵니다.
모든 점을 만들었으면 인덱스를 사용하여 삼각형으로 연결합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// Y축을 중심으로 회전
function lathePoints(points,
                     startAngle,   // 시작하는 각도 (ie 0)
                     endAngle,     // 끝나는 각도 (ie Math.PI * 2)
                     numDivisions, // 만들 쿼드의 개수
                     capStart,     // true면 시작 부분을 막음
                     capEnd) {     // true면 끝 부분을 막음
  const positions = [];
  const texcoords = [];
  const indices = [];

  const vOffset = capStart ? 1 : 0;
  const pointsPerColumn = points.length + vOffset + (capEnd ? 1 : 0);
  const quadsDown = pointsPerColumn - 1;

  // 점 생성
  for (let division = 0; division &lt;= numDivisions; ++division) {
    const u = division / numDivisions;
    const angle = lerp(startAngle, endAngle, u) % (Math.PI * 2);
    const mat = m4.yRotation(angle);
    if (capStart) {
      // 시작 시 Y축에 점 추가
      positions.push(0, points[0][1], 0);
      texcoords.push(u, 0);
    }
    points.forEach((p, ndx) =&gt; {
      const tp = m4.transformPoint(mat, [...p, 0]);
      positions.push(tp[0], tp[1], tp[2]);
      const v = (ndx + vOffset) / quadsDown;
      texcoords.push(u, v);
    });
    if (capEnd) {
      // 끝날 때 Y축에 점 추가
      positions.push(0, points[points.length - 1][1], 0);
      texcoords.push(u, 1);
    }
  }

  // 인덱스 생성
  for (let division = 0; division &lt; numDivisions; ++division) {
    const column1Offset = division * pointsPerColumn;
    const column2Offset = column1Offset + pointsPerColumn;
    for (let quad = 0; quad &lt; quadsDown; ++quad) {
      indices.push(column1Offset + quad, column2Offset + quad, column1Offset + quad + 1);
      indices.push(column1Offset + quad + 1, column2Offset + quad, column2Offset + quad + 1);
    }
  }

  return {
    position: positions,
    texcoord: texcoords,
    indices: indices,
  };
}
</code></pre><p>위 코드는 위치와 텍스처 좌표를 생성한 다음, 인덱스를 생성하여 삼각형을 만듭니다.
<code class="notranslate" translate="no">capStart</code>와 <code class="notranslate" translate="no">capEnd</code>는 cap point의 생성 여부를 지정합니다.
캔을 만들고 있다고 상상해보세요.
이러한 옵션으로 끝을 닫을지 여부를 지정할 겁니다.</p>
<p><a href="webgl-less-code-more-fun.html">단순화된 코드</a>를 사용하여 다음과 같이 데이터로 WebGL 버퍼를 생성할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const tolerance = 0.15;
const distance = .4;
const divisions = 16;
const startAngle = 0;
const endAngle = Math.PI * 2;
const capStart = true;
const capEnd = true;

const tempPoints = getPointsOnBezierCurves(curvePoints, tolerance);
const points = simplifyPoints(tempPoints, 0, tempPoints.length, distance);
const arrays = lathePoints(points, startAngle, endAngle, divisions, capStart, capEnd);
const extents = getExtents(arrays.position);
if (!bufferInfo) {
  bufferInfo = webglUtils.createBufferInfoFromArrays(gl, arrays);
</code></pre><p>여기 예제가 있습니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-lathe-step-01.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-lathe-step-01.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>슬라이더를 움직여서 결과에 어떻게 영향을 주는지 확인해보세요.</p>
<p>다만 한 가지 문제가 있는데요.
삼각형을 활성화하면 텍스처가 고르게 적용되지 않는 것을 볼 수 있습니다.
이건 <code class="notranslate" translate="no">v</code> 텍스처 좌표가 선에 있는 점의 인덱스를 기반으로 하기 때문인데요.
이들이 균등하게 간격을 둔다면 동작할 수도 있습니다.
하지만 그렇지 않기 때문에 다른 작업을 해야 합니다.</p>
<p>점을 순회하여 곡선의 전체 길이와 곡선의 각 점들의 길이를 계산할 수 있습니다.
그런 다음 길이로 나누어 <code class="notranslate" translate="no">v</code>에 대해 더 좋은 값을 구합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// Y 액세스를 중심으로 회전
function lathePoints(points,
                     startAngle,   // 시작하는 각도 (ie 0)
                     endAngle,     // 끝나는 각도 (ie Math.PI * 2)
                     numDivisions, // 만들 쿼드의 개수
                     capStart,     // true면 윗 부분을 막음
                     capEnd) {     // true면 아랫 부분을 막음
  const positions = [];
  const texcoords = [];
  const indices = [];

  const vOffset = capStart ? 1 : 0;
  const pointsPerColumn = points.length + vOffset + (capEnd ? 1 : 0);
  const quadsDown = pointsPerColumn - 1;

+  // v 좌표 생성
+  let vcoords = [];
+
+  // 먼저 점들의 길이를 계산합니다.
+  let length = 0;
+  for (let i = 0; i &lt; points.length - 1; ++i) {
+    vcoords.push(length);
+    length += v2.distance(points[i], points[i + 1]);
+  }
+  vcoords.push(length);  // 마지막 점
+
+  // 이제 각각을 전체 길이로 나눕니다.
+  vcoords = vcoords.map(v =&gt; v / length);

  // 점 생성
  for (let division = 0; division &lt;= numDivisions; ++division) {
    const u = division / numDivisions;
    const angle = lerp(startAngle, endAngle, u) % (Math.PI * 2);
    const mat = m4.yRotation(angle);
    if (capStart) {
      // 시작 시 Y축에 점 추가
      positions.push(0, points[0][1], 0);
      texcoords.push(u, 0);
    }
    points.forEach((p, ndx) =&gt; {
      const tp = m4.transformPoint(mat, [...p, 0]);
      positions.push(tp[0], tp[1], tp[2]);
*      texcoords.push(u, vcoords[ndx]);
    });
    if (capEnd) {
      // 끝날 때 Y축에 점 추가
      positions.push(0, points[points.length - 1][1], 0);
      texcoords.push(u, 1);
    }
  }

  // 인덱스 생성
  for (let division = 0; division &lt; numDivisions; ++division) {
    const column1Offset = division * pointsPerColumn;
    const column2Offset = column1Offset + pointsPerColumn;
    for (let quad = 0; quad &lt; quadsDown; ++quad) {
      indices.push(column1Offset + quad, column1Offset + quad + 1, column2Offset + quad);
      indices.push(column1Offset + quad + 1, column2Offset + quad + 1, column2Offset + quad);
    }
  }

  return {
    position: positions,
    texcoord: texcoords,
    indices: indices,
  };
}
</code></pre><p>그리고 여기 결과입니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-lathe-step-02.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-lathe-step-02.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>이 텍스처 좌표들은 아직 완벽하지 않습니다.
Cap에 대해 무엇을 할지 정하지 않았는데요.
이게 바로 모델링 프로그램을 써야하는 또 다른 이유입니다.
Cap에 대한 UV 좌표를 계산하는 다른 아이디어를 생각해볼 수 있겠지만 그다지 유용하진 않을 겁니다.
구글에 <a href="https://www.google.com/search?q=uv+map+a+barrel">uv map a barrel</a>이라고 검색해보면 완벽한 UV 좌표를 얻는 것이, 데이터 입력 문제 정도의 수학 문제가 아니며, 해당 데이터를 입력하기 위해 좋은 도구가 필요하다는 것을 알 수 있습니다.</p>
<p>우리가 해야할 또 다른 것이 있는데 바로 법선을 추가하는 겁니다.</p>
<p>곡선의 각 점에 대한 법선을 계산할 수 있는데요.
실제로 이 페이지의 예제로 돌아가보면 <code class="notranslate" translate="no">R1</code>과 <code class="notranslate" translate="no">R2</code>로 구성된 선이 곡선의 접선입니다.</p>
<p><img class="webgl_center" src="../resources/tangent-to-curve.png" width="50%" /></p>
<p>법선은 접선에 수직이므로 접선을 사용하여 법선을 생성하기 쉬울 겁니다.</p>
<p>하지만 다음과 같은 실루엣의 촛대를 만들고 싶다고 상상해봅시다.</p>
<p><img class="webgl_center" src="../resources/candle-holder.svg" width="50%" /></p>
<p>매끄러운 부분도 많지만 각진 부분도 많습니다.
사용할 법선을 어떻게 정해야 할까요?
설상가상으로 뾰족한 모서리가 필요할 때 추가 정점을 필요로 하는데요.
정점은 위치과 법선을 가지기 때문에 같은 위치에 대해 다른 법선이 필요하다면 다른 정점이 필요합니다.
이게 큐브를 만들 때 실제로 최소 24개의 정점이 필요한 이유입니다.
큐브의 모서리는 8개뿐이지만 큐브의 각 면은 모서리에 서로 다른 법선을 필요로 합니다.</p>
<p>큐브를 생성할 때 법선을 생성하는 것은 쉽지만 좀 더 복잡한 모양의 경우 선택할 수 있는 쉬운 방법은 없습니다.</p>
<p>모든 모델링 프로그램은 법선을 생성하는 다양한 옵션을 가집니다.
일반적인 방법은 모든 단일 정점에 대해 해당 정점을 공유하는 모든 폴리곤의 법선을 평균화하는 겁니다.
단, 사용자가 최대 각도를 선택할 수 있습니다.
정점으로 공유된 폴리곤 사이의 각도가 최대 각도보다 크면 새로운 정점을 생성합니다.</p>
<p>한 번 해봅시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function generateNormals(arrays, maxAngle) {
  const positions = arrays.position;
  const texcoords = arrays.texcoord;

  // 먼저 각 면의 법선을 계산합니다.
  let getNextIndex = makeIndiceIterator(arrays);
  const numFaceVerts = getNextIndex.numElements;
  const numVerts = arrays.position.length;
  const numFaces = numFaceVerts / 3;
  const faceNormals = [];

  // 모든 면에 대한 법선을 계산합니다.
  // 그동안 모든 면의 정점에 대해 새로운 정점을 만듭니다.
  for (let i = 0; i &lt; numFaces; ++i) {
    const n1 = getNextIndex() * 3;
    const n2 = getNextIndex() * 3;
    const n3 = getNextIndex() * 3;

    const v1 = positions.slice(n1, n1 + 3);
    const v2 = positions.slice(n2, n2 + 3);
    const v3 = positions.slice(n3, n3 + 3);

    faceNormals.push(m4.normalize(m4.cross(m4.subtractVectors(v1, v2), m4.subtractVectors(v3, v2))));
  }

  let tempVerts = {};
  let tempVertNdx = 0;

  // 이는 정점 위치가 정확히 일치한다고 가정합니다.

  function getVertIndex(x, y, z) {

    const vertId = x + &quot;,&quot; + y + &quot;,&quot; + z;
    const ndx = tempVerts[vertId];
    if (ndx !== undefined) {
      return ndx;
    }
    const newNdx = tempVertNdx++;
    tempVerts[vertId] = newNdx;
    return newNdx;
  }

  // 공유된 정점을 파악해야 하는데요.
  // 이는 면(삼각형)을 보는 것만큼 간단하지 않습니다.
  // 예를 들어 표준 실린더가 있다면
  //
  //
  //      3-4
  //     /   \
  //    2     5   S에서 시작하여 E로 가는 실린더를 내려다보면,
  //    |     |   E와 S는 UV 좌표를 공유하지 않기 때문에
  //    1     6   우리가 가진 데이터에서 같은 정점이 아닙니다.
  //     \   /    
  //      S/E
  //
  // 시작과 끝 정점은 다른 UV를 가지기 때문에 정점을 공유하지 않지만
  // 정점을 공유하는 것으로 간주하지 않으면 잘못된 법선을 얻게 됩니다.

  const vertIndices = [];
  for (let i = 0; i &lt; numVerts; ++i) {
    const offset = i * 3;
    const vert = positions.slice(offset, offset + 3);
    vertIndices.push(getVertIndex(vert));
  }

  // 모든 정점을 살펴보고 어느 면이 있는지 기록합니다.
  const vertFaces = [];
  getNextIndex.reset();
  for (let i = 0; i &lt; numFaces; ++i) {
    for (let j = 0; j &lt; 3; ++j) {
      const ndx = getNextIndex();
      const sharedNdx = vertIndices[ndx];
      let faces = vertFaces[sharedNdx];
      if (!faces) {
        faces = [];
        vertFaces[sharedNdx] = faces;
      }
      faces.push(i);
    }
  }

  // 이제 모든 면을 살펴보고 면의 각 정점에 대한 법선을 계산합니다.
  // maxAngle 차이보다 크지 않은 면만 포함합니다.
  // newPositions, newTexcoords, newNormals 배열에 결과를 추가하고, 동일한 정점은 모두 버립니다.
  tempVerts = {};
  tempVertNdx = 0;
  const newPositions = [];
  const newTexcoords = [];
  const newNormals = [];

  function getNewVertIndex(x, y, z, nx, ny, nz, u, v) {
    const vertId =
        x + &quot;,&quot; + y + &quot;,&quot; + z + &quot;,&quot; +
        nx + &quot;,&quot; + ny + &quot;,&quot; + nz + &quot;,&quot; +
        u + &quot;,&quot; + v;

    const ndx = tempVerts[vertId];
    if (ndx !== undefined) {
      return ndx;
    }
    const newNdx = tempVertNdx++;
    tempVerts[vertId] = newNdx;
    newPositions.push(x, y, z);
    newNormals.push(nx, ny, nz);
    newTexcoords.push(u, v);
    return newNdx;
  }

  const newVertIndices = [];
  getNextIndex.reset();
  const maxAngleCos = Math.cos(maxAngle);
  // 각 면마다
  for (let i = 0; i &lt; numFaces; ++i) {
    // 이 면에 대한 법선 가져오기
    const thisFaceNormal = faceNormals[i];
    // 면의 각 정점마다
    for (let j = 0; j &lt; 3; ++j) {
      const ndx = getNextIndex();
      const sharedNdx = vertIndices[ndx];
      const faces = vertFaces[sharedNdx];
      const norm = [0, 0, 0];
      faces.forEach(faceNdx =&gt; {
        // 이 면이 같은 방향을 향하는지 여부
        const otherFaceNormal = faceNormals[faceNdx];
        const dot = m4.dot(thisFaceNormal, otherFaceNormal);
        if (dot &gt; maxAngleCos) {
          m4.addVectors(norm, otherFaceNormal, norm);
        }
      });
      m4.normalize(norm, norm);
      const poffset = ndx * 3;
      const toffset = ndx * 2;
      newVertIndices.push(getNewVertIndex(
          positions[poffset + 0], positions[poffset + 1], positions[poffset + 2],
          norm[0], norm[1], norm[2],
          texcoords[toffset + 0], texcoords[toffset + 1]));
    }
  }

  return {
    position: newPositions,
    texcoord: newTexcoords,
    normal: newNormals,
    indices: newVertIndices,
  };

}

function makeIndexedIndicesFn(arrays) {
  const indices = arrays.indices;
  let ndx = 0;
  const fn = function() {
    return indices[ndx++];
  };
  fn.reset = function() {
    ndx = 0;
  };
  fn.numElements = indices.length;
  return fn;
}

function makeUnindexedIndicesFn(arrays) {
  let ndx = 0;
  const fn = function() {
    return ndx++;
  };
  fn.reset = function() {
    ndx = 0;
  }
  fn.numElements = arrays.positions.length / 3;
  return fn;
}

function makeIndiceIterator(arrays) {
  return arrays.indices
      ? makeIndexedIndicesFn(arrays)
      : makeUnindexedIndicesFn(arrays);
}
</code></pre><p>위 코드에서 먼저 원본 점으로부터 각 면(각 삼각형)에 대한 법선을 생성합니다.
그런 다음 정점 인덱스 세트를 생성하여 동일한 점을 찾는데요.
그 이유는 점을 회전할 때 첫 번째 점과 마지막 점이 일치해야 하지만 다른 UV 좌표를 가지므로 같은 점이 아니기 때문입니다.
정점 법선을 계산하려면 같은 점으로 간주되어야 합니다.</p>
<p>완료되면 각 정점에 대해 사용되는 모든 면의 목록을 만듭니다.</p>
<p>마지막으로 <code class="notranslate" translate="no">maxAngle</code>보다 큰 것들을 제외하고 각 정점이 사용하는 모든 면의 법선을 평균화하여 새로운 정점 세트를 생성합니다.</p>
<p>여기 결과입니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-lathe-step-03.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-lathe-step-03.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>원하는 곳에 뾰족한 모서리를 만들었습니다.
<code class="notranslate" translate="no">maxAngle</code>를 더 크게 만들면 인접한 면들이 법선 계산에 포함되기 시작할 때 모서리가 매끄러워지는 것을 볼 수 있습니다.
또한 <code class="notranslate" translate="no">divisions</code>를 5나 6으로 조정하고 모서리는 각지지만 매끄럽게 하고 싶은 부분은 매끄러워질 때까지 <code class="notranslate" translate="no">maxAngle</code>을 조정해보세요.
<code class="notranslate" translate="no">mode</code>를 <code class="notranslate" translate="no">lit</code>으로 설정하여 법선이 필요한 이유인 조명과 함께 객체가 어떻게 보이는지 확인할 수도 있습니다.</p>
<h2 id="-">그래서 무엇을 배웠나요?</h2>
<p>3D 데이터를 만들고 싶다면 <strong>3D 모델링 패키지를 사용</strong>하면 된다는 걸 배웠습니다!!! 😝</p>
<p>정말로 유용한 무언가를 하려면 실제 <a href="https://www.google.com/search?q=uv+editor">UV 에디터</a>가 필요할 겁니다.
Cap을 잘 다루는 것도 3D가 도움이 될 수 있습니다.
선반 처리를 할 때 제한된 옵션 세트를 사용하는 대신에 에디터의 다른 기능을 사용하여 cap을 추가하고 더 쉽게 cap에 대한 UV를 생성할 수 있습니다.
또한 3D 에디터는 <a href="https://www.google.com/search?q=extruding+model">돌출된 면</a>과 <a href="https://www.google.com/search?q=extruding+along+a+path">경로를 따라 돌출</a>을 지원하는데, 위의 선반 예제를 보면 어떻게 작동하는지 알 수 있습니다.</p>
<h2 id="-">참고</h2>
<p><a href="https://pomax.github.io/bezierinfo/">베지에 곡선에 대한 멋진 페이지</a>가 없었다면 이걸 완료할 수 없었다고 언급하고 싶습니다.</p>
<div class="webgl_bottombar">
<h3>나머지 연산자는 여기서 뭘 하는 건가요?</h3>
<p><code class="notranslate" translate="no">lathePoints</code> 함수를 자세히 보면 각도를 계산할 때 나머지 연산을 볼 수 있습니다.</p>
<pre class="prettyprint showlinemods">
for (let division = 0; division <= numDivisions; ++division) {
  const u = division / numDivisions;
*  const angle = lerp(startAngle, endAngle, u) % (Math.PI * 2);
</pre>
<p>왜 저기에 있나요?</p>
<p>
원을 중심으로 점을 회전할 때 첫 번째와 마지막 점이 일치하도록 하고 싶어서 입니다.
<code class="notranslate" translate="no">Math.sin(0)</code>와 <code class="notranslate" translate="no">Math.sin(Math.PI * 2)</code>는 일치해야 하지만 컴퓨터의 부동 소수점 계산은 완벽하지 않으며 충분히 가깝지만 일반적으로 100% 동일하지는 않습니다.
</p>
<p>
이는 법선을 계산하려고 할 때 중요합니다.
사용하는 정점의 모든 면을 알아야 하는데요.
우리는 정점을 비교하여 이를 계산합니다.
만약 2개의 정점이 같다면 같은 정점이라고 가정합니다.
하지만 <code class="notranslate" translate="no">Math.sin(0)</code>와 <code class="notranslate" translate="no">Math.sin(Math.PI * 2)</code>가 같지 않기 때문에 동일한 정점으로 간주되지 않는데요.
이는 법선을 계산할 때 모든 면을 고려하지 않고 법선들이 잘못 나타남을 의미합니다.
</p>
<p>여기 그런 일이 일어났을 때의 결과입니다.</p>
<img class="webgl_center" src="../resources/lathe-normal-seam.png" width="50%" />
<p>보다시피 정점이 100% 일치하지 않기 때문에 공유된 것으로 간주되지 않는 곳에 경계선이 생깁니다.</p>
<p>
첫 생각은 일치하는 정점을 확인할 때 일정 거리 내에 있는지 확인하도록 수정해야 한다는 겁니다.
그렇다면 같은 정점인거죠.
예를 들어 이렇게 할 수 있습니다.
</p>
<pre class="prettyprint">
const epsilon = 0.0001;
const tempVerts = [];
function getVertIndex(position) {
  if (tempVerts.length) {
    // 가장 가까이 존재하는 정점 찾기
    let closestNdx = 0;
    let closestDistSq = v2.distanceSq(position, tempVerts[0]);
    for (let i = 1; i < tempVerts.length; ++i) {
      let distSq = v2.distanceSq(position, tempVerts[i]);
      if (distSq < closestDistSq) {
        closestDistSq = distSq;
        closestNdx = i;
      }
    }
    // 가장 가까운 정점은 충분히 가까운가?
    if (closestDistSq < epsilon) {
      // 그렇다면 정점의 인덱스 반환
      return closestNdx;
    }
  }
  // 일치하지 않으면 새로운 정점을 추가하고 해당 인덱스를 반환
  tempVerts.push(position);
  return tempVerts.length - 1;
}
</pre>
<p>
효과가 있었습니다!
경계선이 없어졌네요.
하지만 실행에 몇 초가 걸리고 인터페이스를 사용할 수 없게 되었습니다.
이는 O^2 해결법이기 때문인데요.
distance는 낮고, divisions은 높게, 최대 정점에 관한 슬라이더를 움직여보면, 정점을 114000개까지 생성할 수 있습니다.
O^2일 경우 최대 12조에 가까운 반복이 발생합니다.
</p>
<p>
인터넷에서 쉬운 해결책을 찾아봤지만 찾지 못했습니다.
일치하는 점을 더 빨리 찾도록 만들기 위해 모든 점을 <a href="https://en.wikipedia.org/wiki/Octree">octree</a>에 넣는 걸 생각해봤지만 이 글에서 다루긴 너무 많은 것 같습니다.
</p>
<p>
그제서야 끝점만 문제라면 수식에 나머지 연산을 추가하여 실제로 점이 동일하도록 할 수 있다는 것을 깨달았습니다.
원본 코드는 이렇습니다.
</p>
<pre class="prettyprint">
  const angle = lerp(startAngle, endAngle, u);
</pre>
그리고 새로운 코드는 이렇습니다.
<pre class="prettyprint">
  const angle = lerp(startAngle, endAngle, u) % (Math.PI * 2);
</pre>
<p>
나머지 연산 덕분에 <code class="notranslate" translate="no">endAngle</code>이 <code class="notranslate" translate="no">Math.PI * 2</code>일 때 <code class="notranslate" translate="no">angle</code>은 0이 되고 이는 <code class="notranslate" translate="no">startAngle</code>과 동일합니다
경계선이 없어졌네요.
문제가 해결되었습니다!
</p>
<p>
그래도 여전히 <code class="notranslate" translate="no">distance</code>를 0.001로 <code class="notranslate" translate="no">divisions</code>를 60으로 설정하면 메시를 다시 계산하는 데 거의 1초가 걸립니다.
이를 최적화하는 방법이 있을 수도 있지만 복잡한 메시를 생성하는 게 일반적으로 느린 작업이라는 것을 깨닫는 게 요점이라고 생각합니다.
이게 3D 게임은 60fps로 실행할 수 있지만 3D 모델링 패키지는 종종 매우 낮은 프레임 레이트로 작동하는 이유입니다.
</p>
</div>

<div class="webgl_bottombar">
<h3>행렬 수학은 여기에 과도한가요?</h3>
<p>점을 선반 처리할 때 회전시키는 이런 코드가 있습니다.</p>
<pre class="prettyprint">
const mat = m4.yRotation(angle);
...
points.forEach((p, ndx) => {
  const tp = m4.transformPoint(mat, [...p, 0]);
  ...
</pre>
<p>
임의의 3D point를 4x4 행렬로 변환하려면 16번의 곱셈, 12번의 덧셈, 3번의 나눗셈이 필요한데요.
<a href="webgl-2d-rotation.html">단위 원 스타일 회전 수식</a>을 사용하여 단순화할 수 있습니다.
</p>
<pre class="prettyprint">
const s = Math.sin(angle);
const c = Math.cos(angle);
...
points.forEach((p, ndx) => {
  const x = p[0];
  const y = p[1];
  const z = p[2];
  const tp = [
    x * c - z * s,
    y,
    x * s + z * c,
  ];
  ...
</pre>
<p>이는 4번의 곱셈과 2번의 덧셈만 수행하고 함수 호출이 없어서 최소 4배 더 빠릅니다.</p>
<p>
이 최적화에 가치가 있을까요?
글쎄요, 이 특정 예제에 대해 최적화가 중요할 만큼 충분히 수행한다고 생각하지 않습니다.
제 생각은 사용자가 회전할 축을 결정하도록 만들고 싶을 수 있다는 것이었습니다.
행렬을 사용하면 사용자가 축을 전달하여 다음과 같이 사용하기 쉽게 만들 수 있습니다.
</p>
<pre class="prettyprint">
   const mat = m4.axisRotation(userSuppliedAxis, angle);
</pre>
<p>
어느 방법이 최선인지는 당신과 당신의 필요에 달렸습니다.
저는 먼저 유연한 방법을 고르고 추후 너무 느리면 최적화할 겁니다.
</p>
</div>


    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-3d-geometry-lathe.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-3d-geometry-lathe.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-3d-geometry-lathe.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-3d-geometry-lathe.html" selected>한국어</a>
    <option value="/webgl/lessons/pl/webgl-3d-geometry-lathe.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-3d-geometry-lathe.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-3d-geometry-lathe.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-3d-geometry-lathe.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>기초</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-fundamentals.html">기초</a></li>
<li><a href="/webgl/lessons/ko/webgl-how-it-works.html">작동 방식</a></li>
<li><a href="/webgl/lessons/ko/webgl-shaders-and-glsl.html">셰이더와 GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL 상태 다이어그램</a></li>
        </ul>
  <li>이미지 처리</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-image-processing.html">이미지 처리</a></li>
<li><a href="/webgl/lessons/ko/webgl-image-processing-continued.html">이미지 처리 심화</a></li>
        </ul>
  <li>2D Translation, Rotation, Scale, 행렬 수학</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-translation.html">2D Translation</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-rotation.html">2D Rotation</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-scale.html">2D Scale</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrices.html">2D 행렬</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-orthographic.html">3D Orthographic</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective.html">3D Perspective</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-camera.html">3D 카메라</a></li>
        </ul>
  <li>조명</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-lighting-directional.html">방향성 조명</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-point.html">점 조명</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-spot.html">스포트라이트</a></li>
        </ul>
  <li>구조와 구성</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-multiple-things.html">여러 물체 그리기</a></li>
<li><a href="/webgl/lessons/ko/webgl-scene-graph.html">장면 그래프</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-geometry-lathe.html">Geometry - Lathe</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj.html">.obj 파일 로딩</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj-w-mtl.html">.mtl 파일로 .obj 로딩</a></li>
        </ul>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-textures.html">텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-data-textures.html">데이터 텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-2-textures.html">2개 이상의 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-cors-permission.html">Cross Origin Image</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective-correct-texturemapping.html">원근 교정 텍스처 매핑</a></li>
<li><a href="/webgl/lessons/ko/webgl-planar-projection-mapping.html">평면 및 원근 투영 매핑</a></li>
        </ul>
  <li>텍스처 렌더링</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-render-to-texture.html">텍스처 렌더링</a></li>
        </ul>
  <li>그림자</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-shadows.html">그림자</a></li>
        </ul>
  <li>기법</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrix-stack.html">2D - 행렬 스택</a></li>
<li><a href="/webgl/lessons/ko/webgl-sprites.html">Sprite</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-cube-maps.html">Cubemap</a></li>
<li><a href="/webgl/lessons/ko/webgl-environment-maps.html">Environment Map</a></li>
<li><a href="/webgl/lessons/ko/webgl-skybox.html">Skybox</a></li>
<li><a href="/webgl/lessons/ko/webgl-skinning.html">스키닝</a></li>
<li><a href="/webgl/lessons/ko/webgl-fog.html">안개</a></li>
<li><a href="/webgl/lessons/ko/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-text-html.html">텍스트 - HTML</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-canvas2d.html">텍스트 - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-texture.html">텍스트 - 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-glyphs.html">텍스트 - Glyph Texture 사용</a></li>
        </ul>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-ramp-textures.html">Ramp Textures (Toon Shading)</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Tip</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-smallest-programs.html">최소 프로그램</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-without-data.html">데이터 없이 그리기</a></li>
<li><a href="/webgl/lessons/ko/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ko/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>최적화</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ko/webgl-instanced-drawing.html">Instanced Drawing</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-setup-and-installation.html">설정 및 설치</a></li>
<li><a href="/webgl/lessons/ko/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/ko/webgl-resizing-the-canvas.html">Canvas 크기 조정</a></li>
<li><a href="/webgl/lessons/ko/webgl-animation.html">애니메이션</a></li>
<li><a href="/webgl/lessons/ko/webgl-points-lines-triangles.html">점, 선, 삼각형</a></li>
<li><a href="/webgl/lessons/ko/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/ko/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/ko/webgl-and-alpha.html">WebGL Alpha</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-vs-3d-library.html">2D vs 3D 라이브러리</a></li>
<li><a href="/webgl/lessons/ko/webgl-anti-patterns.html">Anti Pattern</a></li>
<li><a href="/webgl/lessons/ko/webgl-matrix-vs-math.html">WebGL 행렬 vs 수학 행렬</a></li>
<li><a href="/webgl/lessons/ko/webgl-precision-issues.html">정밀도 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#screenshot">Screenshot 찍기</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#preservedrawingbuffer">Canvas Clear 방지</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#tabindex">캔버스 키보드 입력</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#html-background">WebGL 배경 제작</a></li>
<li><a href="/webgl/lessons/ko/webgl-cross-platform-issues.html">Cross Platform 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-qna.html">질문 및 답변</a></li>
        </ul>
  <li>참고</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-attributes.html">Attribute</a></li>
<li><a href="/webgl/lessons/ko/webgl-texture-units.html">텍스처 유닛</a></li>
<li><a href="/webgl/lessons/ko/webgl-framebuffers.html">Framebuffer</a></li>
<li><a href="/webgl/lessons/ko/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ko/webgl-references.html">참고 자료</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">도우미 API 문서</a></li>
  <li><a href="https://twgljs.org">TWGL, 가벼운 WebGL 라이브러리</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Github</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
    <div>이슈/버그는? <a href="https://github.com/gfxfundamentals/webgl-fundamentals/issues">Github</a>에 이슈를 만들어주세요.</div>
    <div class="lesson-comment-notes">
      코드 블록은 <b>&lt;pre&gt;&lt;code&gt;</b>여기에 코드 입력<b>&lt;/code&gt;&lt;/pre&gt;</b>를 사용해주세요
    </div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL 3D Geometry - Lathe';
            var disqus_title = 'WebGL 3D Geometry - Lathe';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
      return;
  }

  function addScript(src, type, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    script.type = type || 'javascript';
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  // can't do this because it would eat contexts
  //addScript('//gpustats.org/stats.js', 'module');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>



