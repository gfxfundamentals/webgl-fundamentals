Title: WebGL ê·¸ë¦¼ì
Description: ê·¸ë¦¼ìë¥¼ ê³„ì‚°í•˜ëŠ” ë°©ë²•
TOC: ê·¸ë¦¼ì

ê·¸ë¦¼ìë¥¼ ê·¸ë ¤ë´…ì‹œë‹¤!

## ì‚¬ì „ì§€ì‹

ê¸°ë³¸ì ì¸ ê·¸ë¦¼ìë¥¼ ê³„ì‚°í•˜ëŠ” ê²ƒì€ *ê·¸ë ‡ê²Œê¹Œì§€* ì–´ë µì§€ëŠ” ì•Šì§€ë§Œ 
ë§ì€ ë°°ê²½ì§€ì‹ì„ í•„ìš”ë¡œ í•©ë‹ˆë‹¤. ì´ ê¸€ì„ ì´í•´í•˜ê¸° ìœ„í•´ì„œëŠ” 
ì•„ë˜ ë‚´ìš©ì— ëŒ€í•´ ì•Œê³  ê³„ì…”ì•¼ í•©ë‹ˆë‹¤.

* [ì§êµ íˆ¬ì˜](webgl-3d-orthographic.html)
* [ì›ê·¼ íˆ¬ì˜](webgl-3d-perspective.html)
* [ìŠ¤í¬íŠ¸ë¼ì´íŠ¸ íš¨ê³¼](webgl-3d-lighting-spot.html)
* [í…ìŠ¤ì²˜](webgl-3d-textures.html)
* [í…ìŠ¤ì²˜ì— ë Œë”ë§í•˜ê¸°](webgl-render-to-texture.html)
* [íˆ¬ì˜ ë§µí•‘](webgl-planar-projection-mapping.html)
* [ì¹´ë©”ë¼ë¥¼ ê°€ì‹œí™”í•˜ê¸°](webgl-visualizing-the-camera.html)

ê·¸ëŸ¬ë‹ˆ ìœ„ ê¸€ë“¤ì„ ì•„ì§ ì½ì§€ ì•Šìœ¼ì…¨ë‹¤ë©´ ë¨¼ì € ì½ê³  ì˜¤ì‹­ì‹œì˜¤.

ë¬´ì—‡ë³´ë‹¤, ì´ ê¸€ì€ ì—¬ëŸ¬ë¶„ì´ [ë” ì ì€ ì½”ë“œë¡œ ì¦ê²ê²Œ](webgl-less-code-more-fun.html)ë¥¼ ì´ë¯¸ ì½ìœ¼ì…¨ë‹¤ê³  ê°€ì •í•˜ê³  ìˆìŠµë‹ˆë‹¤.
ì´ ê¸€ì˜ ì˜ˆì œì—ì„œëŠ” ê·¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•´ì„œ ì½”ë“œë¥¼ ë‹¨ìˆœí™” í•˜ê³  ìˆìŠµë‹ˆë‹¤.
ì—¬ëŸ¬ë¶„ì´ ë²„í¼, vertex arrayì™€ attributeê°€ ë­”ì§€ ëª¨ë¥´ê² ë‹¤ê±°ë‚˜ 
`webglUtils.setUniforms`ê°™ì€ ì½”ë“œë¥¼ ë´¤ëŠ”ë° uniformì„ setí•œë‹¤ëŠ”ê²Œ ë¬´ìŠ¨ ëœ»ì¸ì§€ ëª¨ë¥´ì‹œê² ë‹¤ë©´, ë” ì•ìœ¼ë¡œ ëŒì•„ê°€ì„œ [ê¸°ì´ˆ ë¶€ë¶„ë¶€í„° ì½ê³  ì˜¤ì‹­ì‹œì˜¤](webgl-fundamentals.html).

ìš°ì„  ê·¸ë¦¼ìë¥¼ ê·¸ë¦¬ëŠ” ë°ëŠ” ì—¬ëŸ¬ê°€ì§€ ë°©ë²•ì´ ìˆìŠµë‹ˆë‹¤.
ê° ë°©ë²•ë“¤ì€ ì¥ë‹¨ì ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤. ê°€ì¥ í”íˆ ì‚¬ìš©ë˜ëŠ” ë°©ë²•ì€
ì‰ë„ìš° ë§µ(shadow map)ì„ ì‚¬ìš©í•´ì„œ ê·¸ë¦¼ìë¥¼ ê·¸ë¦¬ëŠ” ê²ƒì…ë‹ˆë‹¤.

ì‰ë„ìš° ë§µì€ ì‚¬ì „ì§€ì‹ì—ì„œ ì–¸ê¸‰í•œ ëª¨ë“  ê¸°ìˆ ì„ ì‚¬ìš©í•˜ì—¬ ë™ì‘í•©ë‹ˆë‹¤.

[íˆ¬ì˜ ë§µí•‘ê³¼ ê´€ë ¨ëœ ê¸€](webgl-planar-projection-mapping.html)ì—ì„œ ì´ë¯¸ì§€ë¥¼ ë¬¼ì²´ê²Œ íˆ¬ì˜í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ ë³´ì•˜ìŠµë‹ˆë‹¤.

{{{example url="../webgl-planar-projection-with-projection-matrix.html"}}}

ì´ë¯¸ì§€ëŠ” ì¥ë©´ì— ìˆëŠ” ë¬¼ì²´ì— ì§ì ‘ ê·¸ë ¤ì§„ ê²ƒì´ ì•„ë‹ˆë¼, ë¬¼ì²´ê°€ ë Œë”ë§ ë  ë•Œ 
ê° í”½ì…€ì— ëŒ€í•´ íˆ¬ì˜ëœ í…ìŠ¤ì²˜ ë²”ìœ„ ë‚´ì— ìˆëŠ”ì§€ë¥¼ í™•ì¸í•˜ê³  ë²”ìœ„ ë‚´ì— ìˆë‹¤ë©´ 
íˆ¬ì˜ëœ í…ìŠ¤ì²˜ë¡œë¶€í„° ì ì ˆí•œ ìƒ‰ìƒì„ ìƒ˜í”Œë§í•˜ëŠ” ë°©ì‹ì´ì—ˆìŠµë‹ˆë‹¤.
ë²”ìœ„ ë°–ì´ë¼ë©´ ë¬¼ì²´ì— ë§µí•‘ëœ ë‹¤ë¥¸ í…ìŠ¤ì²˜ë¡œë¶€í„° í…ìŠ¤ì²˜ ì¢Œí‘œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìƒ‰ìƒì„ 
ìƒ˜í”Œë§í•˜ì˜€ìŠµë‹ˆë‹¤.

ë§Œì¼ íˆ¬ì˜ëœ í…ìŠ¤ì²˜ê°€ ì¡°ëª…ì˜ ì‹œì ì—ì„œ ì–»ì–´ì§„ ê¹Šì´ ë°ì´í„°ë¼ë©´ ì–´ë–»ê²Œ ë ê¹Œìš”?
ë‹¤ì‹œë§í•´, ìœ„ ì˜ˆì œì—ì„œ ì¡°ëª…ì´ ì ˆë‘ì²´ì˜ ëë¶€ë¶„ì— ì¡´ì¬í•˜ëŠ” ê²ƒì²˜ëŸ¼ ê°€ì •í•˜ê³  
íˆ¬ì˜ëœ í…ìŠ¤ì²˜ê°€ ê·¸ ì¡°ëª… ìœ„ì¹˜ì—ì„œì˜ ê¹Šì´ê°’ì„ ê°€ì§€ê³  ìˆëŠ”ê²ë‹ˆë‹¤.
ê·¸ëŸ¬ë©´ êµ¬ëŠ” ì¡°ëª…ì— ê°€ê¹Œìš´ ê¹Šì´ê°’ì„ ê°€ì§ˆê±°ê³  í‰ë©´ì€ ë” ë¨¼ ê¹Šì´ê°’ì„ ê°€ì§ˆê²ë‹ˆë‹¤.

<div class="webgl_center"><img class="noinvertdark" src="resources/depth-map-generation.svg" style="width: 600px;"></div>

ê·¸ëŸ° ë°ì´í„°ë¥¼ í™•ë³´í•  ìˆ˜ ìˆë‹¤ë©´ ë Œë”ë§í•  ìƒ‰ìƒì„ ê²°ì •í•  ë•Œ íˆ¬ì˜ëœ í…ìŠ¤ì²˜ë¡œë¶€í„° 
ê¹Šì´ê°’ì„ ì–»ì–´ì˜¬ ìˆ˜ ìˆê³ , ê·¸ë¦¬ë ¤ëŠ” í”½ì…€ì´ ê·¸ ê¹Šì´ê°’ë³´ë‹¤ ì¡°ëª…ê³¼ ë” ë¨¼ì§€ 
ë” ê°€ê¹Œìš´ì§€ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ë§Œì¼ ë” ë©€ë‹¤ë©´ ë‹¤ë¥¸ ë” ì¡°ëª…ê³¼ ê°€ê¹Œìš´ ë¬¼ì²´ê°€ ìˆë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤. ë‹¤ì‹œë§í•´, 
ë¬´ì–¸ê°€ê°€ ì¡°ëª…ì„ ê°€ë¦¬ê³  ìˆì–´ì„œ í”½ì…€ì´ ê·¸ë¦¼ì ì˜ì—­ì— ìˆë‹¤ëŠ” ê²ë‹ˆë‹¤.

<div class="webgl_center"><img class="noinvertdark" src="resources/projected-depth-texture.svg" style="width: 600px;"></div>

ë³´ì‹œë©´ ê¹Šì´ í…ìŠ¤ì²˜ê°€ ì¡°ëª… ì‹œì ì—ì„œì˜ ì ˆë‘ì²´ ì¡°ëª… ê³µê°„ì„ í†µí•´ íˆ¬ì˜ë˜ê³  ìˆìŠµë‹ˆë‹¤.
ìš°ë¦¬ê°€ ë°”ë‹¥ë©´ í”½ì…€ì„ ê·¸ë¦´ ë•Œ ê·¸ í”½ì…€ì˜ ì¡°ëª…ìœ¼ë¡œë¶€í„°ì˜ ê¹Šì´ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤. (ìœ„ ê·¸ë¦¼ì—ì„œ 0.3)
ê·¸ë¦¬ê³  ë‚˜ì„œ ê¹Šì´ë§µ í…ìŠ¤ì²˜ì—ì„œëŠ” ì´ì™€ ëŒ€ì‘í•˜ëŠ” ê¹Šì´ê°’ì„ ì°¾ì•„ë´…ë‹ˆë‹¤.
ì¡°ëª… ì‹œì ì—ì„œ í…ìŠ¤ì²˜ì— ì €ì¥ëœ ê¹Šì´ê°’ì€ 0.1ì¸ë°, êµ¬ê°€ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.
0.1 &lt; 0.3ì´ë¯€ë¡œ ê·¸ ë°”ë‹¥ë©´ í”½ì…€ì€ ê·¸ë¦¼ì ë²”ìœ„ì— ìˆë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

First let's draw the shadow map.
We'll take the last example from [the article on planar projection mapping](webgl-planar-projection-mapping.html) but instead of loading a texture we'll [render to a texture](webgl-render-to-texture.html).
In [that article](webgl-render-to-texture.html) we used a depth renderbuffer.
That gave us a depth buffer for helping to sort pixels but we can't use a depth renderbuffer as a texture.
Fortunately there is an optional WebGL extension called `WEBGL_depth_texture` we can try to enable that will give us depth textures.
With a depth texture we can attach it to a framebuffer and then later use the texture as input to a shader.
The code to check for and enable the extension is:

```js
function main() {
  // Get A WebGL context
  /** @type {HTMLCanvasElement} */
  const canvas = document.querySelector('#canvas');
  const gl = canvas.getContext('webgl');
  if (!gl) {
    return;
  }

+  const ext = gl.getExtension('WEBGL_depth_texture');
+  if (!ext) {
+    return alert('need WEBGL_depth_texture');
+  }
```

Now, similarly to the  [article on rendering to a texture](webgl-render-to-texture.html) we create a texture then a framebuffer and a attach the texture to the framebuffer as a `DEPTH_ATTACHMENT`. 

```js
const depthTexture = gl.createTexture();
const depthTextureSize = 512;
gl.bindTexture(gl.TEXTURE_2D, depthTexture);
gl.texImage2D(
    gl.TEXTURE_2D,      // target
    0,                  // mip level
    gl.DEPTH_COMPONENT, // internal format
    depthTextureSize,   // width
    depthTextureSize,   // height
    0,                  // border
    gl.DEPTH_COMPONENT, // format
    gl.UNSIGNED_INT,    // type
    null);              // data
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

const depthFramebuffer = gl.createFramebuffer();
gl.bindFramebuffer(gl.FRAMEBUFFER, depthFramebuffer);
gl.framebufferTexture2D(
    gl.FRAMEBUFFER,       // target
    gl.DEPTH_ATTACHMENT,  // attachment point
    gl.TEXTURE_2D,        // texture target
    depthTexture,         // texture
    0);                   // mip level
```

[For a bunch of reasons](#attachment-combinations) we also need to create
a color texture and attach it as a color attachment even though we won't
actually use it.

```js
// create a color texture of the same size as the depth texture
const unusedTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, unusedTexture);
gl.texImage2D(
    gl.TEXTURE_2D,
    0,
    gl.RGBA,
    depthTextureSize,
    depthTextureSize,
    0,
    gl.RGBA,
    gl.UNSIGNED_BYTE,
    null,
);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

// attach it to the framebuffer
gl.framebufferTexture2D(
    gl.FRAMEBUFFER,        // target
    gl.COLOR_ATTACHMENT0,  // attachment point
    gl.TEXTURE_2D,         // texture target
    unusedTexture,         // texture
    0);                    // mip level
```

ì´ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œëŠ” ì„œë¡œë‹¤ë¥¸ ì…°ì´ë”ë¥¼ ì‚¬ìš©í•´ì„œ ì¥ë©´ì„ ë‘ë²ˆ ì´ìƒ ê·¸ë¦´ ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.
í•œ ë²ˆì€ ê¹Šì´ í…ìŠ¤ì²˜ë¡œ ë Œë”ë§í•˜ê¸°ìœ„í•œ ê°„ë‹¨í•œ ì…°ì´ë”ë¥¼ ì‚¬ìš©í•´ì„œ, 
í•œ ë²ˆì€ í…ìŠ¤ì²˜ë¥¼ íˆ¬ì˜í•˜ëŠ” í˜„ì¬ ì…°ì´ë”ë¥¼ ì‚¬ìš©í•´ì„œ ê·¸ë¦´ê²ë‹ˆë‹¤.

ë¨¼ì € `drawScene`ì„ ìˆ˜ì •í•´ì„œ ìš°ë¦¬ê°€ ë Œë”ë§ì„ ìˆ˜í–‰í•˜ë ¤ëŠ” í”„ë¡œê·¸ë¨ì„ ì „ë‹¬í•  ìˆ˜ ìˆë„ë¡ í•©ì‹œë‹¤.

```js
-function drawScene(projectionMatrix, cameraMatrix, textureMatrix) {
+function drawScene(projectionMatrix, cameraMatrix, textureMatrix, programInfo) {
  // ì¹´ë©”ë¼ í–‰ë ¬ë¡œ ë·° í–‰ë ¬ì„ ë§Œë“­ë‹ˆë‹¤.
  const viewMatrix = m4.inverse(cameraMatrix);

-  gl.useProgram(textureProgramInfo.program);
+  gl.useProgram(programInfo.program);

  // êµ¬ì™€ í‰ë©´ì— ëª¨ë‘ ì‚¬ìš©ë˜ëŠ” uniformì„ ì„¤ì •í•©ë‹ˆë‹¤.
  // ì£¼ì˜: ì…°ì´ë”ì— ëŒ€ì‘ë˜ëŠ” uniformì´ ì—†ëŠ”ê²½ìš° ë¬´ì‹œë©ë‹ˆë‹¤.
-  webglUtils.setUniforms(textureProgramInfo, {
+  webglUtils.setUniforms(programInfo, {
    u_view: viewMatrix,
    u_projection: projectionMatrix,
*    u_textureMatrix: textureMatrix,
-    u_projectedTexture: imageTexture,
+    u_projectedTexture: depthTexture,
  });

  // ------ êµ¬ë¥¼ ê·¸ë¦½ë‹ˆë‹¤. --------

  // attribute ì„¤ì •
-  webglUtils.setBuffersAndAttributes(gl, textureProgramInfo, sphereBufferInfo);
+  webglUtils.setBuffersAndAttributes(gl, programInfo, sphereBufferInfo);

  // êµ¬ì— í•„ìš”í•œ uniforms ì„¤ì •
-  webglUtils.setUniforms(textureProgramInfo, sphereUniforms);
+  webglUtils.setUniforms(programInfo, sphereUniforms);

  // gl.drawArrays ë˜ëŠ” gl.drawElements í˜¸ì¶œ
  webglUtils.drawBufferInfo(gl, sphereBufferInfo);

  // ------ í‰ë©´ì„ ê·¸ë¦½ë‹ˆë‹¤. --------

  // attribute ì„¤ì •
-  webglUtils.setBuffersAndAttributes(gl, textureProgramInfo, planeBufferInfo);
+  webglUtils.setBuffersAndAttributes(gl, programInfo, planeBufferInfo);

  // ìœ„ì—ì„œ ê³„ì‚°í•œ uniforms ì„¤ì •
-  webglUtils.setUniforms(textureProgramInfo, planeUniforms);
+  webglUtils.setUniforms(programInfo, planeUniforms);

  // gl.drawArrays ë˜ëŠ” gl.drawElements í˜¸ì¶œ
  webglUtils.drawBufferInfo(gl, planeBufferInfo);
}
```

ì´ì œ `drawScene`ì„ í™œìš©í•´ ì¥ë©´ì„ ì¡°ëª… ì‹œì ì—ì„œ ê·¸ë¦¬ê³ , ê·¸ í›„ì— ê¹Šì´ í…ìŠ¤ì²˜ë¥¼ ì‚¬ìš©í•´ ê·¸ë¦½ë‹ˆë‹¤.

```js
function render() {
  webglUtils.resizeCanvasToDisplaySize(gl.canvas);

  gl.enable(gl.CULL_FACE);
  gl.enable(gl.DEPTH_TEST);

  // ì¡°ëª… ì‹œì ì—ì„œ ë¨¼ì € ê·¸ë¦½ë‹ˆë‹¤.
-  const textureWorldMatrix = m4.lookAt(
+  const lightWorldMatrix = m4.lookAt(
      [settings.posX, settings.posY, settings.posZ],          // position
      [settings.targetX, settings.targetY, settings.targetZ], // target
      [0, 1, 0],                                              // up
  );
-  const textureProjectionMatrix = settings.perspective
+  const lightProjectionMatrix = settings.perspective
      ? m4.perspective(
          degToRad(settings.fieldOfView),
          settings.projWidth / settings.projHeight,
          0.5,  // near
          10)   // far
      : m4.orthographic(
          -settings.projWidth / 2,   // left
           settings.projWidth / 2,   // right
          -settings.projHeight / 2,  // bottom
           settings.projHeight / 2,  // top
           0.5,                      // near
           10);                      // far

+  // ê¹Šì´ í…ìŠ¤ì²˜ì— ê·¸ë¦½ë‹ˆë‹¤.
+  gl.bindFramebuffer(gl.FRAMEBUFFER, depthFramebuffer);
+  gl.viewport(0, 0, depthTextureSize, depthTextureSize);
+  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

-  drawScene(textureProjectionMatrix, textureWorldMatrix, m4.identity());
+  drawScene(lightProjectionMatrix, lightWorldMatrix, m4.identity(), colorProgramInfo);

+  // ì´ì œëŠ” ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ëŠ”ë°, ê¹Šì´ í…ìŠ¤ì²˜ë¥¼ ì”¬ì— íˆ¬ì˜í•´ì„œ ê·¸ë¦½ë‹ˆë‹¤.
+  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
+  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
+  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  let textureMatrix = m4.identity();
  textureMatrix = m4.translate(textureMatrix, 0.5, 0.5, 0.5);
  textureMatrix = m4.scale(textureMatrix, 0.5, 0.5, 0.5);
-  textureMatrix = m4.multiply(textureMatrix, textureProjectionMatrix);
+  textureMatrix = m4.multiply(textureMatrix, lightProjectionMatrix);
  // ì›”ë“œ í–‰ë ¬ì˜ ì—­í–‰ë ¬ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
  // ì´ë ‡ê²Œ í•˜ë©´ ë‹¤ë¥¸ ìœ„ì¹˜ê°’ë“¤ì´ ì´ ì›”ë“œ ê³µê°„ì— ìƒëŒ€ì ì¸ ê°’ì´ ë©ë‹ˆë‹¤.
  textureMatrix = m4.multiply(
      textureMatrix,
-      m4.inverse(textureWorldMatrix));
+      m4.inverse(lightWorldMatrix));

  // íˆ¬ì˜ í–‰ë ¬ ê³„ì‚°
  const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
  const projectionMatrix =
      m4.perspective(fieldOfViewRadians, aspect, 1, 2000);

  // lookAtì„ ì‚¬ìš©í•œ ì¹´ë©”ë¼ í–‰ë ¬ ê³„ì‚°
  const cameraPosition = [settings.cameraX, settings.cameraY, 7];
  const target = [0, 0, 0];
  const up = [0, 1, 0];
  const cameraMatrix = m4.lookAt(cameraPosition, target, up);

-  drawScene(projectionMatrix, cameraMatrix, textureMatrix); 
+  drawScene(projectionMatrix, cameraMatrix, textureMatrix, textureProgramInfo); 
}
```

`textureWorldMatrix`ë¥¼ `lightWorldMatrix`ë¡œ, `textureProjectionMatrix`ë¥¼ `lightProjectionMatrix`ë¡œ ì´ë¦„ì„ ë°”ê¾¼ ê²ƒì— ìœ ì˜í•˜ì„¸ìš”.
ì „ì—ëŠ” í…ìŠ¤ì²˜ë¥¼ ì„ì˜ì˜ ê³µê°„ìœ¼ë¡œ íˆ¬ì˜í–ˆì§€ë§Œ ì§€ê¸ˆì€ ì‰ë„ìš° ë§µì„ ì¡°ëª…ì—ì„œë¶€í„° íˆ¬ì˜í•˜ê³  ìˆìŠµë‹ˆë‹¤. ê³„ì‚° ë°©ë²•ì€ ê°™ì§€ë§Œ ë³€ìˆ˜ ì´ë¦„ì„ ë°”ê¾¸ëŠ” ê²ƒì´ ì ì ˆí•´ ë³´ì…ë‹ˆë‹¤.

ë¨¼ì € êµ¬ì™€ í‰ë©´ì„ ì ˆë‘ì²´ ë¼ì¸ì„ ê·¸ë¦¬ê¸° ìœ„í•´ ë§Œë“  ìƒ‰ìƒ ì…°ì´ë”ë¥¼ ì‚¬ìš©í•´ ê¹Šì´ í…ìŠ¤ì²˜ì— ë Œë”ë§ í–ˆìŠµë‹ˆë‹¤. 
ì´ ì…°ì´ë”ëŠ” ë‹¨ìƒ‰ì„ ê·¸ë¦¬ëŠ” ì…°ì´ë”ì´ê³  íŠ¹ë³„íˆ ë‹¤ë¥¸ ê³„ì‚°ì„ í•˜ê³  ìˆì§€ ì•Šì€ë° 
ê¹Šì´ í…ìŠ¤ì²˜ë¥¼ ë Œë”ë§í•˜ëŠ”ë°ëŠ” ì´ê²ƒì´ë©´ ì¶©ë¶„í•©ë‹ˆë‹¤.

ì´í›„ì— ì¥ë©´ì„ ìº”ë²„ìŠ¤ì— ë‹¤ì‹œ ê·¸ë¦¬ëŠ”ë° ì „ê³¼ ë™ì¼í•˜ê²Œ í…ìŠ¤ì²˜ë¥¼ ì¥ë©´ì— íˆ¬ì˜í•´ì„œ ê·¸ë¦½ë‹ˆë‹¤.
ì…°ì´ë”ì—ì„œ ê¹Šì´ í…ìŠ¤ì²˜ë¥¼ ì°¸ì¡°í•  ë•Œ redê°’ë§Œ ìœ íš¨í•˜ê¸° ë•Œë¬¸ì— 
red, gree, blueì— ëŒ€í•´ ê°™ì€ ê°’ì„ ë°˜ë³µí•˜ì—¬ í• ë‹¹í•©ë‹ˆë‹¤.

```glsl
void main() {
  vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;
  bool inRange = 
      projectedTexcoord.x >= 0.0 &&
      projectedTexcoord.x <= 1.0 &&
      projectedTexcoord.y >= 0.0 &&
      projectedTexcoord.y <= 1.0;

-  vec4 projectedTexColor = texture2D(u_projectedTexture, projectedTexcoord.xy);
+  // 'r'ì±„ë„ì— ê¹Šì´ê°’ì´ ì €ì¥ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
+  vec4 projectedTexColor = vec4(texture2D(u_projectedTexture, projectedTexcoord.xy).rrr, 1);
  vec4 texColor = texture2D(u_texture, v_texcoord) * u_colorMult;
  float projectedAmount = inRange ? 1.0 : 0.0;
  gl_FragColor = mix(texColor, projectedTexColor, projectedAmount);
}
```

ì´ì œ ì¥ë©´ì— ìœ¡ë©´ì²´ë¥¼ ì¶”ê°€í•´ ë´…ì‹œë‹¤.

```js
+const cubeBufferInfo = primitives.createCubeBufferInfo(
+    gl,
+    2,  // size
+);

...

+const cubeUniforms = {
+  u_colorMult: [0.5, 1, 0.5, 1],  // light green
+  u_color: [0, 0, 1, 1],
+  u_texture: checkerboardTexture,
+  u_world: m4.translation(3, 1, 0),
+};

...

function drawScene(projectionMatrix, cameraMatrix, textureMatrix, programInfo) {

    ...

+    // ------ ìœ¡ë©´ì²´ë¥¼ ê·¸ë¦½ë‹ˆë‹¤. --------
+
+    // í•„ìš”í•œ attributeë“¤ì„ ì„¤ì •í•©ë‹ˆë‹¤.
+    webglUtils.setBuffersAndAttributes(gl, programInfo, cubeBufferInfo);
+
+    // ë°©ê¸ˆ ê³„ì‚°í•œ uniformì„ ì…ë ¥í•©ë‹ˆë‹¤.
+    webglUtils.setUniforms(programInfo, cubeUniforms);
+
+    // gl.drawArrays ë˜ëŠ” gl.drawElementsë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
+    webglUtils.drawBufferInfo(gl, cubeBufferInfo);

...
```

ì„¸íŒ…ì„ ì¡°ê¸ˆ ë°”ê¿” ë³´ì£ . ì¹´ë©”ë¼ë¥¼ ì•½ê°„ ì´ë™í•˜ê³  ì‹œì•¼ê°(field of view)ì„ ë„“í˜€ì„œ 
íˆ¬ì˜ë˜ëŠ” í…ìŠ¤ì²˜ê°€ ë” ë§ì€ ë¶€ë¶„ì„ ë®ë„ë¡ í•´ ë´…ì‹œë‹¤.

```js
const settings = {
-  cameraX: 2.5,
+  cameraX: 6,
  cameraY: 5,
  posX: 2.5,
  posY: 4.8,
  posZ: 4.3,
  targetX: 2.5,
  targetY: 0,
  targetZ: 3.5,
  projWidth: 1,
  projHeight: 1,
  perspective: true,
-  fieldOfView: 45,
+  fieldOfView: 120,
};
```

ì£¼ì˜: ì ˆë‘ì²´ë¥¼ ë³´ì—¬ì£¼ê¸° ìœ„í•´ ë¼ì¸ì„ ê·¸ë¦¬ëŠ” ì½”ë“œëŠ” `drawScene` í•¨ìˆ˜ ë°–ìœ¼ë¡œ ì˜®ê²¼ìŠµë‹ˆë‹¤.

{{{example url="../webgl-shadows-depth-texture.html"}}}

ì´ë¯¸ì§€ë¥¼ ë¡œë”©í•˜ëŠ” ëŒ€ì‹  ì¥ë©´ì„ ê¹Šì´ í…ìŠ¤ì²˜ì— ë ŒëŸ¬ë”©í•œ ê²°ê³¼ë¥¼ 
ì‚¬ìš©í•œë‹¤ëŠ” ê²ƒë§Œ ì œì™¸í•˜ë©´ ìœ„ìª½ì˜ ì˜ˆì œì™€ ì™„ì „íˆ ë™ì¼í•©ë‹ˆë‹¤.
`cameraX`ë¥¼ 2.5ë¡œ `fieldOfView`ë¥¼ 45ë¡œ ë°”ê¾¸ë©´ ìœ„ìª½ê³¼ ë™ì¼í•œ ê²°ê³¼ë¥¼ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ë¡œë”©ëœ ì´ë¯¸ì§€ ëŒ€ì‹  ìš°ë¦¬ì˜ ê¹Šì´ í…ìŠ¤ì²˜ê°€ íˆ¬ì˜ë˜ê³  ìˆë‹¤ëŠ” ì ë§Œ ì œì™¸í•˜ë©´ìš”.

ê¹Šì´ê°’ì€ 0.0ì—ì„œ 1.0ì‚¬ì´ì˜ ê°’ì¸ë° ì ˆë‘ì²´ ë‚´ì—ì„œì˜ ìœ„ì¹˜ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
ê·¸ëŸ¬ë‹ˆ 0.0(ì–´ë‘ì›€)ì€ ì ˆë‘ì²´ì˜ ë¾°ì¡±í•œ ì ì— ê°€ê¹ê³  1.0(ë°ìŒ)ì€ ë°˜ëŒ€ìª½ ëì— ê°€ê¹ìŠµë‹ˆë‹¤.

ì´ì œ ë‚¨ì€ ê²ƒì€ íˆ¬ì˜ëœ í…ìŠ¤ì²˜ ìƒ‰ìƒê³¼ í…ìŠ¤ì²˜ ë§µí•‘ ìƒ‰ìƒ ì‚¬ì´ì˜ ì„ íƒì„ í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, 
ê¹Šì´ í…ìŠ¤ì²˜ì˜ ê¹Šì´ê°’ìœ¼ë¡œë¶€í„° ì–»ì€ Zê°’ì„ ì‚¬ìš©í•´ ê·¸ ê°’ì´ ìš°ë¦¬ê°€ ê·¸ë¦¬ë ¤ëŠ” í”½ì…€ì—ì„œ 
ì¹´ë©”ë¼ê¹Œì§€ì˜ ê±°ë¦¬ë³´ë‹¤ ë” ë¨¼ì§€ ê°€ê¹Œìš´ì§€ë¥¼ ì•Œì•„ë‚´ëŠ”ë° ì‚¬ìš©í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.
ê¹Šì´ í…ìŠ¤ì²˜ì˜ ê°’ì´ ë” ê°€ê¹Œìš°ë©´ ë¬´ì–¸ê°€ê°€ ë¹›ì„ ê°€ë¦¬ê³  ìˆëŠ” ê²ƒì´ê³ , ë”°ë¼ì„œ ê·¸ í”½ì…€ì€ 
ê·¸ë¦¼ì ì˜ì—­ ì•ˆì— ìˆìŠµë‹ˆë‹¤.

```glsl
void main() {
  vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;
+  float currentDepth = projectedTexcoord.z;

  bool inRange = 
      projectedTexcoord.x >= 0.0 &&
      projectedTexcoord.x <= 1.0 &&
      projectedTexcoord.y >= 0.0 &&
      projectedTexcoord.y <= 1.0;

-  vec4 projectedTexColor = vec4(texture2D(u_projectedTexture, projectedTexcoord.xy).rrr, 1);
+  float projectedDepth = texture2D(u_projectedTexture, projectedTexcoord.xy).r;
+  float shadowLight = (inRange && projectedDepth <= currentDepth) ? 0.0 : 1.0;  

  vec4 texColor = texture2D(u_texture, v_texcoord) * u_colorMult;
-  gl_FragColor = mix(texColor, projectedTexColor, projectedAmount);
+  gl_FragColor = vec4(texColor.rgb * shadowLight, texColor.a);
}
```

ìœ„ì—ì„œ `projectedDepth`ê°€ `currentDepth`ë³´ë‹¤ ì‘ìœ¼ë©´ ì¡°ëª…ì˜ ì‹œì ì—ì„œ 
ë” ê°€ê¹Œìš´ ë¬¼ì²´ê°€ ìˆëŠ” ê²ƒì´ë¯€ë¡œ ê·¸ë¦¬ë ¤ëŠ” í”½ì…€ì´ ê·¸ë¦¼ì ì˜ì—­ ì•ˆì— ìˆëŠ” ê²ƒì…ë‹ˆë‹¤.

ì‹¤í–‰í•´ ë³´ë©´ ê·¸ë¦¼ìê°€ ë‚˜íƒ€ë‚©ë‹ˆë‹¤.

{{{example url="../webgl-shadows-basic.html" }}}

êµ¬ì˜ ê·¸ë¦¼ìê°€ ë°”ë‹¥ë©´ì— ë‚˜íƒ€ë‚˜ëŠ” ê²ƒì„ ë³´ë‹ˆ ë˜ëŠ” ê²ƒ ê°™ê¸°ëŠ” í•œë°, 
ê·¸ë¦¼ìê°€ ì—†ì–´ì•¼ í•˜ëŠ” ê³³ì— ë‚˜íƒ€ë‚˜ëŠ” ì´ìƒí•œ íŒ¨í„´ì„ ë­˜ê¹Œìš”?
ì´ íŒ¨í„´ì€ *ê·¸ë¦¼ì ì—¬ë“œë¦„(shadow acne)*ì´ë¼ê³  í•©ë‹ˆë‹¤.
ê¹Šì´ í…ìŠ¤ì²˜ì— ì €ì¥ëœ ê¹Šì´ ë°ì´í„°ê°€ ì–‘ìí™”(quantize)ë˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.
ì´ëŠ” í…ìŠ¤ì²˜ ìì²´ê°€ í”½ì…€ì˜ ê·¸ë¦¬ë“œì´ê¸° ë•Œë¬¸ì´ê¸°ë„ í•˜ê³ , 
ì¡°ëª…ì˜ ì‹œì ìœ¼ë¡œ íˆ¬ì˜ë˜ì–´ ìƒì„±ë˜ì—ˆìœ¼ë‚˜ ê·¸ ê°’ì„ ì¹´ë©”ë¼ ì‹œì ì—ì„œ ë¹„êµí•˜ê³  ìˆê¸° ë•Œë¬¸ì´ê¸°ë„ í•©ë‹ˆë‹¤. 
ë‹¤ì‹œë§í•´ ê¹Šì´ë§µ ê²©ìì˜ ê°’ë“¤ì´ ì¹´ë©”ë¼ì™€ ì •ë ¬ë˜ì§€ ì•Šì•„ì„œ `currentDepth`ë¥¼ 
ê³„ì‚°í•  ë•Œ `projectedDepth`ë³´ë‹¤ ì•½ê°„ ì‘ê±°ë‚˜ í° ê²½ìš°ê°€ ìƒê¸°ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

ë°”ì´ì–´ìŠ¤(bias)ë¥¼ ë”í•´ ë´…ì‹œë‹¤.

```glsl
...

+uniform float u_bias;

void main() {
  vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;
-  float currentDepth = projectedTexcoord.z;
+  float currentDepth = projectedTexcoord.z + u_bias;

  bool inRange = 
      projectedTexcoord.x >= 0.0 &&
      projectedTexcoord.x <= 1.0 &&
      projectedTexcoord.y >= 0.0 &&
      projectedTexcoord.y <= 1.0;

  float projectedDepth = texture2D(u_projectedTexture, projectedTexcoord.xy).r;
  float shadowLight = (inRange && projectedDepth <= currentDepth) ? 0.0 : 1.0;  

  vec4 texColor = texture2D(u_texture, v_texcoord) * u_colorMult;
  gl_FragColor = vec4(texColor.rgb * shadowLight, texColor.a);
}
```

ê°’ì„ ì„¤ì •í•´ ì¤ë‹ˆë‹¤.

```js
const settings = {
  cameraX: 2.75,
  cameraY: 5,
  posX: 2.5,
  posY: 4.8,
  posZ: 4.3,
  targetX: 2.5,
  targetY: 0,
  targetZ: 3.5,
  projWidth: 1,
  projHeight: 1,
  perspective: true,
  fieldOfView: 120,
+  bias: -0.006,
};

...

function drawScene(projectionMatrix, cameraMatrix, textureMatrix, programInfo, /**/u_lightWorldMatrix) {
  // ì¹´ë©”ë¼ í–‰ë ¬ë¡œ ë·° í–‰ë ¬ì„ ë§Œë“­ë‹ˆë‹¤.
  const viewMatrix = m4.inverse(cameraMatrix);

  gl.useProgram(programInfo.program);

  // êµ¬ì™€ í‰ë©´ì— ëª¨ë‘ ì‚¬ìš©ë˜ëŠ” uniformì„ ì„¤ì •í•©ë‹ˆë‹¤.
  // ì£¼ì˜: ì…°ì´ë”ì— ëŒ€ì‘ë˜ëŠ” uniformì´ ì—†ëŠ”ê²½ìš° ë¬´ì‹œë©ë‹ˆë‹¤.
  webglUtils.setUniforms(programInfo, {
    u_view: viewMatrix,
    u_projection: projectionMatrix,
+    u_bias: settings.bias,
    u_textureMatrix: textureMatrix,
    u_projectedTexture: depthTexture,
  });

  ...
```

{{{example url="../webgl-shadows-basic-w-bias.html"}}}

ë°”ì´ì–´ìŠ¤ ê°’ì„ ë°”ê¿”ë³´ë©´ íŒ¨í„´ì´ ë‚˜íƒ€ë‚˜ëŠ” ìœ„ì¹˜ì™€ ì‹œì ì— ì˜í–¥ì„ ì£¼ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì½”ë“œë¥¼ ì™„ì„±í•˜ê¸° ìœ„í•´ [ìŠ¤í¬íŠ¸ë¼ì´íŠ¸ íš¨ê³¼](webgl-3d-lighting-spot.html)ì˜ 
ìŠ¤í¬íŠ¸ë¼ì´íŠ¸ ê³„ì‚° ì½”ë“œë¥¼ ì¶”ê°€í•˜ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.

ë¨¼ì € [ì´ ê¸€](webgl-3d-lighting-spot.html)ì˜ ì •ì  ì…°ì´ë”ì—ì„œ 
í•„ìš”í•œ ë¶€ë¶„ì„ ê°€ì ¸ë‹¤ ë¶™ì…ì‹œë‹¤.

```glsl
attribute vec4 a_position;
attribute vec2 a_texcoord;
+attribute vec3 a_normal;

+uniform vec3 u_lightWorldPosition;
+uniform vec3 u_viewWorldPosition;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;
uniform mat4 u_textureMatrix;

varying vec2 v_texcoord;
varying vec4 v_projectedTexcoord;
+varying vec3 v_normal;

+varying vec3 v_surfaceToLight;
+varying vec3 v_surfaceToView;

void main() {
  // ìœ„ì¹˜ì™€ í–‰ë ¬ì„ ê³±í•©ë‹ˆë‹¤.
  vec4 worldPosition = u_world * a_position;

  gl_Position = u_projection * u_view * worldPosition;

  // í”„ë˜ê·¸ë¨¼íŠ¸ ì…°ì´ë”ë¡œ í…ìŠ¤ì²˜ ì¢Œí‘œë¥¼ ì „ë‹¬í•©ë‹ˆë‹¤.
  v_texcoord = a_texcoord;

  v_projectedTexcoord = u_textureMatrix * worldPosition;

+  // ë²•ì„ ì„ ì¡°ì •í•˜ì—¬ í”„ë˜ê·¸ë¨¼íŠ¸ ì…°ì´ë”ë¡œ ì „ë‹¬í•©ë‹ˆë‹¤.
+  v_normal = mat3(u_world) * a_normal;
+
+  // í‘œë©´ì˜ ì›”ë“œê³µê°„ ìœ„ì¹˜ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
+  vec3 surfaceWorldPosition = (u_world * a_position).xyz;
+
+  // í‘œë©´ì—ì„œ ì¡°ëª…ì„ í–¥í•˜ëŠ” ë²¡í„°ë¥¼ ê³„ì‚°í•˜ê³ 
+  // í”„ë˜ê·¸ë¨¼íŠ¸ ì…°ì´ë”ë¡œ ì „ë‹¬í•©ë‹ˆë‹¤.
+  v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;
+
+  // í‘œë©´ì—ì„œ ë·°/ì¹´ë©”ë¼ë¥¼ í–¥í•˜ëŠ” ë²¡í„°ë¥¼ ê³„ì‚°í•˜ê³ 
+  // í”„ë˜ê·¸ë¨¼íŠ¸ ì…°ì´ë”ë¡œ ì „ë‹¬í•©ë‹ˆë‹¤.
+  v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;
}
```

í”„ë˜ê·¸ë¨¼íŠ¸ ì…°ì´ë”ëŠ”

```glsl
precision mediump float;

// ì •ì  ì…°ì´ë”ì—ì„œ ì „ë‹¬ëœ ê°’
varying vec2 v_texcoord;
varying vec4 v_projectedTexcoord;
+varying vec3 v_normal;
+varying vec3 v_surfaceToLight;
+varying vec3 v_surfaceToView;

uniform vec4 u_colorMult;
uniform sampler2D u_texture;
uniform sampler2D u_projectedTexture;
uniform float u_bias;
+uniform float u_shininess;
+uniform vec3 u_lightDirection;
+uniform float u_innerLimit;          // ë‚´ì  ê³µê°„ì—ì„œì˜ ê°’
+uniform float u_outerLimit;          // ë‚´ì  ê³µê°„ì—ì„œì˜ ê°’

void main() {
+  // v_normalì€ varying ì´ê¸° ë•Œë¬¸ì— ë³´ê°„ë˜ê³ , 
+  // ë‹¨ìœ„ ë²¡í„°ê°€ ì•„ë‹ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì •ê·œí™”ë¥¼ í•´ì„œ
+  // ë‹¤ì‹œ ë‹¨ìœ„ ë²¡í„°ë¡œ ë§Œë“¤ì–´ì¤ë‹ˆë‹¤.
+  vec3 normal = normalize(v_normal);
+
+  vec3 surfaceToLightDirection = normalize(v_surfaceToLight);
+  vec3 surfaceToViewDirection = normalize(v_surfaceToView);
+  vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);
+
+  float dotFromDirection = dot(surfaceToLightDirection,
+                               -u_lightDirection);
+  float limitRange = u_innerLimit - u_outerLimit;
+  float inLight = clamp((dotFromDirection - u_outerLimit) / limitRange, 0.0, 1.0);
+  float light = inLight * dot(normal, surfaceToLightDirection);
+  float specular = inLight * pow(dot(normal, halfVector), u_shininess);

  vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;
  float currentDepth = projectedTexcoord.z + u_bias;

  bool inRange =
      projectedTexcoord.x >= 0.0 &&
      projectedTexcoord.x <= 1.0 &&
      projectedTexcoord.y >= 0.0 &&
      projectedTexcoord.y <= 1.0;

  // 'r'ì±„ë„ì— ê¹Šì´ê°’ì´ ì €ì¥ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
  float projectedDepth = texture2D(u_projectedTexture, projectedTexcoord.xy).r;
  float shadowLight = (inRange && projectedDepth <= currentDepth) ? 0.0 : 1.0;

  vec4 texColor = texture2D(u_texture, v_texcoord) * u_colorMult;
-  gl_FragColor = vec4(texColor.rgb * shadowLight, texColor.a);
+  gl_FragColor = vec4(
+      texColor.rgb * light * shadowLight +
+      specular * shadowLight,
+      texColor.a);
}
```

`shadowLight`ë¥¼ `light`ì™€ `specular` íš¨ê³¼ì˜ ì–‘ì„ ì¡°ì ˆí•˜ê¸° ìœ„í•´ ì‚¬ìš©í•œ ê²ƒì— ì£¼ëª©í•˜ì„¸ìš”. 
ë¬¼ì²´ê°€ ê·¸ë¦¼ì ì˜ì—­ì— ìˆë‹¤ë©´ ë¹›ì´ ë“¤ì§€ ì•ŠëŠ”ê²ƒì…ë‹ˆë‹¤.

ì´ì œ uniformë“¤ì„ ì„¤ì •í•´ ì£¼ê¸°ë§Œ í•˜ë©´ ë©ë‹ˆë‹¤.

```js
-function drawScene(projectionMatrix, cameraMatrix, textureMatrix, programInfo) {
+function drawScene(
+    projectionMatrix,
+    cameraMatrix,
+    textureMatrix,
+    lightWorldMatrix,
+    programInfo) {
  // ì¹´ë©”ë¼ í–‰ë ¬ë¡œë¶€í„° ë·° í–‰ë ¬ì„ ë§Œë“­ë‹ˆë‹¤.
  const viewMatrix = m4.inverse(cameraMatrix);

  gl.useProgram(programInfo.program);

  // êµ¬ì™€ í‰ë©´ì— ëª¨ë‘ ì‚¬ìš©ë˜ëŠ” uniformì„ ì„¤ì •í•©ë‹ˆë‹¤.
  // ì£¼ì˜: ì…°ì´ë”ì— ëŒ€ì‘ë˜ëŠ” uniformì´ ì—†ëŠ”ê²½ìš° ë¬´ì‹œë©ë‹ˆë‹¤.
  webglUtils.setUniforms(programInfo, {
    u_view: viewMatrix,
    u_projection: projectionMatrix,
    u_bias: settings.bias,
    u_textureMatrix: textureMatrix,
    u_projectedTexture: depthTexture,
+    u_shininess: 150,
+    u_innerLimit: Math.cos(degToRad(settings.fieldOfView / 2 - 10)),
+    u_outerLimit: Math.cos(degToRad(settings.fieldOfView / 2)),
+    u_lightDirection: lightWorldMatrix.slice(8, 11).map(v => -v),
+    u_lightWorldPosition: lightWorldMatrix.slice(12, 15),
+    u_viewWorldPosition: cameraMatrix.slice(12, 15),
  });

...

function render() {
  ...

-  drawScene(lightProjectionMatrix, lightWorldMatrix, m4.identity(), colorProgramInfo);
+  drawScene(
+      lightProjectionMatrix,
+      lightWorldMatrix,
+      m4.identity(),
+      lightWorldMatrix,
+      colorProgramInfo);

  ...

-  drawScene(projectionMatrix, cameraMatrix, textureMatrix, textureProgramInfo);
+  drawScene(
+      projectionMatrix,
+      cameraMatrix,
+      textureMatrix,
+      lightWorldMatrix,
+      textureProgramInfo);

  ...
}
```

ì„¤ì •ëœ uniform ê°’ë“¤ì„ ë˜ì§šì–´ ë´…ì‹œë‹¤. [ìŠ¤í¬íŠ¸ë¼ì´íŠ¸ì— ê´€í•œ ê¸€](webgl-3d-lighting-spot.html)ì„ ë– ì˜¬ë ¤ë³´ë©´ innerLimitì™€ outerLimitì€ ë‚´ì  ê³µê°„(ì½”ì‚¬ì¸ ê³µê°„)ì˜ ê°’ì´ê³  
ì¡°ëª…ì˜ ë°©í–¥ì„ ë”°ë¼ì„œ ë»—ì–´ë‚˜ê°€ëŠ” í˜•ì‹ì´ê¸° ë•Œë¬¸ì— ì‹œì•¼ê°ì˜ ì ˆë°˜ë§Œ í•„ìš”í•©ë‹ˆë‹¤.
[ì¹´ë©”ë¼ì— ê´€í•œ ê¸€](webgl-3d-camera.html)ì—ì„œ 4x4 í–‰ë ¬ì˜ ì„¸ ë²ˆì§¸ í–‰ì´ Zì¶•ì¸ ê²ƒì„ 
ê¸°ì–µí•˜ì‹œë©´ `lightWorldMatrix`ë¡œë¶€í„° ì„¸ ë²ˆì§¸ í–‰ì˜ ì• ì„¸ê°œ ê°’ì„ ê°€ì ¸ì˜¤ë©´ ê·¸ê²ƒì´ ì¡°ëª…ì˜ -Zë°©í–¥ì´ë¼ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ìš°ë¦¬ëŠ” ì–‘ì˜ ë°©í–¥ì´ í•„ìš”í•˜ê¸° ë•Œë¬¸ì— ë’¤ì§‘ì—ˆìŠµë‹ˆë‹¤.
ê°™ì€ ê¸€ì„ í†µí•´ ë„¤ ë²ˆì§¸ í–‰ì´ ì›”ë“œê³µê°„ ìœ„ì¹˜ë¼ëŠ” ê²ƒì„ ì•Œê³  ìˆìœ¼ë¯€ë¡œ ê´€ë ¨ëœ í–‰ë ¬ë¡œë¶€í„° 
lightWorldPositionê³¼ viewWorldPosition(ì¹´ë©”ë¼ì˜ ì›”ë“œê³µê°„ ìœ„ì¹˜)ì„ ìœ ì‚¬í•˜ê²Œ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ë¬¼ë¡  ì´ ê°’ë“¤ì€ ë³€ìˆ˜ë¥¼ ë” ì¶”ê°€í•˜ê±°ë‚˜ ì„¸íŒ…í•  ìˆ˜ ìˆëŠ” ê°’ì„ ì¶”ê°€í•´ì„œë„ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë°°ê²½ë„ ê²€ì€ìƒ‰ìœ¼ë¡œ ë°”ê¾¸ê³  ì ˆë‘ì²´ë¥¼ í‘œì‹œí•˜ëŠ” ì„ ì€ í°ìƒ‰ìœ¼ë¡œ í•©ì‹œë‹¤.

```js
function render() {

  ...

  // ì´ì œ ê¹Šì´ í…ìŠ¤ì²˜ë¥¼ ì¥ë©´ì— íˆ¬ì˜í•˜ê³  ìº”ë²„ìŠ¤ì— ê·¸ë¦½ë‹ˆë‹¤.
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
+  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  ...

  // ------ ì ˆë‘ì²´ë¥¼ ê·¸ë¦½ë‹ˆë‹¤. ------
  {

    ...

    // ë°©ê¸ˆ ê³„ì‚°í•œ uniformê°’ë“¤ì„ ì„¤ì •í•©ë‹ˆë‹¤.
    webglUtils.setUniforms(colorProgramInfo, {
-      u_color: [0, 0, 0, 1],
+      u_color: [1, 1, 1, 1],
      u_view: viewMatrix,
      u_projection: projectionMatrix,
      u_world: mat,
    });
```

ì´ì œ ìŠ¤í¬íŠ¸ë¼ì´íŠ¸ì™€ ê·¸ë¦¼ìë¥¼ ì–»ì—ˆìŠµë‹ˆë‹¤.

{{{example url="../webgl-shadows-w-spot-light.html" }}}

ë°©í–¥ì„± ì¡°ëª…ì— ëŒ€í•´ì„œëŠ” [ë°©í–¥ì„± ì¡°ëª…ê³¼ ê´€ë ¨ëœ ê¸€](webgl-3d-lighting-directional.html)ì—ì„œ ì…°ì´ë” ì½”ë“œë¥¼ ë³µì‚¬í•˜ê³  
ì›ê·¼ íˆ¬ì˜ì„ ì§êµ íˆ¬ì˜ìœ¼ë¡œ ë°”ê¾¸ë©´ ë©ë‹ˆë‹¤.

ë¨¼ì € ì •ì  ì…°ì´ë”ëŠ”

```glsl
attribute vec4 a_position;
attribute vec2 a_texcoord;
+attribute vec3 a_normal;

-uniform vec3 u_lightWorldPosition;
-uniform vec3 u_viewWorldPosition;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;
uniform mat4 u_textureMatrix;

varying vec2 v_texcoord;
varying vec4 v_projectedTexcoord;
varying vec3 v_normal;

-varying vec3 v_surfaceToLight;
-varying vec3 v_surfaceToView;

void main() {
  // ìœ„ì¹˜ë¥¼ í–‰ë ¬ê³¼ ê³±í•©ë‹ˆë‹¤.
  vec4 worldPosition = u_world * a_position;

  gl_Position = u_projection * u_view * worldPosition;

  // í…ìŠ¤ì²˜ ì¢Œí‘œë¥¼ í”„ë˜ê·¸ë¨¼íŠ¸ ì…°ì´ë”ë¡œ ë„˜ê²¨ì¤ë‹ˆë‹¤.
  v_texcoord = a_texcoord;

  v_projectedTexcoord = u_textureMatrix * worldPosition;

  // ë²•ì„ ì˜ ë°©í–¥ì„ ì¡°ì •í•˜ê³  í”„ë˜ê·¸ë¨¼íŠ¸ ì…°ì´ë”ë¡œ ë…ê²¨ì¤ë‹ˆë‹¤.
  v_normal = mat3(u_world) * a_normal;

-  // í‘œë©´ì˜ ì›”ë“œê³µê°„ ìœ„ì¹˜ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
-  vec3 surfaceWorldPosition = (u_world * a_position).xyz;
-
-  // í‘œë©´ì—ì„œ ì¡°ëª…ì„ í–¥í•˜ëŠ” ë²¡í„°ë¥¼ ê³„ì‚°í•˜ê³ 
-  // í”„ë˜ê·¸ë¨¼íŠ¸ ì…°ì´ë”ë¡œ ì „ë‹¬í•©ë‹ˆë‹¤.
-  v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;
-
-  // í‘œë©´ì—ì„œ ë·°/ì¹´ë©”ë¼ë¥¼ í–¥í•˜ëŠ” ë²¡í„°ë¥¼ ê³„ì‚°í•˜ê³ 
-  // í”„ë˜ê·¸ë¨¼íŠ¸ ì…°ì´ë”ë¡œ ì „ë‹¬í•©ë‹ˆë‹¤.
-  v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;
}
```

í”„ë˜ê·¸ë¨¼íŠ¸ ì…°ì´ë”ì—ì„ ,

```glsl
precision mediump float;

// ì •ì  ì…°ì´ë”ì—ì„œ ë„˜ì–´ì˜¨ ê°’
varying vec2 v_texcoord;
varying vec4 v_projectedTexcoord;
varying vec3 v_normal;
-varying vec3 v_surfaceToLight;
-varying vec3 v_surfaceToView;

uniform vec4 u_colorMult;
uniform sampler2D u_texture;
uniform sampler2D u_projectedTexture;
uniform float u_bias;
-uniform float u_shininess;
-uniform vec3 u_lightDirection;
-uniform float u_innerLimit;          // in dot space
-uniform float u_outerLimit;          // in dot space
+uniform vec3 u_reverseLightDirection;

void main() {
  // v_normalì€ varying ì´ê¸° ë•Œë¬¸ì— ë³´ê°„ë˜ê³ , 
  // ë‹¨ìœ„ ë²¡í„°ê°€ ì•„ë‹ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì •ê·œí™”ë¥¼ í•´ì„œ
  // ë‹¤ì‹œ ë‹¨ìœ„ ë²¡í„°ë¡œ ë§Œë“¤ì–´ì¤ë‹ˆë‹¤.
  vec3 normal = normalize(v_normal);

+  float light = dot(normal, u_reverseLightDirection);

-  vec3 surfaceToLightDirection = normalize(v_surfaceToLight);
-  vec3 surfaceToViewDirection = normalize(v_surfaceToView);
-  vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);
-
-  float dotFromDirection = dot(surfaceToLightDirection,
-                               -u_lightDirection);
-  float limitRange = u_innerLimit - u_outerLimit;
-  float inLight = clamp((dotFromDirection - u_outerLimit) / limitRange, 0.0, 1.0);
-  float light = inLight * dot(normal, surfaceToLightDirection);
-  float specular = inLight * pow(dot(normal, halfVector), u_shininess);

  vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;
  float currentDepth = projectedTexcoord.z + u_bias;

  bool inRange =
      projectedTexcoord.x >= 0.0 &&
      projectedTexcoord.x <= 1.0 &&
      projectedTexcoord.y >= 0.0 &&
      projectedTexcoord.y <= 1.0;

  // 'r'ì€ ê¹Šì´ ê°’ì„ ì €ì¥í•˜ê³  ìˆìŠµë‹ˆë‹¤.
  float projectedDepth = texture2D(u_projectedTexture, projectedTexcoord.xy).r;
  float shadowLight = (inRange && projectedDepth <= currentDepth) ? 0.0 : 1.0;

  vec4 texColor = texture2D(u_texture, v_texcoord) * u_colorMult;
  gl_FragColor = vec4(
-      texColor.rgb * light * shadowLight +
-      specular * shadowLight,
+      texColor.rgb * light * shadowLight,
      texColor.a);
}
```

uniformë“¤ì€

```js
  // êµ¬ì™€ í‰ë©´ì— ëª¨ë‘ ì‚¬ìš©ë˜ëŠ” uniformì„ ì„¤ì •í•©ë‹ˆë‹¤.
  // ì£¼ì˜: ì…°ì´ë”ì— ëŒ€ì‘ë˜ëŠ” uniformì´ ì—†ëŠ”ê²½ìš° ë¬´ì‹œë©ë‹ˆë‹¤.
  webglUtils.setUniforms(programInfo, {
    u_view: viewMatrix,
    u_projection: projectionMatrix,
    u_bias: settings.bias,
    u_textureMatrix: textureMatrix,
    u_projectedTexture: depthTexture,
-    u_shininess: 150,
-    u_innerLimit: Math.cos(degToRad(settings.fieldOfView / 2 - 10)),
-    u_outerLimit: Math.cos(degToRad(settings.fieldOfView / 2)),
-    u_lightDirection: lightWorldMatrix.slice(8, 11).map(v => -v),
-    u_lightWorldPosition: lightWorldMatrix.slice(12, 15),
-    u_viewWorldPosition: cameraMatrix.slice(12, 15),
+    u_reverseLightDirection: lightWorldMatrix.slice(8, 11),
  });
```

ì¥ë©´ì„ ë„“ê²Œ ë³´ê¸° ìœ„í•´ ì¹´ë©”ë¼ë¥¼ ì¡°ì •í•˜ì˜€ìŠµë‹ˆë‹¤.

{{{example url="../webgl-shadows-w-directional-light.html"}}}

ì½”ë“œë¥¼ ë³´ë©´ ëª…í™•í•œë° ì›ë˜ ë°©í–¥ì„± ì¡°ëª…ì€ ë°©í–¥ë§Œ ê°€ì§€ê³  ìœ„ì¹˜ëŠ” ì—†ì§€ë§Œ, 
ìš°ë¦¬ì˜ ì‰ë„ìš°ë§µì€ ë„ˆë¬´ ì»¤ì„œ íŠ¹ì • ìœ„ì¹˜ë¥¼ ê³¨ë¼ ì‰ë„ìš° ë§µì„ ì ìš©í•  ë¶€ë¶„ì— ëŒ€í•´ì„œë§Œ 
ê³„ì‚°ì„ ìˆ˜í–‰í•˜ë„ë¡ ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

ê¸€ì´ ë„ˆë¬´ ê¸¸ì–´ì§€ê³  ìˆëŠ”ë° ì—¬ì „íˆ ê·¸ë¦¼ìì™€ ê´€ë ¨í•´ì„œëŠ” ë‹¤ë£° ë‚´ìš©ë“¤ì´ ë§ì´ ìˆìŠµë‹ˆë‹¤.
ë‚˜ë¨¸ì§€ëŠ” [ë‹¤ìŒ ê¸€](webgl-shadows-continued.html)ì—ì„œ ì•Œì•„ë³´ë„ë¡ í•©ì‹œë‹¤.

<div class="webgl_bottombar">
<a id="attachment-combinations"></a>
<h3>Why did we need to create an unused color texture?</h3>
<p>Here we get buried in the minutia of the WebGL spec.</p>
<p>WebGL is based on OpenGL ES 2.0 and the <a href="https://www.khronos.org/registry/webgl/specs/latest/1.0/">WebGL spec</a>
basically says WebGL follows the OpenGL ES 2.0 spec except for any exceptions
listed in the WebGL spec.</p>
<p>When you make a framebuffer you add attachments. You can add all kinds of
attachments. Above we added an RGBA/UNSIGNED_BYTE texture color attachment
and a depth texture attachment. In the article on rendering to textures we
attached a similar color attachment but we attached a depth renderbuffer,
not a depth texture. We could also attach an RGB texture, a LUMINANCE texture,
and many other types of textures and renderbuffers.</p>
<p>The <a href="">OpenGL ES 2.0 spec</a> gives a bunch of rules on whether
or not a certain combination of attachments will work together. One rule
is that there must be at least one attachment. Another rule is
that they all have to be the same size. The final rule is</p>
<blockquote>
<h4>4.4.5 Framebuffer Completeness</h4>
<p>
The combination of internal formats of the attached images does not violate an <b>implementation-dependent</b> set of restrictions.
</p>
</blockquote>
<p>
That unfortunate wording means <b>no combinations of attachments are required to work!</b>
</p>
<p>
The WebGL committee saw that and decided to require that WebGL implementations support
at least 3 common combinations. From <a href="https://www.khronos.org/registry/webgl/specs/latest/1.0/#6.8">Section 6.8 of the WebGL spec</a> they are:
<blockquote>
<ul>
  <li><code>COLOR_ATTACHMENT0</code> = <code>RGBA</code>/<code>UNSIGNED_BYTE</code> texture</li>
  <li><code>COLOR_ATTACHMENT0</code> = <code>RGBA</code>/<code>UNSIGNED_BYTE</code> texture + <code>DEPTH_ATTACHMENT</code> = <code>DEPTH_COMPONENT16</code> renderbuffer</li>
  <li><code>COLOR_ATTACHMENT0</code> = <code>RGBA</code>/<code>UNSIGNED_BYTE</code> texture + <code>DEPTH_STENCIL_ATTACHMENT</code> = <code>DEPTH_STENCIL</code> renderbuffer</li>
</blockquote>
<p>
Later the <a href="https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/">WEBGL_depth_texture</a> extensions was created.
All it really says is
that you can create depth textures and you can attach them to framebuffers
but it does not say anything more about required combinations. So, given
the OpenGL ES 2.0 spec rule that says what combinations are allowed to work
is up to the implementation, and given that the WebGL spec only lists 3
combinations required to work and that none of those combinations include
depth textures, only depth renderbuffers, that means there is no guarantee
that using a depth texture will ever work, at least according to the spec.
</p>
<p>In practice it appears that most drivers themselves work with just a depth
texture attached and no other attachments. Unfortunately Safari, at least as of
February 2020, does not allow that combination to work. It requires there be a
color attachment as well, most likely it requires an <code>RGBA</code>/<code>UNSIGNED_BYTE</code>
color attachment. The fact that it fails without it is within the specs above.
</p>
<p>All that is the long way of saying we need the unused color texture to work
in Safari. It also sadly means there's still no guarantee that things will work
across all drivers/gpus/browsers. Fortunately it appears that combination does
work everywhere. Also fortunately OpenGL ES 3.0 on which <a href="https://webgl2fundamentals.org">WebGL2</a>
is based changed the spec and requires many more combinations to just work. Unfortunately
as of February 2020 <a href="https://webgl2fundamentals.org/webgl/lessons/webgl-getting-webgl2.html">Safari does not support WebGL2</a>.
So, in WebGL1, we need to add the unused color texture and then cross our fingers. ğŸ˜­
</p>
</div>

