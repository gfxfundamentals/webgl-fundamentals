<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ko/webgl-instanced-drawing.md. Do not edited directly -->
<!--
Copyright 2021 GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="동일한 객체의 여러 인스턴스 그리기">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-instanced-drawing_ko.jpg">

<meta property="og:title" content="WebGL 최적화 - 색인된 그리기">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-instanced-drawing_ko.jpg">
<meta property="og:description" content="동일한 객체의 여러 인스턴스 그리기">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/ko/webgl-instanced-drawing.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGL 최적화 - 색인된 그리기">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/ko/webgl-instanced-drawing.html">
<meta name="twitter:description" content="동일한 객체의 여러 인스턴스 그리기">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-instanced-drawing_ko.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-instanced-drawing.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-instanced-drawing_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-instanced-drawing.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/ko/webgl-instanced-drawing.html",
      "inLanguage":"ko",
      "name":"WebGL 최적화 - 색인된 그리기",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-instanced-drawing.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL 최적화 - 색인된 그리기</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/ko/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-instanced-drawing.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-instanced-drawing.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-instanced-drawing.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-instanced-drawing.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-instanced-drawing.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-instanced-drawing.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-instanced-drawing.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-instanced-drawing.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-instanced-drawing.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-instanced-drawing.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-instanced-drawing.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-instanced-drawing.html" selected>한국어</a>
    <option value="/webgl/lessons/pl/webgl-instanced-drawing.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-instanced-drawing.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-instanced-drawing.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-instanced-drawing.html" >简体中文</a>
</select>


    <a href="#toc">목차</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ko/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL 최적화 - 색인된 그리기</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>WebGL은 <em>색인된 그리기</em>라는 기능을 가지고 있습니다.
기본적으로 개별적으로 그릴 때보다 빠르게 같은 걸 여러 번 그리는 방법입니다.</p>
<p>참고로 이 기능은 WebGL1의 선택적 확장이지만 <a href="https://web3dsurvey.com/webgl/extensions/ANGLE_instanced_arrays">거의 모든 브라우저와 기기에서 사용 가능</a>합니다.</p>
<p>먼저 동일한 항목의 여러 인스턴스를 그리는 예제부터 만들어 봅시다.</p>
<p><a href="webgl-3d-orthographic.html">직교 투영</a>에 관한 글의 마지막 부분과 유사한 코드로 출발하여 다음과 같은 두 셰이더로 시작합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;!-- 정점 셰이더 --&gt;
&lt;script id=&quot;vertex-shader-3d&quot; type=&quot;x-shader/x-vertex&quot;&gt;
attribute vec4 a_position;
uniform mat4 matrix;

void main() {
  // 위치에 행렬 곱하기
  gl_Position = matrix * a_position;
}
&lt;/script&gt;
</code></pre>
<p>그리고</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;!-- 프래그먼트 셰이더 --&gt;
&lt;script id=&quot;fragment-shader-3d&quot; type=&quot;x-shader/x-fragment&quot;&gt;
precision mediump float;

uniform vec4 color;

void main() {
  gl_FragColor = color;
}
&lt;/script&gt;
</code></pre>
<p>정점 셰이더는 각 정점을 <a href="webgl-3d-orthographic.html">해당 글</a>에서 다룬 상당히 유연한 배열인 단일 행렬로 곱합니다.
프래그먼트 셰이더는 유니폼을 통해 전달한 색상을 사용합니다.</p>
<p>그리기 위해서는 세이더를 컴파일하고 서로 연결한 다음 속성과 유니폼의 위치를 찾아야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const program = webglUtils.createProgramFromScripts(gl, [&#39;vertex-shader-3d&#39;, &#39;fragment-shader-3d&#39;]);

const positionLoc = gl.getAttribLocation(program, &#39;a_position&#39;);
const colorLoc = gl.getUniformLocation(program, &#39;color&#39;);
const matrixLoc = gl.getUniformLocation(program, &#39;matrix&#39;);
</code></pre>
<p>그런 다음 버퍼를 통해 위치에 대한 데이터를 제공해야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -0.1,  0.4,
  -0.1, -0.4,
   0.1, -0.4,
   0.1, -0.4,
  -0.1,  0.4,
   0.1,  0.4,
   0.4, -0.1,
  -0.4, -0.1,
  -0.4,  0.1,
  -0.4,  0.1,
   0.4, -0.1,
   0.4,  0.1,
]), gl.STATIC_DRAW);
const numVertices = 12;
</code></pre>
<p>5개의 인스턴스를 그려봅시다.
각 인스턴스에 대해 5개의 행렬과 5개의 색상을 만들겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const numInstances = 5;
const matrices = [
  m4.identity(),
  m4.identity(),
  m4.identity(),
  m4.identity(),
  m4.identity(),
];

const colors = [
  [ 1, 0, 0, 1, ],  // 빨간색
  [ 0, 1, 0, 1, ],  // 초록색
  [ 0, 0, 1, 1, ],  // 파란색
  [ 1, 0, 1, 1, ],  // 자주색
  [ 0, 1, 1, 1, ],  // 청록색
];
</code></pre>
<p>그리기 위해서는 먼저 셰이더 프로그램을 사용해서, 속성을 설정하고, 5개의 인스턴스를 반복한 다음, 각각에 대한 새로운 행렬을 계산하고, 행렬의 유니폼과 색상을 설정 후 그립니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function render(time) {
  time *= 0.001; // 초 단위

  gl.useProgram(program);

  // 위치 속성 설정
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(
    positionLoc,  // 위치
    2,            // 크기 (반복마다 버퍼에서 가져오는 값의 개수)
    gl.FLOAT,     // 버퍼 데이터 타입
    false,        // 정규화
    0,            // 스트라이드 (0 = 위 크기와 타입으로 계산)
    0,            // 버퍼 오프셋
  );

  matrices.forEach((mat, ndx) =&gt; {
    m4.translation(-0.5 + ndx * 0.25, 0, 0, mat);
    m4.zRotate(mat, time * (0.1 + 0.1 * ndx), mat);

    const color = colors[ndx];

    gl.uniform4fv(colorLoc, color);
    gl.uniformMatrix4fv(matrixLoc, false, mat);

    gl.drawArrays(
      gl.TRIANGLES,
      0,             // 오프셋
      numVertices,   // 인스턴스당 정점 수
    );
  });

  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</code></pre>
<p>참고로 행렬 수학 라이브러리는 각 행렬 수학 함수의 끝에서 선택적 대상 행렬을 사용합니다.
대부분의 글에서 이 기능을 사용하지 않고 라이브러리가 새로운 행렬을 할당하도록 했지만 이번에는 이미 생성된 행렬에 결과를 저장하려 합니다.</p>
<p>이는 잘 동작하며 다른 색상을 가진 5개의 더하기 기호가 회전합니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-instanced-drawing-not-instanced.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-instanced-drawing-not-instanced.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p><code class="notranslate" translate="no">gl.uniform4v</code>, <code class="notranslate" translate="no">gl.uniformMatrix4fv</code>, <code class="notranslate" translate="no">gl.drawArrays</code>를 각각 5번 호출하여 총 15번의 WebGL 호출을 가지는데요.
셰이더가 더 복잡하다면, <a href="webgl-3d-lighting-spot.html">스포트라이트</a>의 셰이더처럼, 6번의 <code class="notranslate" translate="no">gl.uniformXXX</code> 호출과 한 번의 <code class="notranslate" translate="no">gl.drawArrays</code> 호출로, 객체당 최소 7번의 호출을 가집니다.
400개의 객체를 그린다면 2800 WebGL 호출이 될 겁니다.</p>
<p>색인화은 이러한 호출을 줄이는 방법입니다.
이는 동일한 항목을 몇 번 그려야 하는지 WebGL에 알려주는 방식으로 작동합니다.
각 속성에 대해 정점 셰이더가 호출될 때마다 해당 속성을 할당된 버퍼에서 <em>다음 값</em>으로 진행할지(기본값), 또는 일반적으로 N이 1인 모든 N 인스턴스만 진행할지 지정합니다.</p>
<p>예를 들어 유니폼에서 <code class="notranslate" translate="no">matrix</code>와 <code class="notranslate" translate="no">color</code>를 제공하는 대신, <code class="notranslate" translate="no">attribute</code>를 통해 제공할 수 있는데요.
각 인스턴스의 행렬과 색상을 버퍼에 넣고, 속성이 해당 버퍼에서 데이터를 가져오도록 설정한 다음, 인스턴스당 한 번만 다음 값으로 진행하도록 WebGL에 지시할 겁니다.</p>
<p>해봅시다!</p>
<p>먼저 해야할 일은 WebGL의 해당 선택적 기능을 확인하고 활성화하는 겁니다.
<a href="https://developer.mozilla.org/en-US/docs/Web/API/ANGLE_instanced_arrays"><code class="notranslate" translate="no">ANGLE_instanced_arrays</code></a>라고 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const canvas = document.querySelector(&#39;#canvas&#39;);
const gl = canvas.getContext(&#39;webgl&#39;);
if (!gl) {
  return;
}

+const ext = gl.getExtension(&#39;ANGLE_instanced_arrays&#39;);
+if (!ext) {
+  return alert(&#39;need ANGLE_instanced_arrays&#39;);
+}
</code></pre>
<p>다음은 <code class="notranslate" translate="no">matrix</code>와 <code class="notranslate" translate="no">color</code>에 대해 유니폼 대신 속성을 사용하도록 셰이더를 수정할 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;!-- 정점 셰이더 --&gt;
&lt;script id=&quot;vertex-shader-3d&quot; type=&quot;x-shader/x-vertex&quot;&gt;
attribute vec4 a_position;
-uniform mat4 matrix;
+attribute vec4 color;
+attribute mat4 matrix;
+
+varying vec4 v_color;

void main() {
  // 위치에 행렬 곱하기
  gl_Position = matrix * a_position;

+  // 프래그먼트 셰이더로 정점 색상 전달
+  v_color = color;
}
&lt;/script&gt;
</code></pre>
<p>그리고</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;!-- 프래그먼트 셰이더 --&gt;
&lt;script id=&quot;fragment-shader-3d&quot; type=&quot;x-shader/x-fragment&quot;&gt;
precision mediump float;

-uniform vec4 color;
+// 정점 셰이더에서 전달됩니다.
+varying vec4 v_color;

void main() {
-  gl_FragColor = color;
+  gl_FragColor = v_color;
}
&lt;/script&gt;
</code></pre>
<p>속성은 정점 셰이더에서만 작동하므로 정점 셰이더의 속성에서 색상을 가져와서 베링을 통해 프래그먼트 셰이더로 전달해야 합니다.</p>
<p>다음으로 해당 속성의 위치를 찾아야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const program = webglUtils.createProgramFromScripts(gl, [&#39;vertex-shader-3d&#39;, &#39;fragment-shader-3d&#39;]);

const positionLoc = gl.getAttribLocation(program, &#39;a_position&#39;);
-const colorLoc = gl.getUniformLocation(program, &#39;color&#39;);
-const matrixLoc = gl.getUniformLocation(program, &#39;matrix&#39;);
+const colorLoc = gl.getAttribLocation(program, &#39;color&#39;);
+const matrixLoc = gl.getAttribLocation(program, &#39;matrix&#39;);
</code></pre>
<p>이제, 속성에 적용될 행렬을 넣을 버퍼가 필요합니다.
버퍼는 하나의 <em>chuck</em>에서 가장 잘 업데이트되기 때문에 모든 행렬을 동일한 <code class="notranslate" translate="no">Float32Array</code>에 넣을 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 인스턴스당 하나씩 행렬 설정
const numInstances = 5;
+// 행렬당 하나의 뷰로 형식화 배열 만들기
+const matrixData = new Float32Array(numInstances * 16);
</code></pre>
<p>그런 다음 각 행렬에 대해 하나씩, <code class="notranslate" translate="no">Float32Array</code> 뷰를 만들 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const matrices = [
-  m4.identity(),
-  m4.identity(),
-  m4.identity(),
-  m4.identity(),
-  m4.identity(),
-];
const matrices = [];
for (let i = 0; i &lt; numInstances; ++i) {
  const byteOffsetToMatrix = i * 16 * 4;
  const numFloatsForView = 16;
  matrices.push(
    new Float32Array(
      matrixData.buffer,
      byteOffsetToMatrix,
      numFloatsForView
    )
  );
}
</code></pre>
<p>이렇게 하면 모든 행렬에 대한 데이터를 참조하고 싶을 때 <code class="notranslate" translate="no">matrixData</code>를 사용할 수 있고, 어느 개별적인 행렬을 원한다면 <code class="notranslate" translate="no">matrices[ndx]</code>를 사용할 수 있습니다.</p>
<p>또한 이 데이터를 위해 GPU에 버퍼를 생성해야 합니다.
이 시점에서는 버퍼를 할당하기만 하면 되며, 데이터를 제공할 필요는 없으므로, <code class="notranslate" translate="no">gl.bufferData</code>에 대한 두 번째 매개변수는 버퍼를 할당하는 크기입니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const matrixBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, matrixBuffer);
// 버퍼 할당
gl.bufferData(gl.ARRAY_BUFFER, matrixData.byteLength, gl.DYNAMIC_DRAW);
</code></pre>
<p><code class="notranslate" translate="no">gl.DYNAMIC_DRAW</code>를 마지막 매개변수로 전달했음에 주목하세요.
이건 WebGL에 이 데이터가 자주 바뀔 것이라는 <em>hint</em>입니다.</p>
<p>다음으로 버퍼에도 색상이 필요합니다.
최소한 이 예제에서, 이 데이터는 바뀌지 않을 것이므로, 데이터를 업로드하기만 하면 됩니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const colors = [
-  [ 1, 0, 0, 1, ],  // 빨간색
-  [ 0, 1, 0, 1, ],  // 초록색
-  [ 0, 0, 1, 1, ],  // 파란색
-  [ 1, 0, 1, 1, ],  // 자주색
-  [ 0, 1, 1, 1, ],  // 청록색
-];
+// 인스턴스당 하나씩, 행렬 설정
+const colorBuffer = gl.createBuffer();
+gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
+gl.bufferData(gl.ARRAY_BUFFER,
+  new Float32Array([
+    1, 0, 0, 1,  // 빨간색
+    0, 1, 0, 1,  // 초록색
+    0, 0, 1, 1,  // 파란색
+    1, 0, 1, 1,  // 자주색
+    0, 1, 1, 1,  // 청록색
+  ]),
+  gl.STATIC_DRAW);
</code></pre>
<p>그릴 때 각 instance를 순환하는 대신, 행렬과 색상 uniform을 설정한 다음, 그리기를 호출하기 전에 각 instance에 대한 행렬을 먼저 계산할 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 모든 행렬 업데이트
matrices.forEach((mat, ndx) =&gt; {
  m4.translation(-0.5 + ndx * 0.25, 0, 0, mat);
  m4.zRotate(mat, time * (0.1 + 0.1 * ndx), mat);

-  const color = colors[ndx];
-
-  gl.uniform4fv(colorLoc, color);
-  gl.uniformMatrix4fv(matrixLoc, false, mat);
-
-  gl.drawArrays(
-    gl.TRIANGLES,
-    0,             // 오프셋
-    numVertices,   // 인스턴스당 정점 수
-  );
});
</code></pre>
<p>행렬 라이브러리가 선택적 대상 행렬을 사용하고, 행렬은 <code class="notranslate" translate="no">Float32Array</code> 뷰로 동일하게 더 큰 <code class="notranslate" translate="no">Float32Array</code>일 뿐이기 때문에, 완료되면 모든 행렬 데이터는 GPU에 직접 업로드할 준비가 끝납니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 새로운 행렬 데이터 업로드
gl.bindBuffer(gl.ARRAY_BUFFER, matrixBuffer);
gl.bufferSubData(gl.ARRAY_BUFFER, 0, matrixData);
</code></pre>
<p>이제 행렬과 색상에 대한 속성을 설정해야 합니다.
행렬 속성은 <code class="notranslate" translate="no">mat4</code>인데요.
<code class="notranslate" translate="no">mat4</code>는 실제로 4개의 속성 슬롯을 사용합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const bytesPerMatrix = 4 * 16;
for (let i = 0; i &lt; 4; ++i) {
  const loc = matrixLoc + i;
  gl.enableVertexAttribArray(loc);
  // 스트라이드와 오프셋에 유의
  const offset = i * 16;  // 행당 4float, float당 4byte
  gl.vertexAttribPointer(
    loc,              // 위치
    4,                // 크기 (반복마다 버퍼에서 가져오는 값의 개수)
    gl.FLOAT,         // 버퍼 데이터 타입
    false,            // 정규화
    bytesPerMatrix,   // 스트라이드, 다음 값 세트를 가져오기 위해 진행할 바이트 수
    offset,           // 버퍼 오프셋
  );
  // 이 줄은 각 1개의 인스턴스에 대해서만 속성이 변경됨을 나타냄
  ext.vertexAttribDivisorANGLE(loc, 1);
}
</code></pre>
<p>색인된 그리기와 관련하여 가장 중요한 점은 <code class="notranslate" translate="no">ext.vertexAttribDivisorANGLE</code>에 대한 호출입니다.
인스턴스당 한 번만 다음 값으로 진행하도록 이 속성을 설정하는데요.
이는 <code class="notranslate" translate="no">matrix</code> 속성이 첫 번째 인스턴스에 대한 모든 정점에 대해 첫 번째 행렬을, 두 번째 인스턴스에 대해 두 번째 행렬을 사용하는 식입니다.</p>
<p>색상 속성도 설정해야 하는데,</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 색상에 대한 속성 설정
gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
gl.enableVertexAttribArray(colorLoc);
gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0);
// 이 줄은 각 1개의 인스턴스에 대해서만 속성이 변경됨을 나타냄
ext.vertexAttribDivisorANGLE(colorLoc, 1);
</code></pre>
<p>이 두 속성을 사용하여 다른 걸 그리고 싶다면 약수를 기본값인 0으로 다시 설정하거나, <a href="webgl-attributes.html#vaos">정점 배열 객체</a>를 사용해야 합니다.</p>
<p>드디어 단일 그리기 호출로 모든 인스턴스를 그릴 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">ext.drawArraysInstancedANGLE(
  gl.TRIANGLES,
  0,             // 오프셋
  numVertices,   // 인스턴스당 정점 수
  numInstances,  // 인스턴스 수
);
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-instanced-drawing.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-instanced-drawing.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>위 예제는 도형당 3번의 WebGL 호출 * 5개의 도형으로 총 15번의 호출이 있었습니다.
하나는 행렬 업로드, 다른 하나는 그리기, 이제 5개의 도형에 대해 2번의 호출만 가집니다.
그리기 시작하기 위한 색상과 행렬에 대한 몇 가지 설정이 있습니다.
<a href="webgl-attributes.html#vaos">Vertex array object</a>를 사용하여 해당 설정을 렌더링 시점에서 초기화 시점으로 옮길 수 있습니다.</p>
<p>말할 필요도 없다고 느껴지지만 하긴 저는 너무 많이 했기 때문에 당연한 것일 수도 있습니다.
위 코드는 캔버스적인 측면을 고려하지 않았는데요.
<a href="webgl-3d-orthographic.html">투영 행렬</a>이나 <a href="webgl-3d-camera.html">뷰 행렬</a>을 사용하지 않습니다.
오로지 색인된 그리기를 보여주기 위한 것입니다.
투영 행렬이나 뷰 행렬을 원한다면 자바스크립트에 계산을 추가할 수 있습니다.
이는 자바스크립트의 작업이 더 많아짐을 의미합니다.
좀 더 확실한 방법은 1개 혹은 2개 이상의 유니폼을 정점 셰이더에 추가하는 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;!-- 정점 셰이더 --&gt;
&lt;script id=&quot;vertex-shader-3d&quot; type=&quot;x-shader/x-vertex&quot;&gt;
attribute vec4 a_position;
attribute vec4 color;
attribute mat4 matrix;
+uniform mat4 projection;
+uniform mat4 view;

varying vec4 v_color;

void main() {
  // 위치에 행렬 곱하기
-  gl_Position = matrix * a_position;
+  gl_Position = projection * view * matrix * a_position;

  // 프래그먼트 셰이더로 정점 색상 전달
  v_color = color;
}
&lt;/script&gt;
</code></pre>
<p>그런 다음 초기화할 때 위치를 찾고,</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const positionLoc = gl.getAttribLocation(program, &#39;a_position&#39;);
const colorLoc = gl.getAttribLocation(program, &#39;color&#39;);
const matrixLoc = gl.getAttribLocation(program, &#39;matrix&#39;);
+const projectionLoc = gl.getUniformLocation(program, &#39;projection&#39;);
+const viewLoc = gl.getUniformLocation(program, &#39;view&#39;);
</code></pre>
<p>렌더링할 때 적절하게 설정합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.useProgram(program);

+// 모든 인스턴스에 공유되므로 뷰와 투영 행렬 설정
+const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
+gl.uniformMatrix4fv(projectionLoc, false, m4.orthographic(-aspect, aspect, -1, 1, -1, 1));
+gl.uniformMatrix4fv(viewLoc, false, m4.zRotation(time * .1));
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-instanced-drawing-projection-view.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-instanced-drawing-projection-view.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-instanced-drawing.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-instanced-drawing.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-instanced-drawing.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-instanced-drawing.html" selected>한국어</a>
    <option value="/webgl/lessons/pl/webgl-instanced-drawing.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-instanced-drawing.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-instanced-drawing.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-instanced-drawing.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>기초</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-fundamentals.html">기초</a></li>
<li><a href="/webgl/lessons/ko/webgl-how-it-works.html">작동 방식</a></li>
<li><a href="/webgl/lessons/ko/webgl-shaders-and-glsl.html">셰이더와 GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL 상태 다이어그램</a></li>
        </ul>
  <li>이미지 처리</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-image-processing.html">이미지 처리</a></li>
<li><a href="/webgl/lessons/ko/webgl-image-processing-continued.html">이미지 처리 심화</a></li>
        </ul>
  <li>2D 평행 이동, 회전, 스케일, 행렬 수학</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-translation.html">2D 평행 이동</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-rotation.html">2D 회전</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-scale.html">2D 스케일</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrices.html">2D 행렬</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-orthographic.html">3D 직교 투영</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective.html">3D 원근 투영</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-camera.html">3D 카메라</a></li>
        </ul>
  <li>조명</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-lighting-directional.html">방향성 조명</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-point.html">점 조명</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-spot.html">스포트라이트</a></li>
        </ul>
  <li>구조와 구성</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-less-code-more-fun.html">유틸리티 함수</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-multiple-things.html">여러 물체 그리기</a></li>
<li><a href="/webgl/lessons/ko/webgl-scene-graph.html">장면 그래프</a></li>
        </ul>
  <li>지오메트리</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-geometry-lathe.html">지오메트리 - 선반 가공</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj.html">.obj 파일 로딩</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj-w-mtl.html">.mtl 파일로 .obj 로딩</a></li>
        </ul>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-textures.html">텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-data-textures.html">데이터 텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-2-textures.html">2개 이상의 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-cors-permission.html">교차 출처 이미지</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective-correct-texturemapping.html">원근 교정 텍스처 매핑</a></li>
<li><a href="/webgl/lessons/ko/webgl-planar-projection-mapping.html">평면 및 원근 투영 매핑</a></li>
        </ul>
  <li>텍스처 렌더링</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-render-to-texture.html">텍스처 렌더링</a></li>
        </ul>
  <li>그림자</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-shadows.html">그림자</a></li>
        </ul>
  <li>기법</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrix-stack.html">2D - 행렬 스택</a></li>
<li><a href="/webgl/lessons/ko/webgl-sprites.html">스프라이트</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-cube-maps.html">큐브맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-environment-maps.html">환경맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-skybox.html">스카이박스</a></li>
<li><a href="/webgl/lessons/ko/webgl-skinning.html">스키닝</a></li>
<li><a href="/webgl/lessons/ko/webgl-fog.html">안개</a></li>
<li><a href="/webgl/lessons/ko/webgl-picking.html">피킹 (물체 클릭)</a></li>
        </ul>
  <li>텍스트</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-text-html.html">텍스트 - HTML</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-canvas2d.html">텍스트 - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-texture.html">텍스트 - 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-glyphs.html">텍스트 - 글리프 텍스처 사용</a></li>
        </ul>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-ramp-textures.html">램프 텍스처 (툰 셰이딩)</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>팁</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-smallest-programs.html">최소 프로그램</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-without-data.html">데이터 없이 그리기</a></li>
<li><a href="/webgl/lessons/ko/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ko/webgl-pulling-vertices.html">정점 풀링</a></li>
        </ul>
  <li>최적화</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-indexed-vertices.html">색인된 정점 (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ko/webgl-instanced-drawing.html">색인된 그리기</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-setup-and-installation.html">설정 및 설치</a></li>
<li><a href="/webgl/lessons/ko/webgl-boilerplate.html">상용구</a></li>
<li><a href="/webgl/lessons/ko/webgl-resizing-the-canvas.html">캔버스 크기 조정</a></li>
<li><a href="/webgl/lessons/ko/webgl-animation.html">애니메이션</a></li>
<li><a href="/webgl/lessons/ko/webgl-points-lines-triangles.html">점, 선, 삼각형</a></li>
<li><a href="/webgl/lessons/ko/webgl-multiple-views.html">다중 뷰, 다중 캔버스</a></li>
<li><a href="/webgl/lessons/ko/webgl-visualizing-the-camera.html">카메라 시각화</a></li>
<li><a href="/webgl/lessons/ko/webgl-and-alpha.html">WebGL 알파</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-vs-3d-library.html">2D vs 3D 라이브러리</a></li>
<li><a href="/webgl/lessons/ko/webgl-anti-patterns.html">안티 패턴</a></li>
<li><a href="/webgl/lessons/ko/webgl-matrix-vs-math.html">WebGL 행렬 vs 수학 행렬</a></li>
<li><a href="/webgl/lessons/ko/webgl-precision-issues.html">정밀도 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#screenshot">스크린샷 찍기</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#preservedrawingbuffer">캔버스 지우기 방지</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#tabindex">캔버스 키보드 입력</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#html-background">WebGL 배경 제작</a></li>
<li><a href="/webgl/lessons/ko/webgl-cross-platform-issues.html">크로스 플랫폼 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-qna.html">질문 및 답변</a></li>
        </ul>
  <li>참고</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-attributes.html">속성</a></li>
<li><a href="/webgl/lessons/ko/webgl-texture-units.html">텍스처 유닛</a></li>
<li><a href="/webgl/lessons/ko/webgl-framebuffers.html">프레임 버퍼</a></li>
<li><a href="/webgl/lessons/ko/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ko/webgl-references.html">참고 자료</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">도우미 API 문서</a></li>
  <li><a href="https://twgljs.org">TWGL, 가벼운 WebGL 라이브러리</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Github</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
    <div>이슈/버그는? <a href="https://github.com/gfxfundamentals/webgl-fundamentals/issues">Github</a>에 이슈를 만들어주세요.</div>
    <div class="lesson-comment-notes">
      코드 블록은 <b>&lt;pre&gt;&lt;code&gt;</b>여기에 코드 입력<b>&lt;/code&gt;&lt;/pre&gt;</b>를 사용해주세요
    </div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL 최적화 - 색인된 그리기';
            var disqus_title = 'WebGL 최적화 - 색인된 그리기';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>



