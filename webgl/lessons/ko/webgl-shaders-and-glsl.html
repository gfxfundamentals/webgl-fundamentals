<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ko/webgl-shaders-and-glsl.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Shader는 뭐고 GLSL은 뭘까?">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-shaders-and-glsl_ko.jpg">

<meta property="og:title" content="WebGL Shader 그리고 GLSL">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-shaders-and-glsl_ko.jpg">
<meta property="og:description" content="Shader는 뭐고 GLSL은 뭘까?">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/ko/webgl-shaders-and-glsl.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGL Shader 그리고 GLSL">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/ko/webgl-shaders-and-glsl.html">
<meta name="twitter:description" content="Shader는 뭐고 GLSL은 뭘까?">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-shaders-and-glsl_ko.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-shaders-and-glsl.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-shaders-and-glsl_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-shaders-and-glsl.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/ko/webgl-shaders-and-glsl.html",
      "inLanguage":"ko",
      "name":"WebGL Shader 그리고 GLSL",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-shaders-and-glsl.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL Shader 그리고 GLSL</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/ko/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-shaders-and-glsl.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-shaders-and-glsl.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-shaders-and-glsl.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-shaders-and-glsl.html" selected>한국어</a>
    <option value="/webgl/lessons/pl/webgl-shaders-and-glsl.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-shaders-and-glsl.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-shaders-and-glsl.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html" >简体中文</a>
</select>


    <a href="#toc">목차</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ko/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub a {
    background: #000;
    color: #fff;
    text-decoration: none;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 2rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 300px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(150px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a:hover {
    background: #c11;
    color: #fff;
}
#forkongithub a::before,#forkongithub a::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub a::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
@media (max-width: 900px) {
    #forkongithub a{
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub a{
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL Shader 그리고 GLSL</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>이 글은 <a href="webgl-fundamentals.html">WebGL 기초</a>에서 이어집니다.
<a href="webgl-how-it-works.html">WebGL 작동 원리</a>를 읽지 않았다면 먼저 읽어보는 게 좋습니다.</p>
<p>shader와 GLSL에 대해 언급했지만 실제로 구체적인 세부 사항은 다루지 않았는데요.
예제로 충분하셨길 바라지만 혹시 모르니 좀 더 명확하게 해봅시다.</p>
<p><a href="webgl-how-it-works.html">작동 원리</a>에서 언급했듯이 WebGL은 뭔가를 그릴 때마다 2개의 shader를 필요로 하는데요.
<em>vertex shader</em>와 <em>fragment shader</em>입니다.
각각의 shader는 <em>함수</em>인데요.
vertex shader와 fragment shader는 함께 shader program(또는 그냥 program)으로 연결됩니다.
일반적인 WebGL 앱은 많은 shader program을 가집니다.</p>
<h2 id="vertex-shader">Vertex Shader</h2>
<p>Vertex Shader의 역할은 clip 공간 좌표를 생성하는 겁니다.
항상 이런 형식을 취하는데</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">void main() {
  gl_Position = doMathToMakeClipspaceCoordinates
}
</code></pre><p>shader는 vertex마다 한 번씩 호출되는데요.
호출될 때마다 특수 전역 변수, <code class="notranslate" translate="no">gl_Position</code>을 일부 clip 공간 좌표로 설정해야 합니다.</p>
<p>vertex shader는 데이터가 필요한데요.
3가지 방법으로 데이터를 얻을 수 있습니다.</p>
<ol>
<li><a href="#attribute">Attributes</a> (buffer에서 가져온 데이터)</li>
<li><a href="#uniform">Uniforms</a> (단일 그리기 호출의 모든 vertex에 대해 동일하게 유지하는 값)</li>
<li><a href="#vertex-shader의-texture">Textures</a> (pixel/texel의 데이터)</li>
</ol>
<h3 id="attribute">Attribute</h3>
<p>가장 일반적인 방법은 buffer와 <em>attribute</em>를 통하여 하는 겁니다.
<a href="webgl-how-it-works.html">작동 원리</a>에서 buffer와 attribute를 다뤘는데요.
buffer를 만들고,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var buf = gl.createBuffer();
</code></pre><p>이 buffer에 데이터를 넣고</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, someData, gl.STATIC_DRAW);
</code></pre><p>그런 다음, 만든 shader program을 통해 초기화 시 attribute의 위치를 찾고</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var positionLoc = gl.getAttribLocation(someShaderProgram, &quot;a_position&quot;);
</code></pre><p>그리고 렌더링할 때 WebGL에게 해당 buffer에서 attribute로 데이터를 어떻게 가져올지 지시하고</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 이 attribute에 대한 buffer에서 데이터 가져오기 활성화
gl.enableVertexAttribArray(positionLoc);

var numComponents = 3;  // (x, y, z)
var type = gl.FLOAT;    // 32bit 부동 소수점 값
var normalize = false;  // 값 원본 그대로 유지
var offset = 0;         // buffer의 처음부터 시작
var stride = 0;         // 다음 vertex로 가기 위해 이동하는 byte 수
                        // 0 = type과 numComponents에 맞는 stride 사용 
gl.vertexAttribPointer(
    positionLoc,
    numComponents,
    type,
    false,
    stride,
    offset
);
</code></pre><p><a href="webgl-fundamentals.html">WebGL 기초</a>에서 우리는 shader에서 수식없이 직접 데이터를 전달할 수 있다는 것을 봤습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">attribute vec4 a_position;

void main() {
  gl_Position = a_position;
}
</code></pre><p>buffer에 clip 공간 vertex를 넣으면 동작할 겁니다. </p>
<p>attribute는 type으로 <code class="notranslate" translate="no">float</code>, <code class="notranslate" translate="no">vec2</code>, <code class="notranslate" translate="no">vec3</code>, <code class="notranslate" translate="no">vec4</code>, <code class="notranslate" translate="no">mat2</code>, <code class="notranslate" translate="no">mat3</code>, 그리고 <code class="notranslate" translate="no">mat4</code>를 사용할 수 있습니다.</p>
<h3 id="uniform">Uniform</h3>
<p>shader uniform은 그리기 호출의 모든 vertex에 대해 똑같이 유지되며 shader에게 전달되는 값입니다.
간단한 예로 위 vertex shader에 offset을 추가할 수 있는데</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">attribute vec4 a_position;
+uniform vec4 u_offset;

void main() {
  gl_Position = a_position + u_offset;
}
</code></pre><p>그리고 이제 모든 vertex를 일정량만큼 offset 할 수 있습니다.
먼저 초기화 시 uniform의 위치를 찾아야 하는데</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var offsetLoc = gl.getUniformLocation(someProgram, &quot;u_offset&quot;);
</code></pre><p>그런 다음 그리기 전에 uniform을 설정하면</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.uniform4fv(offsetLoc, [1, 0, 0, 0]);  // 화면 우측 절반으로 offset
</code></pre><p>참고로 uniform은 개별 shader program에 속합니다.
만약 이름이 같은 uniform을 가진 shader program이 여러 개 있다면 두 uniform 모두 고유한 위치와 값을 가지는데요.
<code class="notranslate" translate="no">gl.uniform???</code>을 호출하면 <em>현재 program</em>의 uniform만 설정합니다.
현재 program은 <code class="notranslate" translate="no">gl.useProgram</code>에 전달한 마지막 program 입니다.</p>
<p>uniform은 여러 type을 가질 수 있는데요.
각 type마다 설정을 위해 해당하는 함수를 호출해야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.uniform1f (floatUniformLoc, v);                 // float
gl.uniform1fv(floatUniformLoc, [v]);               // float 또는 float 배열
gl.uniform2f (vec2UniformLoc, v0, v1);             // vec2
gl.uniform2fv(vec2UniformLoc, [v0, v1]);           // vec2 또는 vec2 배열
gl.uniform3f (vec3UniformLoc, v0, v1, v2);         // vec3
gl.uniform3fv(vec3UniformLoc, [v0, v1, v2]);       // vec3 또는 vec3 배열
gl.uniform4f (vec4UniformLoc, v0, v1, v2, v4);     // vec4
gl.uniform4fv(vec4UniformLoc, [v0, v1, v2, v4]);   // vec4 또는 vec4 배열

gl.uniformMatrix2fv(mat2UniformLoc, false, [  4x element array ])  // mat2 또는 mat2 배열
gl.uniformMatrix3fv(mat3UniformLoc, false, [  9x element array ])  // mat3 또는 mat3 배열
gl.uniformMatrix4fv(mat4UniformLoc, false, [ 16x element array ])  // mat4 또는 mat4 배열

gl.uniform1i (intUniformLoc, v);                   // int
gl.uniform1iv(intUniformLoc, [v]);                 // int 또는 int 배열
gl.uniform2i (ivec2UniformLoc, v0, v1);            // ivec2
gl.uniform2iv(ivec2UniformLoc, [v0, v1]);          // ivec2 또는 ivec2 배열
gl.uniform3i (ivec3UniformLoc, v0, v1, v2);        // ivec3
gl.uniform3iv(ivec3UniformLoc, [v0, v1, v2]);      // ivec3 또는 ivec3 배열
gl.uniform4i (ivec4UniformLoc, v0, v1, v2, v4);    // ivec4
gl.uniform4iv(ivec4UniformLoc, [v0, v1, v2, v4]);  // ivec4 또는 ivec4 배열

gl.uniform1i (sampler2DUniformLoc, v);             // sampler2D (texture)
gl.uniform1iv(sampler2DUniformLoc, [v]);           // sampler2D 또는 sampler2D 배열

gl.uniform1i (samplerCubeUniformLoc, v);           // samplerCube (texture)
gl.uniform1iv(samplerCubeUniformLoc, [v]);         // samplerCube 또는 samplerCube 배열
</code></pre><p><code class="notranslate" translate="no">bool</code>, <code class="notranslate" translate="no">bvec2</code>, <code class="notranslate" translate="no">bvec3</code>, 그리고 <code class="notranslate" translate="no">bvec4</code> type도 있는데요.
<code class="notranslate" translate="no">gl.uniform?f?</code> 또는 <code class="notranslate" translate="no">gl.uniform?i?</code> 함수를 사용합니다.</p>
<p>배열의 경우 배열의 모든 uniform을 한번에 설정할 수 있습니다.
예를들어</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// shader
uniform vec2 u_someVec2[3];

// 초기화 시 JavaScript
var someVec2Loc = gl.getUniformLocation(someProgram, &quot;u_someVec2&quot;);

// 렌더링할 때
gl.uniform2fv(someVec2Loc, [1, 2, 3, 4, 5, 6]);  // u_someVec2의 전체 배열 설정
</code></pre><p>하지만 배열의 개별 요소를 설정하고 싶다면 각 요소의 위치를 개별적으로 찾아야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 초기화 시 JavaScript
var someVec2Element0Loc = gl.getUniformLocation(someProgram, &quot;u_someVec2[0]&quot;);
var someVec2Element1Loc = gl.getUniformLocation(someProgram, &quot;u_someVec2[1]&quot;);
var someVec2Element2Loc = gl.getUniformLocation(someProgram, &quot;u_someVec2[2]&quot;);

// 렌더링할 때
gl.uniform2fv(someVec2Element0Loc, [1, 2]);  // 요소 0 설정
gl.uniform2fv(someVec2Element1Loc, [3, 4]);  // 요소 1 설정
gl.uniform2fv(someVec2Element2Loc, [5, 6]);  // 요소 2 설정
</code></pre><p>마찬가지로 struct를 생성하면</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">struct SomeStruct {
  bool active;
  vec2 someVec2;
};
uniform SomeStruct u_someThing;
</code></pre><p>각 field를 개별적으로 찾아야 하는데</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var someThingActiveLoc = gl.getUniformLocation(someProgram, &quot;u_someThing.active&quot;);
var someThingSomeVec2Loc = gl.getUniformLocation(someProgram, &quot;u_someThing.someVec2&quot;);
</code></pre><h3 id="vertex-shader-texture">Vertex Shader의 Texture</h3>
<p><a href="#fragment-shader의-texture">Fragment Shader의 Texture</a>를 봐주세요.</p>
<h2 id="fragment-shader">Fragment Shader</h2>
<p>Fragment Shader의 역할은 rasterize 되는 현재 픽셀의 색상을 제공하는 것입니다.
항상 이런 형식을 취하는데</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">precision mediump float;

void main() {
  gl_FragColor = doMathToMakeAColor;
}
</code></pre><p>fragment shader는 각 픽셀마다 한 번씩 호출되는데요.
호출될 때마다 특수 전역 변수, <code class="notranslate" translate="no">gl_FragColor</code>를 어떤 색상으로 설정해줘야 합니다.</p>
<p>fragment shader는 데이터가 필요한데요.
3가지 방법으로 데이터를 얻을 수 있습니다.</p>
<ol>
<li><a href="#uniform">Uniforms</a> (단일 그리기 호출의 모든 vertex에 대해 동일하게 유지하는 값)</li>
<li><a href="#fragment-shader의-texture">Textures</a> (pixel/texel의 데이터)</li>
<li><a href="#varying">Varyings</a> (vertex shader에서 전달되고 보간된 데이터)</li>
</ol>
<h3 id="fragment-shader-uniform">Fragment Shader의 Uniform</h3>
<p><a href="#uniform">Shader의 Uniform</a>을 봐주세요.</p>
<h3 id="fragment-shader-texture">Fragment Shader의 Texture</h3>
<p>shader의 texture에서 값을 가져오면 <code class="notranslate" translate="no">sampler2D</code> uniform을 생성하고 값을 추출하기 위해 GLSL 함수 <code class="notranslate" translate="no">texture2D</code>를 사용합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">precision mediump float;

uniform sampler2D u_texture;

void main() {
  vec2 texcoord = vec2(0.5, 0.5)  // texture 중간에서 값 가져오기
  gl_FragColor = texture2D(u_texture, texcoord);
}
</code></pre><p>texture에서 나오는 데이터는 <a href="webgl-3d-textures.html">수많은 설정에 따라</a> 달라집니다.
최소한 texture의 데이터를 생성하고 넣어야 하는데, 예를들어</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var tex = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, tex);
var level = 0;
var width = 2;
var height = 1;
var data = new Uint8Array([
  255, 0, 0, 255,   // 빨강 pixel
  0, 255, 0, 255,   // 초록 pixel
]);
gl.texImage2D(
    gl.TEXTURE_2D,
    level,
    gl.RGBA,
    width,
    height,
    0,
    gl.RGBA,
    gl.UNSIGNED_BYTE,
    data
);
</code></pre><p>초기화 시 shader program의 uniform 위치를 찾고</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var someSamplerLoc = gl.getUniformLocation(someProgram, &quot;u_texture&quot;);
</code></pre><p>렌더링할 때 texture unit에 texture를 할당하며</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var unit = 5;  // texture unit 선택
gl.activeTexture(gl.TEXTURE0 + unit);
gl.bindTexture(gl.TEXTURE_2D, tex);
</code></pre><p>그리고 texture를 할당한 unit을 shader에게 알려주는데</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.uniform1i(someSamplerLoc, unit);
</code></pre><h3 id="varying">Varying</h3>
<p>varying은 <a href="webgl-how-it-works.html">동작 원리</a>에 다룬 vertex shader에서 fragment shader로 값을 전달하는 방법입니다.</p>
<p>varying을 사용하려면 vertex와 fragment shader 양쪽에 일치하는 varying을 선언해야 하는데요.
각 vertex마다 vertex shader의 varying을 어떤 값으로 설정해줍니다.
WebGL이 픽셀을 그릴 때 이 값들 사이를 보간하고 fragment shader에서 대응하는 varying으로 전달할 겁니다.</p>
<p>vertex shader</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">attribute vec4 a_position;

uniform vec4 u_offset;

+varying vec4 v_positionWithOffset;

void main() {
  gl_Position = a_position + u_offset;
+  v_positionWithOffset = a_position + u_offset;
}
</code></pre><p>fragment shader</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">precision mediump float;

+varying vec4 v_positionWithOffset;

void main() {
+  // clip 공간에서 (-1 &lt;-&gt; +1) 색상 공간으로 (0 -&gt; 1) 변환
+  vec4 color = v_positionWithOffset * 0.5 + 0.5
+  gl_FragColor = color;
}
</code></pre><p>위 예제는 대부분 말도 안되는 예제입니다.
일반적으로는 clip 공간 값을 fragment shader에 직접 복사해서 색상으로 사용하지 않는데요.
그럼에도 불구하고 작동하며 색상을 만들어냅니다.</p>
<h2 id="glsl">GLSL</h2>
<p>GLSL는 Graphics Library Shader Language의 약자인데요.
shader가 작성되는 언어입니다.
이건 JavaScript에서 흔하지 않은 특별한 준 고유 기능을 가지고 있는데요.
그래픽을 rasterize 하기 위한 계산을 하는데 일반적으로 필요한 수학적 계산을 하도록 설계되었습니다.
예를들어 각각 2개의 값, 3개의 값, 그리고 4개의 값을 나타내는 <code class="notranslate" translate="no">vec2</code>, <code class="notranslate" translate="no">vec3</code>, 그리고 <code class="notranslate" translate="no">vec4</code> 같은 type들이 내장되어 있습니다.
마찬가지로 2x2, 3x3, 그리고 4x4 행렬을 나타내는 <code class="notranslate" translate="no">mat2</code>, <code class="notranslate" translate="no">mat3</code> 그리고 <code class="notranslate" translate="no">mat4</code>가 있는데요.
<code class="notranslate" translate="no">vec</code>에 scalar를 곱하는 것 같은 작업을 수행할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 a = vec4(1, 2, 3, 4);
vec4 b = a * 2.0;
// 현재 b는 vec4(2, 4, 6, 8);
</code></pre><p>마찬가지로 행렬 곱셈과 벡터 대 행렬 곱셈을 할 수 있는데</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">mat4 a = ???
mat4 b = ???
mat4 c = a * b;

vec4 v = ???
vec4 y = c * v;
</code></pre><p>또한 vec의 부분에 대한 다양한 선택자가 있습니다.
vec4를 보면</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 v;
</code></pre><ul>
<li><code class="notranslate" translate="no">v.x</code>는 <code class="notranslate" translate="no">v.s</code>와 <code class="notranslate" translate="no">v.r</code>과 <code class="notranslate" translate="no">v[0]</code>과 같습니다.</li>
<li><code class="notranslate" translate="no">v.y</code>는 <code class="notranslate" translate="no">v.t</code>와 <code class="notranslate" translate="no">v.g</code>와 <code class="notranslate" translate="no">v[1]</code>과 같습니다.</li>
<li><code class="notranslate" translate="no">v.z</code>는 <code class="notranslate" translate="no">v.p</code>와 <code class="notranslate" translate="no">v.b</code>와 <code class="notranslate" translate="no">v[2]</code>와 같습니다.</li>
<li><code class="notranslate" translate="no">v.w</code>는 <code class="notranslate" translate="no">v.q</code>와 <code class="notranslate" translate="no">v.a</code>와 <code class="notranslate" translate="no">v[3]</code>과 같습니다.</li>
</ul>
<p>vec 구성 요소들을 <em>swizzle</em> 할 수 있는데 이는 구성 요소를 교환하거나 반복할 수 있다는 걸 뜻합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">v.yyyy
</code></pre><p>이건 다음과 같고</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4(v.y, v.y, v.y, v.y)
</code></pre><p>마찬가지로</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">v.bgra
</code></pre><p>이건 다음과 같으며</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4(v.b, v.g, v.r, v.a)
</code></pre><p>vec 또는 mat을 만들 때 한 번에 여러 부분을 공급할 수 있습니다. 예를들면</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4(v.rgb, 1)
</code></pre><p>이건 다음과 같고</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4(v.r, v.g, v.b, 1)
</code></pre><p>또한</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4(1)
</code></pre><p>이건 다음과 같은데</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4(1, 1, 1, 1)
</code></pre><p>한 가지 주의해야할 점은 GLSL의 type이 매우 엄격하다는 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">float f = 1;  // ERROR 1은 int입니다. float에는 int를 할당할 수 없습니다.
</code></pre><p>올바른 방법은 다음 중 하나인데</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">float f = 1.0;      // float 사용
float f = float(1)  // integer를 float로 cast
</code></pre><p>위 예제의 <code class="notranslate" translate="no">vec4(v.rgb, 1)</code>는 <code class="notranslate" translate="no">vec4</code>가 내부에서 <code class="notranslate" translate="no">float(1)</code>처럼 cast하기 때문에 <code class="notranslate" translate="no">1</code>에 대해 문제가 발생하지 않습니다.</p>
<p>GLSL은 많은 내장 함수들을 가지고 있는데요.
대부분은 여러 구성요소에서 한 번에 작동합니다.
예를 들어</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">T sin(T angle)
</code></pre><p>T는 <code class="notranslate" translate="no">float</code>, <code class="notranslate" translate="no">vec2</code>, <code class="notranslate" translate="no">vec3</code> 또는 <code class="notranslate" translate="no">vec4</code>가 될 수 있음을 뜻합니다.
만약 <code class="notranslate" translate="no">vec4</code>를 전달하면 각 구성요소의 sine인 <code class="notranslate" translate="no">vec4</code>를 돌려받습니다.
다시 말해 <code class="notranslate" translate="no">v</code>가 <code class="notranslate" translate="no">vec4</code>라면</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 s = sin(v);
</code></pre><p>이건 다음과 같고</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 s = vec4(sin(v.x), sin(v.y), sin(v.z), sin(v.w));
</code></pre><p>가끔은 한 매개변수가 부동 소수점이고 나머지는 <code class="notranslate" translate="no">T</code>가 됩니다.
이는 모든 구성요소에 부동 소수점이 적용된다는 걸 뜻하는데요.
예를들어 <code class="notranslate" translate="no">v1</code>과 <code class="notranslate" translate="no">v2</code>가 <code class="notranslate" translate="no">vec4</code>이고 <code class="notranslate" translate="no">f</code>는 부동 소수점이라면</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 m = mix(v1, v2, f);
</code></pre><p>이건 다음과 같으며</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 m = vec4(
    mix(v1.x, v2.x, f),
    mix(v1.y, v2.y, f),
    mix(v1.z, v2.z, f),
    mix(v1.w, v2.w, f)
);
</code></pre><p><a href="https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf">WebGL Reference Card</a>의 마지막 페이지에서 모든 GLSL 함수 목록을 볼 수 있습니다.
만약 정말 무미건조하고 장황한 것을 좋아한다면 <a href="https://www.khronos.org/files/opengles_shading_language.pdf">GLSL 사양</a>에 도전해볼 수 있습니다.</p>
<h2 id="-">총정리</h2>
<p>이게 바로 이 모든 글들의 핵심입니다.
WebGL은 다양한 shader를 생성하고, 데이터를 이 shader에 공급한 뒤 <code class="notranslate" translate="no">gl.drawArrays</code> 또는 <code class="notranslate" translate="no">gl.drawElements</code>를 호출하여 WebGL이 vertex를 처리하도록 각 vertex에 대한 현재 vertex shader를 호출한 뒤 각 픽셀에 대한 현재 fragment shader를 호출하여 픽셀을 렌더링하는 것에 대한 모든 겁니다.</p>
<p>실제로 shader를 생성하려면 여러 줄의 코드가 필요합니다.
이 코드들은 대부분의 WebGL program에서 똑같기 때문에 한 번 작성한 후에는 거의 생략할 수 있습니다.
GLSL shader를 컴파일하고 shader program에 연결하는 방법은 <a href="webgl-boilerplate.html">여기</a>에서 다룹니다.</p>
<p>여기서 막 시작했다면 두 가지 방향으로 갈 수 있는데요.
이미지 처리에 관심있다면 <a href="webgl-image-processing.html">2D 이미지 처리 방법</a>을 알려드리겠습니다.
이동, 회전, 크기 조정 그리고 최종적으로 3D를 공부하는데 관심있다면 <a href="webgl-2d-translation.html">여기</a>에서 시작해주세요.</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-shaders-and-glsl.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-shaders-and-glsl.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-shaders-and-glsl.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-shaders-and-glsl.html" selected>한국어</a>
    <option value="/webgl/lessons/pl/webgl-shaders-and-glsl.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-shaders-and-glsl.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-shaders-and-glsl.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>기초</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-fundamentals.html">기초</a></li>
<li><a href="/webgl/lessons/ko/webgl-how-it-works.html">작동 원리</a></li>
<li><a href="/webgl/lessons/ko/webgl-shaders-and-glsl.html">Shader 그리고 GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL 상태 다이어그램</a></li>
        </ul>
  <li>이미지 처리</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-image-processing.html">WebGL 이미지 처리</a></li>
<li><a href="/webgl/lessons/ko/webgl-image-processing-continued.html">WebGL 이미지 처리 심화</a></li>
        </ul>
  <li>2D 이동, 회전, 크기 조정, 행렬 수학</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-translation.html">WebGL 2D 이동</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-rotation.html">WebGL 2D 회전</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-scale.html">WebGL 2D 크기</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrices.html">WebGL 2D 행렬</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-orthographic.html">WebGL - Orthographic 3D</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective.html">3D Perspective</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-camera.html">3D Cameras</a></li>
        </ul>
  <li>조명</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>구조 및 조직</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-multiple-things.html">Drawing Multiple Things</a></li>
<li><a href="/webgl/lessons/ko/webgl-scene-graph.html">Scene Graphs</a></li>
        </ul>
  <li>기하학</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-geometry-lathe.html">Geometry - Lathe</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj.html">Loading .obj files</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-textures.html">Textures</a></li>
<li><a href="/webgl/lessons/ko/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/ko/webgl-2-textures.html">Using 2 or More Textures</a></li>
<li><a href="/webgl/lessons/ko/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective-correct-texturemapping.html">Perspective Correct Texture Mapping</a></li>
<li><a href="/webgl/lessons/ko/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>텍스처로 렌더링</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-render-to-texture.html">Render to Texture</a></li>
        </ul>
  <li>그림자</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>기법</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrix-stack.html">2D - Matrix Stack</a></li>
<li><a href="/webgl/lessons/ko/webgl-sprites.html">Sprites</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/ko/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/ko/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/ko/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/ko/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ko/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>글자</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-text-html.html">Text - HTML</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-canvas2d.html">Text - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-texture.html">Text - Using a Texture</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-ramp-textures.html">Ramp Textures (Toon Shading)</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>팁</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/ko/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ko/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>최적화</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ko/webgl-instanced-drawing.html">Instanced Drawing</a></li>
        </ul>
  <li>기타</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-setup-and-installation.html">WebGL 설치</a></li>
<li><a href="/webgl/lessons/ko/webgl-boilerplate.html">WebGL Boilerplate</a></li>
<li><a href="/webgl/lessons/ko/webgl-resizing-the-canvas.html">WebGL Canvas 크기 조정</a></li>
<li><a href="/webgl/lessons/ko/webgl-animation.html">Animation</a></li>
<li><a href="/webgl/lessons/ko/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/ko/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/ko/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/ko/webgl-and-alpha.html">WebGL and Alpha</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/ko/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/ko/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/ko/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#html-background">Use WebGL as Background in HTML</a></li>
<li><a href="/webgl/lessons/ko/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/ko/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>참고</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/ko/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/ko/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/ko/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ko/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">도우미 API 문서</a></li>
  <li><a href="https://twgljs.org">TWGL, 가벼운 WebGL 라이브러리</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">github</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
    <div>질문은? <a href="https://stackoverflow.com/questions/tagged/webgl">Stackoverflow</a>에서 물어봐주세요.</div>
    <div>이슈/버그는? <a href="https://github.com/gfxfundamentals/webgl-fundamentals/issues">Github</a>에 이슈를 만들어주세요.</div>
    <div class="lesson-comment-notes">
      코드 블록은 <b>&lt;pre&gt;&lt;code&gt;</b>여기에 코드 입력<b>&lt;/code&gt;&lt;/pre&gt;</b>를 사용해주세요
    </div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL Shader 그리고 GLSL';
            var disqus_title = 'WebGL Shader 그리고 GLSL';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
      return;
  }

  function addScript(src, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  addScript('//cdn.webglstats.com/stat.js');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>



