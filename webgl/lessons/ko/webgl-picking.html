<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ko/webgl-picking.md. Do not edited directly -->
<!--
Copyright 2021 GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="WebGL에서 항목을 선택하는 방법">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-picking_ko.jpg">

<meta property="og:title" content="WebGL 피킹">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-picking_ko.jpg">
<meta property="og:description" content="WebGL에서 항목을 선택하는 방법">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/ko/webgl-picking.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGL 피킹">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/ko/webgl-picking.html">
<meta name="twitter:description" content="WebGL에서 항목을 선택하는 방법">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-picking_ko.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-picking.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-picking_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-picking.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/ko/webgl-picking.html",
      "inLanguage":"ko",
      "name":"WebGL 피킹",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-picking.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL 피킹</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/ko/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-picking.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-picking.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-picking.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-picking.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-picking.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-picking.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-picking.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-picking.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-picking.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-picking.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-picking.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-picking.html" selected>한국어</a>
    <option value="/webgl/lessons/pl/webgl-picking.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-picking.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-picking.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-picking.html" >简体中文</a>
</select>


    <a href="#toc">목차</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ko/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL 피킹</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>이 글은 WebGL을 사용하여 물체를 선택하거나 고르는 방법에 관한 것입니다.</p>
<p>이 사이트의 다른 글을 읽으셨다면 WebGL 자체는 단순 래스터화 라이브러리라는 것을 깨달으셨을 겁니다.
삼각형, 선, 점을 캔버스에 그리므로 &quot;선택할 객체&quot;라는 개념이 없는데요.
여러분이 제공하는 셰이더를 통해 픽셀만 출력합니다.
이는 무언가를 &quot;선택&quot;하는 개념을 코드에서 가져와야 한다는 걸 의미합니다.
이를 위해 사용자가 선택할 수 있는 항목이 무엇인지 정의가 필요한데요.
말인즉슨 이 글에서 일반적인 개념을 다룰 순 있지만, 여러분의 어플리케이션에 사용 가능한 개념으로 변환하는 방법은 스스로 결정해야 합니다.</p>
<h2 id="-">객체 클릭</h2>
<p>사용자가 클릭한 항목을 알아내는 가장 쉬운 방법 중 하나는 각 객체에 대한 숫자 아이디를 제공하는 것인데, 그러면 아이디를 사용하여 조명과 텍스처 없이 색상으로 모든 객체를 그릴 수 있습니다.
이는 각 객체의 실루엣 이미지를 제공할 겁니다.
깊이 버퍼는 정렬을 처리할 텐데요.
그러면 마우스 아래에 있는 픽셀 색상을 읽을 수 있고, 거기에 렌더링된 객체의 아이디를 알 수 있습니다.</p>
<p>이 기술을 구현하기 위해 이전에 다뤘던 여러 글을 결합해야 합니다.
먼저 여러 항목을 그리면 그것들을 선택하려고 할 수 있으므로 <a href="webgl-drawing-multiple-things.html">여러 객체 그리기</a>에 대한 글에서 나온 내용을 사용할 겁니다.</p>
<p>여기에 더해 이러한 아이디를 화면 밖에서도 렌더링하고 싶기 때문에 <a href="webgl-render-to-texture.html">텍스처에 렌더링</a>하는 코드도 추가할 겁니다.</p>
<p>그럼 <a href="webgl-drawing-multiple-things.html">여러 항목 그리기</a>에서 다뤘던 200개의 항목을 그리는 마지막 예제부터 시작하겠습니다.</p>
<p>거기에 <a href="webgl-render-to-texture.html">텍스처 렌더링에 대한 글</a>의 마지막 예제에서 텍스처와 깊이 버퍼가 첨부된 프레임 버퍼를 추가해봅시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 렌더링할 텍스처 생성
const targetTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, targetTexture);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

// 깊이 렌더 버퍼 생성
const depthBuffer = gl.createRenderbuffer();
gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);

function setFramebufferAttachmentSizes(width, height) {
  gl.bindTexture(gl.TEXTURE_2D, targetTexture);
  // 레벨 0의 크기와 포맷 정의
  const level = 0;
  const internalFormat = gl.RGBA;
  const border = 0;
  const format = gl.RGBA;
  const type = gl.UNSIGNED_BYTE;
  const data = null;
  gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                width, height, border,
                format, type, data);

  gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
}

// 프레임 버퍼 생성과 바인딩
const fb = gl.createFramebuffer();
gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

// 첫 번째 color attachment에 텍스처 첨부
const attachmentPoint = gl.COLOR_ATTACHMENT0;
const level = 0;
gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, targetTexture, level);

// 깊이 버퍼를 targetTexture와 같은 크기로 만들기
gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);
</code></pre>
<p>텍스처와 깊이 렌더 버퍼의 크기를 설정하는 코드를 함수에 넣어 캔버스의 크기에 맞게 크기를 조정하도록 호출할 수 있습니다.</p>
<p>렌더링 코드에서 캔버스의 크기가 변경되면 텍스처와 렌더 버퍼가 일치하도록 조정할 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function drawScene(time) {
  time *= 0.0005;

-  webglUtils.resizeCanvasToDisplaySize(gl.canvas);
+  if (webglUtils.resizeCanvasToDisplaySize(gl.canvas)) {
+    // 캔버스 크기가 바뀌었으니 프레임 버퍼 attachment와 일치시킵니다.
+    setFramebufferAttachmentSizes(gl.canvas.width, gl.canvas.height);
+  }

...
</code></pre>
<p>다음으로 두 번째 셰이더가 필요합니다.
샘플의 셰이더는 정점 색상을 사용하여 렌더링하고 있지만 우리는 아이디로 렌더링하기 위해 단색으로 설정 가능한 셰이더가 필요합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;!-- 정점 셰이더 --&gt;
&lt;script id=&quot;pick-vertex-shader&quot; type=&quot;x-shader/x-vertex&quot;&gt;
  attribute vec4 a_position;

  uniform mat4 u_matrix;

  void main() {
    // Multiply the position by the matrix.
    gl_Position = u_matrix * a_position;
  }
&lt;/script&gt;
&lt;!-- 프래그먼트 셰이더 --&gt;
&lt;script id=&quot;pick-fragment-shader&quot; type=&quot;x-shader/x-fragment&quot;&gt;
  precision mediump float;

  uniform vec4 u_id;

  void main() {
     gl_FragColor = u_id;
  }
&lt;/script&gt;
</code></pre>
<p>그리고 <a href="webgl-less-code-more-fun.html">도우미 함수</a>를 사용하여 컴파일, 연결, 위치 탐색을 해야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// GLSL 프로그램 설정
const programInfo = webglUtils.createProgramInfo(
    gl, [&quot;3d-vertex-shader&quot;, &quot;3d-fragment-shader&quot;]);
+const pickingProgramInfo = webglUtils.createProgramInfo(
+    gl, [&quot;pick-vertex-shader&quot;, &quot;pick-fragment-shader&quot;]);
</code></pre>
<p>모든 객체를 두 번 렌더링할 수 있어야 합니다.
할당한 셰이더와 방금 작성한 셰이더로 모든 객체를 렌더링하는 코드를 함수로 추출해봅시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function drawObjects(objectsToDraw, overrideProgramInfo) {
  objectsToDraw.forEach(function(object) {
    const programInfo = overrideProgramInfo || object.programInfo;
    const bufferInfo = object.bufferInfo;

    gl.useProgram(programInfo.program);

    // 필요한 모든 속성 설정
    webglUtils.setBuffersAndAttributes(gl, programInfo, bufferInfo);

    // 유니폼 설정
    webglUtils.setUniforms(programInfo, object.uniforms);

    // 그리기
    gl.drawArrays(gl.TRIANGLES, 0, bufferInfo.numElements);
  });
}
</code></pre>
<p><code class="notranslate" translate="no">drawObjects</code>는 객체의 할당된 셰이더 대신에 피킹 셰이더를 사용하기 위해 전달할 수 있는 선택적 <code class="notranslate" translate="no">overrideProgramInfo</code>를 가집니다.</p>
<p>이를 호출하여 한 번은 아이디로 텍스처에, 다시 한 번은 캔버스에 장면을 그려봅시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 장면 그리기
function drawScene(time) {
  time *= 0.0005;

  ...

  // 각 객체에 대한 행렬 계산
  objects.forEach(function(object) {
    object.uniforms.u_matrix = computeMatrix(
        viewProjectionMatrix,
        object.translation,
        object.xRotationSpeed * time,
        object.yRotationSpeed * time);
  });

+  // ------ 텍스처에 객체 그리기 --------
+
+  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
+  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
+
+  gl.enable(gl.CULL_FACE);
+  gl.enable(gl.DEPTH_TEST);
+
+  // 캔버스와 깊이 버퍼 지우기
+  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
+
+  drawObjects(objectsToDraw, pickingProgramInfo);
+
+  // ------ 캔버스에 객체 그리기
+
+  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
+  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
+
+  drawObjects(objectsToDraw);

  requestAnimationFrame(drawScene);
}
</code></pre>
<p>피킹 셰이더는 <code class="notranslate" translate="no">u_id</code>를 아이디로 설정해야 하므로 유니폼 데이터에 이를 추가해봅시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 각 객체에 대한 정보를 만듭니다.
const baseHue = rand(0, 360);
const numObjects = 200;
for (let ii = 0; ii &lt; numObjects; ++ii) {
+  const id = ii + 1;
  const object = {
    uniforms: {
      u_colorMult: chroma.hsv(eMod(baseHue + rand(0, 120), 360), rand(0.5, 1), rand(0.5, 1)).gl(),
      u_matrix: m4.identity(),
+      u_id: [
+        ((id &gt;&gt;  0) &amp; 0xFF) / 0xFF,
+        ((id &gt;&gt;  8) &amp; 0xFF) / 0xFF,
+        ((id &gt;&gt; 16) &amp; 0xFF) / 0xFF,
+        ((id &gt;&gt; 24) &amp; 0xFF) / 0xFF,
+      ],
    },
    translation: [rand(-100, 100), rand(-100, 100), rand(-150, -50)],
    xRotationSpeed: rand(0.8, 1.2),
    yRotationSpeed: rand(0.8, 1.2),
  };
  objects.push(object);
  objectsToDraw.push({
    programInfo: programInfo,
    bufferInfo: shapes[ii % shapes.length],
    uniforms: object.uniforms,
  });
}
</code></pre>
<p><a href="webgl-less-code-more-fun.html">도우미 라이브러리</a>가 유니폼 적용을 처리하기 때문에 잘 동작합니다.</p>
<p>아이디를 R, G, B, A로 나눠야 합니다.
텍스처의 포맷/타입이 <code class="notranslate" translate="no">gl.RGBA</code>/<code class="notranslate" translate="no">gl.UNSIGNED_BYTE</code>이기 때문에 채널당 8비트를 얻습니다.
8비트는 256개의 값만 나타낼 수 있지만 아이디를 4개의 채널로 나눠서 총 40억개 이상인 32비트를 얻을 수 있습니다.</p>
<p>&quot;마우스 아래에 아무것도 없음&quot;을 의미하는 0을 사용할 것이기 때문에 아이디에 1을 추가합니다.</p>
<p>이제 마우스 아래에 있는 객체를 하이라이트 표시해봅시다.</p>
<p>먼저 캔버스에 상대적인 마우스 위치를 가져오는 코드가 필요합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// mouseX와 mouseY는 캔버스에 상대적인 CSS 표시 공간에 있습니다.
let mouseX = -1;
let mouseY = -1;

...

gl.canvas.addEventListener(&#39;mousemove&#39;, (e) =&gt; {
   const rect = canvas.getBoundingClientRect();
   mouseX = e.clientX - rect.left;
   mouseY = e.clientY - rect.top;
});
</code></pre>
<p>위 코드에서 <code class="notranslate" translate="no">mouseX</code>와 <code class="notranslate" translate="no">mouseY</code>는 표시 공간의 CSS 픽셀에 있습니다.
즉 캔버스에 있는 픽셀 수의 공간이 아니라 캔버스가 표시되는 공간에 있다는 뜻입니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;canvas width=&quot;11&quot; height=&quot;22&quot; style=&quot;width:33px; height:44px;&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p>다시 말해 이런 캔버스가 있을 때 <code class="notranslate" translate="no">mouseX</code>는 0에서 33까지이고 <code class="notranslate" translate="no">mouseY</code>는 0에서 44까지입니다.
더 많은 정보를 알고 싶다면 <a href="webgl-resizing-the-canvas.html">이 글</a>을 확인해주세요.</p>
<p>이제 마우스 위치를 가지고 있으니 마우스 아래의 픽셀을 찾는 코드를 추가해봅시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;
const data = new Uint8Array(4);
gl.readPixels(
    pixelX,            // x
    pixelY,            // y
    1,                 // 너비
    1,                 // 높이
    gl.RGBA,           // 포맷
    gl.UNSIGNED_BYTE,  // 타입
    data);             // 결과를 저장할 형식화 배열
const id = data[0] + (data[1] &lt;&lt; 8) + (data[2] &lt;&lt; 16) + (data[3] &lt;&lt; 24);
</code></pre>
<p><code class="notranslate" translate="no">pixelX</code>와 <code class="notranslate" translate="no">pixelY</code>를 계산하는 위 코드는 표시 공간의 <code class="notranslate" translate="no">mouseX</code>와 <code class="notranslate" translate="no">mouseY</code>에서 캔버스 공간의 픽셀로 변환합니다.
다시 말해 위 예제에서 <code class="notranslate" translate="no">mouseX</code>는 0에서 33사이가 되고 <code class="notranslate" translate="no">mouseY</code>는 0에서 44사이가 됩니다.
<code class="notranslate" translate="no">pixelX</code>는 0에서 11사이일 것이며 <code class="notranslate" translate="no">pixelY</code>는 0에서 22사이일 겁니다.</p>
<p>실제 코드에서는 유틸리티 함수 <code class="notranslate" translate="no">resizeCanvasToDisplaySize</code>를 사용하고 있으며, 캔버스와 동일한 크기로 텍스처를 만들기 때문에 표시 크기와 캔버스 크기는 일치하지만, 일치하지 않은 경우에 대한 최소한의 대비를 해뒀습니다.</p>
<p>이제 아이디가 있으니 실제로 선택된 객체를 하이라이트 표시하기 위해 캔버스 렌더링에 사용할 색상을 변경해봅시다.
우리가 썼던 셰이더는 사용 가능한 유니폼 <code class="notranslate" translate="no">u_colorMult</code>를 가지고 있으므로, 마우스 아래에 객체가 있으면 이를 찾아서 <code class="notranslate" translate="no">u_colorMult</code> 값을 저장하고 선택 색상으로 교체한 다음 복원합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// mouseX와 mouseY는 캔버스에 상대적인 CSS 표시 공간에 있습니다.
let mouseX = -1;
let mouseY = -1;
+let oldPickNdx = -1;
+let oldPickColor;
+let frameCount = 0;

// 장면 그리기
function drawScene(time) {
  time *= 0.0005;
+  ++frameCount;

  // ------ 텍스처에 객체 그리기 --------

  ...

  // ------ 마우스 아래에 어떤 픽셀이 있는지 알아내 해당 값을 읽습니다.

  const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
  const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;
  const data = new Uint8Array(4);
  gl.readPixels(
      pixelX,            // x
      pixelY,            // y
      1,                 // 너비
      1,                 // 높이
      gl.RGBA,           // 포맷
      gl.UNSIGNED_BYTE,  // 타입
      data);             // 결과를 저장할 형식화 배열
  const id = data[0] + (data[1] &lt;&lt; 8) + (data[2] &lt;&lt; 16) + (data[3] &lt;&lt; 24);

  // 객체의 색상 복원
  if (oldPickNdx &gt;= 0) {
    const object = objects[oldPickNdx];
    object.uniforms.u_colorMult = oldPickColor;
    oldPickNdx = -1;
  }

  // 마우스 아래에 있는 객체를 하이라이트 표시
  if (id &gt; 0) {
    const pickNdx = id - 1;
    oldPickNdx = pickNdx;
    const object = objects[pickNdx];
    oldPickColor = object.uniforms.u_colorMult;
    object.uniforms.u_colorMult = (frameCount &amp; 0x8) ? [1, 0, 0, 1] : [1, 1, 0, 1];
  }

  // ------ 캔버스에 객체 그리기
</code></pre>
<p>그러면 마우스를 장면 위에서 움직일 수 있고 마우스 아래의 객체는 깜박일 겁니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-picking-w-gpu.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-picking-w-gpu.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>가능한 최적화 중 하나는 아이디를 캔버스와 동일한 크기의 텍스처로 렌더링하는 겁니다.
개념적으로는 가장 쉬운 작업입니다.</p>
<p>하지만 마우스 아래에 있는 픽셀만 렌더링할 수도 있습니다.
이를 위해 수식이 해당 1픽셀만 포함하도록 절두체를 사용합니다.</p>
<p>지금까지는 3D의 경우 Z평면에 대한 시야, 종횡비, near/far 값을 입력으로 사용하고, 이러한 값들로 정의된 절두체를 클립 공간으로 변환하기 위한 원근 투영 행렬을 만드는 <code class="notranslate" translate="no">perspective</code> 함수를 사용했습니다.</p>
<p>대부분의 3D 수학 라이브러리는 Z평면에 대한 left, right, top, bottom, z-near, z-far, 6개의 값을 받아 원근 행렬을 생성하는 <code class="notranslate" translate="no">frustum</code> 함수가 가지고 있습니다.</p>
<p>이를 사용하여 마우스 아래에 있는 1픽셀에 대한 원근 행렬을 생성할 수 있습니다.</p>
<p>먼저 <code class="notranslate" translate="no">perspective</code> 함수를 사용하는 경우 근거리 평면의 가장자리와 크기를 계산합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 절두체의 근거리 평면 계산
const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
const top = Math.tan(fieldOfViewRadians * 0.5) * near;
const bottom = -top;
const left = aspect * bottom;
const right = aspect * top;
const width = Math.abs(right - left);
const height = Math.abs(top - bottom);
</code></pre>
<p><code class="notranslate" translate="no">left</code>, <code class="notranslate" translate="no">right</code>, <code class="notranslate" translate="no">width</code>, <code class="notranslate" translate="no">height</code>는 근거리 평면의 크기와 위치입니다.
이제 해당 평면에서 마우스 아래에 있는 1픽셀의 크기와 위치를 계산하고 <code class="notranslate" translate="no">frustum</code> 함수에 전달하여 해당 1픽셀을 포함하는 투영 행렬을 생성할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 마우스 아래의 1픽셀을 포함하는 근거리 평면 부분 계산
const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;

const subLeft = left + pixelX * width / gl.canvas.width;
const subBottom = bottom + pixelY * height / gl.canvas.height;
const subWidth = 1 / gl.canvas.width;
const subHeight = 1 / gl.canvas.height;

// 해당 1픽셀에 대한 절두체 만들기
const projectionMatrix = m4.frustum(
    subLeft,
    subLeft + subWidth,
    subBottom,
    subBottom + subHeight,
    near,
    far);
</code></pre>
<p>이걸 사용하려면 약간의 변경이 필요합니다.
이제 셰이더는 <code class="notranslate" translate="no">u_matrix</code>만 사용하기 때문에 다른 투영 행렬로 그리려고 한다면, 캔버스에 그리기 위해 일반 투영 행렬로 한 번, 1픽셀 투영 행렬에 대해 다시 한 번, 모든 객체에 대해 프레임마다 두 번씩 행렬을 다시 계산해야 합니다.</p>
<p>해당 곱셈을 정점 셰이더로 이동하여 자바스크립트에서 제거할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;!-- 정점 셰이더 --&gt;
&lt;script id=&quot;3d-vertex-shader&quot; type=&quot;x-shader/x-vertex&quot;&gt;
attribute vec4 a_position;
attribute vec4 a_color;

-uniform mat4 u_matrix;
+uniform mat4 u_viewProjection;
+uniform mat4 u_world;

varying vec4 v_color;

void main() {
-  // 위치에 행렬 곱하기
-  gl_Position = u_matrix * a_position;
+  // 위치에 행렬 곱하기
+  gl_Position = u_viewProjection * u_world * a_position;

  // 프래그먼트 셰이더로 색상 전달
  v_color = a_color;
}
&lt;/script&gt;

...

&lt;!-- 정점 셰이더 --&gt;
&lt;script id=&quot;pick-vertex-shader&quot; type=&quot;x-shader/x-vertex&quot;&gt;
attribute vec4 a_position;

-uniform mat4 u_matrix;
+uniform mat4 u_viewProjection;
+uniform mat4 u_world;

void main() {
-  // 위치에 행렬 곱하기
-  gl_Position = u_matrix * a_position;
+  // 위치에 행렬 곱하기
+  gl_Position = u_viewProjection * u_world * a_position;
}
&lt;/script&gt;
</code></pre>
<p>그런 다음 자바스크립트 <code class="notranslate" translate="no">viewProjectionMatrix</code>를 모든 객체에 공유할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const objectsToDraw = [];
const objects = [];
+const viewProjectionMatrix = m4.identity();

// 각 객체에 대한 정보를 만듭니다.
const baseHue = rand(0, 360);
const numObjects = 200;
for (let ii = 0; ii &lt; numObjects; ++ii) {
  const id = ii + 1;
  const object = {
    uniforms: {
      u_colorMult: chroma.hsv(eMod(baseHue + rand(0, 120), 360), rand(0.5, 1), rand(0.5, 1)).gl(),
-      u_matrix: m4.identity(),
+      u_world: m4.identity(),
+      u_viewProjection: viewProjectionMatrix,
      u_id: [
        ((id &gt;&gt;  0) &amp; 0xFF) / 0xFF,
        ((id &gt;&gt;  8) &amp; 0xFF) / 0xFF,
        ((id &gt;&gt; 16) &amp; 0xFF) / 0xFF,
        ((id &gt;&gt; 24) &amp; 0xFF) / 0xFF,
      ],
    },
    translation: [rand(-100, 100), rand(-100, 100), rand(-150, -50)],
    xRotationSpeed: rand(0.8, 1.2),
    yRotationSpeed: rand(0.8, 1.2),
  };
</code></pre>
<p>그리고 각 객체에 대한 행렬을 계산하는 곳에서 더 이상 뷰 투영 행렬을 포함시킬 필요가 없습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-function computeMatrix(viewProjectionMatrix, translation, xRotation, yRotation) {
-  let matrix = m4.translate(viewProjectionMatrix,
+function computeMatrix(translation, xRotation, yRotation) {
+  let matrix = m4.translation(
      translation[0],
      translation[1],
      translation[2]);
  matrix = m4.xRotate(matrix, xRotation);
  return m4.yRotate(matrix, yRotation);
}
...

// 각 객체에 대한 행렬 계산
objects.forEach(function(object) {
  object.uniforms.u_world = computeMatrix(
-      viewProjectionMatrix,
      object.translation,
      object.xRotationSpeed * time,
      object.yRotationSpeed * time);
});
</code></pre>
<p>1x1 픽셀 텍스처와 깊이 버퍼만 생성할 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">setFramebufferAttachmentSizes(1, 1);

...

// 장면 그리기
function drawScene(time) {
  time *= 0.0005;
  ++frameCount;

-  if (webglUtils.resizeCanvasToDisplaySize(gl.canvas)) {
-    // 캔버스 크기가 바뀌었으니 프레임 버퍼 attachment와 일치시킵니다.
-    setFramebufferAttachmentSizes(gl.canvas.width, gl.canvas.height);
-  }
+  webglUtils.resizeCanvasToDisplaySize(gl.canvas);
</code></pre>
<p>그런 다음 화면 바깥의 아이디들을 렌더링하기 전에 1픽셀 투영 행렬을 사용하여 뷰 투영을 설정한 다음 캔버스에 그릴 때 원본 투영 행렬을 사용할 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-// 투영 행렬 계산
-const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
-const projectionMatrix =
-    m4.perspective(fieldOfViewRadians, aspect, 1, 2000);

// lookAt을 사용하여 카메라 행렬 계산
const cameraPosition = [0, 0, 100];
const target = [0, 0, 0];
const up = [0, 1, 0];
const cameraMatrix = m4.lookAt(cameraPosition, target, up);

// 카메라 행렬로 뷰 행렬 만들기
const viewMatrix = m4.inverse(cameraMatrix);

-const viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);

// 각 객체에 대한 행렬 계산
objects.forEach(function(object) {
  object.uniforms.u_world = computeMatrix(
      object.translation,
      object.xRotationSpeed * time,
      object.yRotationSpeed * time);
});

// ------ 텍스처에 객체 그리기 --------

// 마우스 아래에 어떤 픽셀이 있는지 알아내 해당 픽셀만 렌더링하도록 절두체를 설정합니다.

{
  // 절두체의 근거리 평면 계산
  const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
  const top = Math.tan(fieldOfViewRadians * 0.5) * near;
  const bottom = -top;
  const left = aspect * bottom;
  const right = aspect * top;
  const width = Math.abs(right - left);
  const height = Math.abs(top - bottom);

  // 마우스 아래의 1픽셀을 포함하는 근거리 평면 부분 계산
  const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
  const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;

  const subLeft = left + pixelX * width / gl.canvas.width;
  const subBottom = bottom + pixelY * height / gl.canvas.height;
  const subWidth = 1 / gl.canvas.width;
  const subHeight = 1 / gl.canvas.height;

  // 해당 1픽셀에 대한 절두체 만들기
  const projectionMatrix = m4.frustum(
      subLeft,
      subLeft + subWidth,
      subBottom,
      subBottom + subHeight,
      near,
      far);
+  m4.multiply(projectionMatrix, viewMatrix, viewProjectionMatrix);
}

gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
gl.viewport(0, 0, 1, 1);

gl.enable(gl.CULL_FACE);
gl.enable(gl.DEPTH_TEST);

// 캔버스와 깊이 버퍼 지우기
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

drawObjects(objectsToDraw, pickingProgramInfo);

// 1픽셀 읽기
-const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
-const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;
const data = new Uint8Array(4);
gl.readPixels(
-    pixelX,            // x
-    pixelY,            // y
+    0,                 // x
+    0,                 // y
    1,                 // 너비
    1,                 // 높이
    gl.RGBA,           // 포맷
    gl.UNSIGNED_BYTE,  // 타입
    data);             // 결과를 저장할 형식화 배열
const id = data[0] + (data[1] &lt;&lt; 8) + (data[2] &lt;&lt; 16) + (data[3] &lt;&lt; 24);

// 객체의 색상을 복원
if (oldPickNdx &gt;= 0) {
  const object = objects[oldPickNdx];
  object.uniforms.u_colorMult = oldPickColor;
  oldPickNdx = -1;
}

// 마우스가 있는 곳의 객체를 하이라이트 표시
if (id &gt; 0) {
  const pickNdx = id - 1;
  oldPickNdx = pickNdx;
  const object = objects[pickNdx];
  oldPickColor = object.uniforms.u_colorMult;
  object.uniforms.u_colorMult = (frameCount &amp; 0x8) ? [1, 0, 0, 1] : [1, 1, 0, 1];
}

// ------ 캔버스에 객체 그리기

+{
+  // 투영 행렬 계산
+  const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
+  const projectionMatrix =
+      m4.perspective(fieldOfViewRadians, aspect, near, far);
+
+  m4.multiply(projectionMatrix, viewMatrix, viewProjectionMatrix);
+}

gl.bindFramebuffer(gl.FRAMEBUFFER, null);
gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

drawObjects(objectsToDraw);
</code></pre>
<p>그리고 수식이 동작하는 것을 확인할 수 있고 단일 픽셀만 그리고 있으며 여전히 마우스 아래에 무엇이 있는지 알아내고 있습니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-picking-w-gpu-1pixel.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-picking-w-gpu-1pixel.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-picking.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-picking.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-picking.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-picking.html" selected>한국어</a>
    <option value="/webgl/lessons/pl/webgl-picking.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-picking.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-picking.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-picking.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>기초</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-fundamentals.html">기초</a></li>
<li><a href="/webgl/lessons/ko/webgl-how-it-works.html">작동 방식</a></li>
<li><a href="/webgl/lessons/ko/webgl-shaders-and-glsl.html">셰이더와 GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL 상태 다이어그램</a></li>
        </ul>
  <li>이미지 처리</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-image-processing.html">이미지 처리</a></li>
<li><a href="/webgl/lessons/ko/webgl-image-processing-continued.html">이미지 처리 심화</a></li>
        </ul>
  <li>2D Translation, Rotation, Scale, 행렬 수학</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-translation.html">2D Translation</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-rotation.html">2D Rotation</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-scale.html">2D Scale</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrices.html">2D 행렬</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-orthographic.html">3D Orthographic</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective.html">3D Perspective</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-camera.html">3D 카메라</a></li>
        </ul>
  <li>조명</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-lighting-directional.html">방향성 조명</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-point.html">점 조명</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-spot.html">스포트라이트</a></li>
        </ul>
  <li>구조와 구성</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-multiple-things.html">여러 물체 그리기</a></li>
<li><a href="/webgl/lessons/ko/webgl-scene-graph.html">장면 그래프</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-geometry-lathe.html">지오메트리 - Lathe</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj.html">.obj 파일 로딩</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj-w-mtl.html">.mtl 파일로 .obj 로딩</a></li>
        </ul>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-textures.html">텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-data-textures.html">데이터 텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-2-textures.html">2개 이상의 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-cors-permission.html">교차 출처 이미지</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective-correct-texturemapping.html">원근 교정 텍스처 매핑</a></li>
<li><a href="/webgl/lessons/ko/webgl-planar-projection-mapping.html">평면 및 원근 투영 매핑</a></li>
        </ul>
  <li>텍스처 렌더링</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-render-to-texture.html">텍스처 렌더링</a></li>
        </ul>
  <li>그림자</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-shadows.html">그림자</a></li>
        </ul>
  <li>기법</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrix-stack.html">2D - 행렬 스택</a></li>
<li><a href="/webgl/lessons/ko/webgl-sprites.html">Sprite</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-cube-maps.html">큐브맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-environment-maps.html">환경맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-skybox.html">스카이박스</a></li>
<li><a href="/webgl/lessons/ko/webgl-skinning.html">스키닝</a></li>
<li><a href="/webgl/lessons/ko/webgl-fog.html">안개</a></li>
<li><a href="/webgl/lessons/ko/webgl-picking.html">피킹 (물체 클릭)</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-text-html.html">텍스트 - HTML</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-canvas2d.html">텍스트 - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-texture.html">텍스트 - 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-glyphs.html">텍스트 - 글리프 텍스처 사용</a></li>
        </ul>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-ramp-textures.html">램프 텍스처 (툰 셰이딩)</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Tip</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-smallest-programs.html">최소 프로그램</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-without-data.html">데이터 없이 그리기</a></li>
<li><a href="/webgl/lessons/ko/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ko/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>최적화</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-indexed-vertices.html">색인된 정점 (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ko/webgl-instanced-drawing.html">Instanced Drawing</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-setup-and-installation.html">설정 및 설치</a></li>
<li><a href="/webgl/lessons/ko/webgl-boilerplate.html">상용구</a></li>
<li><a href="/webgl/lessons/ko/webgl-resizing-the-canvas.html">캔버스 크기 조정</a></li>
<li><a href="/webgl/lessons/ko/webgl-animation.html">애니메이션</a></li>
<li><a href="/webgl/lessons/ko/webgl-points-lines-triangles.html">점, 선, 삼각형</a></li>
<li><a href="/webgl/lessons/ko/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/ko/webgl-visualizing-the-camera.html">카메라 시각화</a></li>
<li><a href="/webgl/lessons/ko/webgl-and-alpha.html">WebGL Alpha</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-vs-3d-library.html">2D vs 3D 라이브러리</a></li>
<li><a href="/webgl/lessons/ko/webgl-anti-patterns.html">안티 패턴</a></li>
<li><a href="/webgl/lessons/ko/webgl-matrix-vs-math.html">WebGL 행렬 vs 수학 행렬</a></li>
<li><a href="/webgl/lessons/ko/webgl-precision-issues.html">정밀도 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#screenshot">스크린샷 찍기</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#preservedrawingbuffer">캔버스 지우기 방지</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#tabindex">캔버스 키보드 입력</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#html-background">WebGL 배경 제작</a></li>
<li><a href="/webgl/lessons/ko/webgl-cross-platform-issues.html">크로스 플랫폼 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-qna.html">질문 및 답변</a></li>
        </ul>
  <li>참고</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-attributes.html">속성</a></li>
<li><a href="/webgl/lessons/ko/webgl-texture-units.html">텍스처 유닛</a></li>
<li><a href="/webgl/lessons/ko/webgl-framebuffers.html">프레임 버퍼</a></li>
<li><a href="/webgl/lessons/ko/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ko/webgl-references.html">참고 자료</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">도우미 API 문서</a></li>
  <li><a href="https://twgljs.org">TWGL, 가벼운 WebGL 라이브러리</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Github</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
    <div>이슈/버그는? <a href="https://github.com/gfxfundamentals/webgl-fundamentals/issues">Github</a>에 이슈를 만들어주세요.</div>
    <div class="lesson-comment-notes">
      코드 블록은 <b>&lt;pre&gt;&lt;code&gt;</b>여기에 코드 입력<b>&lt;/code&gt;&lt;/pre&gt;</b>를 사용해주세요
    </div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL 피킹';
            var disqus_title = 'WebGL 피킹';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
      return;
  }

  function addScript(src, type, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    script.type = type || 'javascript';
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  // can't do this because it would eat contexts
  //addScript('//gpustats.org/stats.js', 'module');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>



