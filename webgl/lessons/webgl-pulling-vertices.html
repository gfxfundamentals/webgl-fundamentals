<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/webgl-pulling-vertices.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="WebGL Pulling Vertices" />
<meta property="og:type" content="website" />
<meta property="og:image" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />
<meta property="og:description" content="Using independent indices" />
<meta property="og:url" content="http://webglfundamentals.org/webgl/lessons/webgl-pulling-vertices.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webglfundamentals.org" />
<meta name="twitter:title" content="WebGL Pulling Vertices" />
<meta name="twitter:url" content="http://webglfundamentals.org/webgl/lessons/webgl-pulling-vertices.html" />
<meta name="twitter:description" content="Using independent indices" />
<meta name="twitter:image:src" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />


<title>WebGL Pulling Vertices</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />
</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-pulling-vertices.html" selected>English</a>
    <option value="/webgl/lessons/fr/webgl-pulling-vertices.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-pulling-vertices.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-pulling-vertices.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-pulling-vertices.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-pulling-vertices.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-pulling-vertices.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-pulling-vertices.html" >简体中文</a>
</select>


    <a href="#toc">Table of Contents</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/">WebGLFundamentals.org</a></h1>
</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL Pulling Vertices</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>This article assumes you&#39;ve read many of the other articles
starting with <a href="webgl-fundamentals.html">the fundamentals</a>.
If you have not read them please start there first.</p>
<p>Traditionally, WebGL apps put geometry data in buffers.
They then use attributes to automatically supply vertex data from those buffers
to the vertex shader where the programmer provides code to convert them to clip space.</p>
<p>The word <strong>traditionally</strong> is important. It&#39;s only a <strong>tradition</strong>
to do it this way. It is in no way a requirement. WebGL doesn&#39;t
care how we do it, it only cares that our vertex shaders
assign clip space coordinates to <code>gl_Position</code>.</p>
<p>Let&#39;s draw a texture mapped cube using code like the examples in <a href="webgl-3d-textures.html">the article on textures</a>. 
We&#39;re told we need at least 24 unique vertices. This is because even though there are only 8 corner
positions the same corner gets used on 3 different faces of the
cube and each face needs different texture coordinates.</p>
<div class="webgl_center"><img src="resources/cube-vertices-uv.svg" style="width: 400px;"></div>

<p>In the diagram above we can see that the left face&#39;s use of corner 3 needs
texture coordinates 1,1 but in the right face&#39;s use of corner 3 needs texture coordinates
0,1. The top face would need different texture coordinates as well.</p>
<p>This is usually accomplished by expanding from 8 corner positions
to 24 vertices</p>
<pre class="prettyprint"><code class="lang-js">  // front
  { pos: [-1, -1,  1], uv: [0, 1], }, // 0
  { pos: [ 1, -1,  1], uv: [1, 1], }, // 1
  { pos: [-1,  1,  1], uv: [0, 0], }, // 2
  { pos: [ 1,  1,  1], uv: [1, 0], }, // 3
  // right
  { pos: [ 1, -1,  1], uv: [0, 1], }, // 4
  { pos: [ 1, -1, -1], uv: [1, 1], }, // 5
  { pos: [ 1,  1,  1], uv: [0, 0], }, // 6
  { pos: [ 1,  1, -1], uv: [1, 0], }, // 7
  // back
  { pos: [ 1, -1, -1], uv: [0, 1], }, // 8
  { pos: [-1, -1, -1], uv: [1, 1], }, // 9
  { pos: [ 1,  1, -1], uv: [0, 0], }, // 10
  { pos: [-1,  1, -1], uv: [1, 0], }, // 11
  // left
  { pos: [-1, -1, -1], uv: [0, 1], }, // 12
  { pos: [-1, -1,  1], uv: [1, 1], }, // 13
  { pos: [-1,  1, -1], uv: [0, 0], }, // 14
  { pos: [-1,  1,  1], uv: [1, 0], }, // 15
  // top
  { pos: [ 1,  1, -1], uv: [0, 1], }, // 16
  { pos: [-1,  1, -1], uv: [1, 1], }, // 17
  { pos: [ 1,  1,  1], uv: [0, 0], }, // 18
  { pos: [-1,  1,  1], uv: [1, 0], }, // 19
  // bottom
  { pos: [ 1, -1,  1], uv: [0, 1], }, // 20
  { pos: [-1, -1,  1], uv: [1, 1], }, // 21
  { pos: [ 1, -1, -1], uv: [0, 0], }, // 22
  { pos: [-1, -1, -1], uv: [1, 0], }, // 23
</code></pre>
<p>Those positions and texture coordinates are
put into buffers and provided to the vertex shader
via attributes.</p>
<p>But do we really need to do it this way? What if
we wanted to actually have just the 8 corners
and 4 texture coordinates. Something like</p>
<pre class="prettyprint"><code class="lang-js">positions = [
  -1, -1,  1,  // 0
   1, -1,  1,  // 1
  -1,  1,  1,  // 2
   1,  1,  1,  // 3
  -1, -1, -1,  // 4
   1, -1, -1,  // 5
  -1,  1, -1,  // 6
   1,  1, -1,  // 7
];
uvs = [
  0, 0,  // 0
  1, 0,  // 1
  0, 1,  // 2
  1, 1,  // 3
];
</code></pre>
<p>And then for each of the 24 vertices we&#39;d specify which of those
to use.</p>
<pre class="prettyprint"><code class="lang-js">positionIndexUVIndex = [
  // front
  0, 1, // 0
  1, 3, // 1
  2, 0, // 2
  3, 2, // 3
  // right
  1, 1, // 4
  5, 3, // 5
  3, 0, // 6
  7, 2, // 7
  // back
  5, 1, // 8
  4, 3, // 9
  7, 0, // 10
  6, 2, // 11
  // left
  4, 1, // 12
  0, 3, // 13
  6, 0, // 14
  2, 2, // 15
  // top
  7, 1, // 16
  6, 3, // 17
  3, 0, // 18
  2, 2, // 19
  // bottom
  1, 1, // 20
  0, 3, // 21
  5, 0, // 22
  4, 2, // 23
];
</code></pre>
<p>Could we use this on the GPU? Why not!?</p>
<p>We&#39;ll upload the positions and texture coordinates
each to their own textures. First we&#39;ll check for and enable
floating point textures as this will make it easy
to put our positions in the texture. Otherwise
we&#39;d need to encode them in some other way.</p>
<pre class="prettyprint"><code class="lang-js">const gl = canvas.getContext(&quot;webgl&quot;);
if (!gl) {
  return;
}
+const ext = gl.getExtension(&#39;OES_texture_float&#39;);
+if (!ext) {
+  alert(&#39;need OES_texture_float&#39;);
+  return;
+}
</code></pre>
<p>Then we&#39;ll put the data into a textures like
we covered in <a href="webgl-data-textures.html">the article on data textures</a>.</p>
<pre class="prettyprint"><code class="lang-js">function makeDataTexture(gl, data, numComponents) {
  // expand the data to 4 values per pixel.
  const numElements = data.length / numComponents;
  const expandedData = new Float32Array(numElements * 4);
  for (let i = 0; i &lt; numElements; ++i) {
    const srcOff = i * numComponents;
    const dstOff = i * 4;
    for (let j = 0; j &lt; numComponents; ++j) {
      expandedData[dstOff + j] = data[srcOff + j];
    }
  }
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(
      gl.TEXTURE_2D,
      0,            // mip level
      gl.RGBA,      // format
      numElements,  // width
      1,            // height
      0,            // border
      gl.RGBA,      // format
      gl.FLOAT,     // type
      expandedData,
  );
  // make it possible to use a non-power-of-2 texture and
  // we don&#39;t need any filtering
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  return tex;
}

const positionTexture = makeDataTexture(gl, positions, 3);
const texcoordTexture = makeDataTexture(gl, uvs, 2);
</code></pre>
<p>Since textures have up to 4 values per pixel <code>makeDataTexture</code>
expands whatever data we give it to 4 values per pixel. </p>
<p>Next we need up load the position and texcoord indices to a buffer.</p>
<pre class="prettyprint"><code class="lang-js">// Create a buffer for the position and UV indices
const positionIndexUVIndexBuffer = gl.createBuffer();
// Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
gl.bindBuffer(gl.ARRAY_BUFFER, positionIndexUVIndexBuffer);
// Put the position and texcoord indices in the buffer
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positionIndexUVIndex), gl.STATIC_DRAW);
</code></pre>
<p>Even though we only need 24 vertices we still need draw 6 faces, 12 triangles
each, 3 vertices per triangle for 36 vertices. To tell it which 6 vertices
to use for each face we&#39;ll use <a href="webgl-indexed-vertices.html">vertex indices</a>.</p>
<pre class="prettyprint"><code class="lang-js">const indices = [
   0,  1,  2,   2,  1,  3,  // front
   4,  5,  6,   6,  5,  7,  // right
   8,  9, 10,  10,  9, 11,  // back
  12, 13, 14,  14, 13, 15,  // left
  16, 17, 18,  18, 17, 19,  // top
  20, 21, 22,  22, 21, 23,  // bottom
];
// Create an index buffer
const indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
// Put the indices in the buffer
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
</code></pre>
<p>As we want to draw an image on the cube itself we need a 3rd texture
with that image. Let&#39;s just make another 4x4 data texture with a checkerboard.
We&#39;ll use <code>gl.LUMINANCE</code> as the format since then we only need one byte per pixel.</p>
<pre class="prettyprint"><code class="lang-js">// Create a checker texture.
const checkerTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, checkerTexture);
// Fill the texture with a 4x4 gray checkerboard.
gl.texImage2D(
    gl.TEXTURE_2D,
    0,
    gl.LUMINANCE,
    4,
    4,
    0,
    gl.LUMINANCE,
    gl.UNSIGNED_BYTE,
    new Uint8Array([
      0xDD, 0x99, 0xDD, 0xAA,
      0x88, 0xCC, 0x88, 0xDD,
      0xCC, 0x88, 0xCC, 0xAA,
      0x88, 0xCC, 0x88, 0xCC,
    ]),
);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
</code></pre>
<p>On to the vertex shader... We can look up a pixel from the texture like
this</p>
<pre class="prettyprint"><code class="lang-glsl">vec4 texelFetch(sampler2D tex, vec2 texSize, vec2 pixelCoord) {
  vec2 uv = (pixelCoord + 0.5) / texSize;
  return texture2D(tex, uv);
}
</code></pre>
<p>So given an integer pixel coordinate and the size of the texture in pixels the
code above will pull out a pixel value. If you&#39;re curious why the <code>+ 0.5</code> see <a href="webgl-skinning.html">the
article on skinning</a>.</p>
<p>Given the <code>texelFetch</code> function we can take a 1D array index
and lookup a value out of a 2D texture like this</p>
<pre class="prettyprint"><code class="lang-glsl">vec4 getValueByIndexFromTexture(sampler2D tex, vec2 texSize, float index) {
  float col = mod(index, texSize.x);
  float row = floor(index / texSize.x);
  return texelFetch(tex, texSize, vec2(col, row));
}
</code></pre>
<p>So given those 2 functions here is our shader</p>
<pre class="prettyprint"><code class="lang-glsl">attribute vec2 positionAndTexcoordIndices;

uniform sampler2D positionTexture;
uniform vec2 positionTextureSize;
uniform sampler2D texcoordTexture;
uniform vec2 texcoordTextureSize;

uniform mat4 u_matrix;

varying vec2 v_texcoord;

vec4 texelFetch(sampler2D tex, vec2 texSize, vec2 pixelCoord) {
  vec2 uv = (pixelCoord + 0.5) / texSize;
  return texture2D(tex, uv);
} 

vec4 getValueByIndexFromTexture(sampler2D tex, vec2 texSize, float index) {
  float col = mod(index, texSize.x);
  float row = floor(index / texSize.x);
  return texelFetch(tex, texSize, vec2(col, row));
}

void main() {
  float positionIndex = positionAndTexcoordIndices.x;
  vec3 position = getValueByIndexFromTexture(
      positionTexture, positionTextureSize, positionIndex).xyz;

  // Multiply the position by the matrix.
  gl_Position = u_matrix * vec4(position, 1);

  float texcoordIndex = positionAndTexcoordIndices.y;
  vec2 texcoord = getValueByIndexFromTexture(
      texcoordTexture, texcoordTextureSize, texcoordIndex).xy;

  // Pass the texcoord to the fragment shader.
  v_texcoord = texcoord;
}
</code></pre>
<p>At the bottom it&#39;s effectively the same shader we used
in <a href="webgl-3d-textures.html">the article on textures</a>.
We multiply a <code>position</code> by <code>u_matrix</code> and we output
a texcoord to <code>v_texcoord</code> to pass on the fragment shader.</p>
<p>The difference is only in how we get the position and
texcoord. We&#39;re using the indices passed in and getting
those values from their respective textures.</p>
<p>To use the shader we need to lookup all the locations</p>
<pre class="prettyprint"><code class="lang-js">// setup GLSL program
const program = webglUtils.createProgramFromScripts(gl, [&quot;3d-vertex-shader&quot;, &quot;3d-fragment-shader&quot;]);

+// look up where the vertex data needs to go.
+const posTexIndexLoc = gl.getAttribLocation(
+    program, &quot;positionAndTexcoordIndices&quot;);
+
+// lookup uniforms
+const matrixLoc = gl.getUniformLocation(program, &quot;u_matrix&quot;);
+const positionTexLoc = gl.getUniformLocation(program, &quot;positionTexture&quot;);
+const positionTexSizeLoc = gl.getUniformLocation(program, &quot;positionTextureSize&quot;);
+const texcoordTexLoc = gl.getUniformLocation(program, &quot;texcoordTexture&quot;);
+const texcoordTexSizeLoc = gl.getUniformLocation(program, &quot;texcoordTextureSize&quot;);
+const u_textureLoc = gl.getUniformLocation(program, &quot;u_texture&quot;);
</code></pre>
<p>At render time we setup the attributes</p>
<pre class="prettyprint"><code class="lang-js">// Tell it to use our program (pair of shaders)
gl.useProgram(program);

+// Bind the positionIndexUVIndex buffer.
+gl.bindBuffer(gl.ARRAY_BUFFER, positionIndexUVIndexBuffer);
+
+// Turn on the position index attribute
+gl.enableVertexAttribArray(posTexIndexLoc);
+
+// Tell the position/texcoord index attribute how to get data out
+// of positionIndexUVIndexBuffer (ARRAY_BUFFER)
+{
+  const size = 2;          // 2 components per iteration
+  const type = gl.FLOAT;   // the data is 32bit floats
+  const normalize = false; // don&#39;t normalize the data
+  const stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
+  const offset = 0;        // start at the beginning of the buffer
+  gl.vertexAttribPointer(
+    posTexIndexLoc, size, type, normalize, stride, offset);
+}
</code></pre>
<p>Note the size is 2, since there is 1 position index and 1 texcoord
index per vertex.</p>
<p>We then setup our vertex indices</p>
<pre class="prettyprint"><code class="lang-js">// Set our indices
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
</code></pre>
<p>Then we need to bind all 3 textures and setup all the
uniforms</p>
<pre class="prettyprint"><code class="lang-js">// Set the matrix.
gl.uniformMatrix4fv(matrixLoc, false, matrix);

// put the position texture on texture unit 0
gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, positionTexture);
// Tell the shader to use texture unit 0 for positionTexture
gl.uniform1i(positionTexLoc, 0);
// Tell the shader the size of the position texture
gl.uniform2f(positionTexSizeLoc, positions.length / 3, 1);

// put the texcoord texture on texture unit 1
gl.activeTexture(gl.TEXTURE0 + 1);
gl.bindTexture(gl.TEXTURE_2D, texcoordTexture);
// Tell the shader to use texture unit 1 for texcoordTexture
gl.uniform1i(texcoordTexLoc, 1);
// Tell the shader the size of the texcoord texture
gl.uniform2f(texcoordTexSizeLoc, uvs.length / 2, 1);

// put the checkboard texture on texture unit 2
gl.activeTexture(gl.TEXTURE0 + 2);
gl.bindTexture(gl.TEXTURE_2D, checkerTexture);
// Tell the shader to use texture unit 2 for u_texture
gl.uniform1i(u_textureLoc, 2);
</code></pre>
<p>And finally draw</p>
<pre class="prettyprint"><code class="lang-js">// Draw the geometry.
gl.drawElements(gl.TRIANGLES, 6 * 6, gl.UNSIGNED_SHORT, 0);
</code></pre>
<p>And we get a textured cube using only 8 positions and
4 texture coordinates</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-pulling-vertices.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-pulling-vertices.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>Some things to note. The code is lazy and uses 1D
textures for the positions and texture coordinates.
Textures can only be so wide. <a href="https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE">How wide is machine
specific</a> which you can query with </p>
<pre class="prettyprint"><code class="lang-js">const maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
</code></pre>
<p>If we wanted to handle more data than that we&#39;d need
to pick some texture size that fits our data, and spread
the data across multiple rows possibly
padding last row to make a rectangle.</p>
<p>Another thing we&#39;re doing here is using 2 textures,
one for positions, one for texture coordinates.
There is no reason we couldn&#39;t put both data in the
same texture either interleaved</p>
<pre class="prettyprint"><code>pos,uv,pos,uv,pos,uv...
</code></pre><p>or in different places in the texture</p>
<pre class="prettyprint"><code>pos,pos,pos,...
uv, uv, uv,...
</code></pre><p>We&#39;d just have to change the math in the vertex shader
that computes how to pull them out of the texture.</p>
<p>The question comes up, should you do things like this?
The answer is &quot;it depends&quot;. Depending on the GPU this
might be slower than the more traditional way.</p>
<p>The point of this article was to point out yet again,
WebGL doesn&#39;t care how you set <code>gl_Position</code> with
clip space coordinates nor does it care how you set
<code>gl_FragColor</code>. All it cares is that you set them.
Textures are really just 2D arrays of random access
data.</p>
<p>When you have a problem you want to solve in WebGL
remember that WebGL just runs shaders and those shaders
have access to data via uniforms (global variables),
attributes (data that comes per vertex shader iteration),
and textures (random access 2D arrays). Don&#39;t let the
traditional ways of using WebGL prevent you from
seeing the real flexibility that&#39;s there.</p>
<div class="webgl_bottombar">
<h3>Why is it called Vertex Pulling?</h3>
<p>I'd actually only heard the term recently (July 2019)
even thought I'd used the technique before. It comes
from [OpenGL Insights "Programmable Vertex Pulling" article by Daniel Rakos](https://www.google.com/search?q=OpenGL+Insights+"Programmable+Vertex+Pulling"+article+by+Daniel+Rakos).
</p>
<p>It's called vertex *pulling* since it's the vertex shader
that decides which vertex data to read vs the traditional way where
vertex data is supplied automatically via attributes. Effectively
the vertex shader is *pulling* data out of the textures.</p>
</div>
    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-pulling-vertices.html" selected>English</a>
    <option value="/webgl/lessons/fr/webgl-pulling-vertices.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-pulling-vertices.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-pulling-vertices.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-pulling-vertices.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-pulling-vertices.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-pulling-vertices.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-pulling-vertices.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Fundamentals</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgl/lessons/webgl-how-it-works.html">How It Works</a></li>
<li><a href="/webgl/lessons/webgl-shaders-and-glsl.html">Shaders and GLSL</a></li>
        </ul>
  <li>Image Processing</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-image-processing.html">Image Processing</a></li>
<li><a href="/webgl/lessons/webgl-image-processing-continued.html">Image Processing Continued</a></li>
        </ul>
  <li>2D translation, rotation, scale, matrix math</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-translation.html">2D Translation</a></li>
<li><a href="/webgl/lessons/webgl-2d-rotation.html">2D Rotation</a></li>
<li><a href="/webgl/lessons/webgl-2d-scale.html">2D Scale</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrices.html">2D Matrices</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-orthographic.html">Orthographic 3D</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective.html">3D Perspective</a></li>
<li><a href="/webgl/lessons/webgl-3d-camera.html">3D Cameras</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Structure and Organization</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/webgl-drawing-multiple-things.html">Drawing Multiple Things</a></li>
<li><a href="/webgl/lessons/webgl-scene-graph.html">Scene Graphs</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-geometry-lathe.html">Geometry - Lathe</a></li>
        </ul>
  <li>Textures</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-textures.html">Textures</a></li>
<li><a href="/webgl/lessons/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/webgl-2-textures.html">Using 2 or More Textures</a></li>
<li><a href="/webgl/lessons/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective-correct-texturemapping.html">Perspective Correct Texture Mapping</a></li>
        </ul>
  <li>Rendering To A Texture</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-render-to-texture.html">Render to Texture</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrix-stack.html">2D - Matrix Stack</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/webgl-fog.html">Fog</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-text-html.html">Text - HTML</a></li>
<li><a href="/webgl/lessons/webgl-text-canvas2d.html">Text - Canvas 2D</a></li>
<li><a href="/webgl/lessons/webgl-text-texture.html">Text - Using a Texture</a></li>
<li><a href="/webgl/lessons/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-setup-and-installation.html">Setup And Installation</a></li>
<li><a href="/webgl/lessons/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/webgl-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgl/lessons/webgl-animation.html">Animation</a></li>
<li><a href="/webgl/lessons/webgl-and-alpha.html">WebGL and Alpha</a></li>
<li><a href="/webgl/lessons/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/webgl-texture-units.html">Texture Units</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="http://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgl">Ask on stackoverflow</a>.</div>
        <div>Issue/Bug? <a href="http://github.com/gfxfundamentals/webgl-fundamentals/issues">Create an issue on github</a>.</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL Pulling Vertices';
            var disqus_title = 'WebGL Pulling Vertices';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script src="//cdn.webglstats.com/stat.js" defer="defer" async="async"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');

</script>


</html>



